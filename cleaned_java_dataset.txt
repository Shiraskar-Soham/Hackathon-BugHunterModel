package com.ofb.crawler.commons.types.gstToPan.dto.response;

public class PanToGstElementDto {
    private String gstIn;

    public PanToGstElementDto() {
    }

    public PanToGstElementDto(String gstIn) {
        this.gstIn = gstIn;
    }

    public String getGstIn() {
        return gstIn;
    }

    public void setGstIn(String gstIn) {
        this.gstIn = gstIn;
    }

    public static interface GstinStep {
        BuildStep withGstin(String gstin);
    }

    public static interface BuildStep {
        PanToGstElementDto build();
    }

    public static class Builder implements GstinStep, BuildStep {
        private String gstin;

        private Builder() {
        }

        public static GstinStep panToGstListResponseDto() {
            return new Builder();
        }

        @Override
        public BuildStep withGstin(String gstin) {
            this.gstin = gstin;
            return this;
        }

        @Override
        public PanToGstElementDto build() {
            return new PanToGstElementDto(
                this.gstin
            );
        }
    }
}


package com.ofb.crawler.commons.types.gstInfo.dto.response;

@Data
@NoArgsConstructor
public class GstInfoResponseDto extends BaseS3ResponseDto {

    private GstInfoResponse gstInfoResponse;

    private GstInfoTaskParamsDto gstInfoTaskParamsDto;

    public GstInfoResponseDto(GstInfoResponse gstInfoResponse, GstInfoTaskParamsDto gstInfoTaskParamsDto) {
        this.gstInfoResponse = gstInfoResponse;
        this.gstInfoTaskParamsDto = gstInfoTaskParamsDto;
    }

    public GstInfoResponseDto(String parsingId, TaskType taskType, long parsingTime, BaseTaskParamsDto baseTaskParamsDto, GstInfoResponse gstInfoResponse, GstInfoTaskParamsDto gstInfoTaskParamsDto) {
        super(parsingId, taskType, parsingTime, baseTaskParamsDto);
        this.gstInfoResponse = gstInfoResponse;
        this.gstInfoTaskParamsDto = gstInfoTaskParamsDto;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
        GstInfoResponseDto that = (GstInfoResponseDto) o;
        return Objects.equals(gstInfoResponse, that.gstInfoResponse) && Objects.equals(gstInfoTaskParamsDto, that.gstInfoTaskParamsDto);
    }

    @Override
    public int hashCode() {
        return Objects.hash(super.hashCode(), gstInfoResponse, gstInfoTaskParamsDto);
    }

    public static interface ParsingIdStep {
        TaskTypeStep withParsingId(String parsingId);
    }

    public static interface TaskTypeStep {
        ParsingTimeStep withTaskType(TaskType taskType);
    }

    public static interface ParsingTimeStep {
        BaseTaskParamsDtoStep withParsingTime(long parsingTime);
    }

    public static interface BaseTaskParamsDtoStep {
        GstInfoResponseStep withBaseTaskParamsDto(BaseTaskParamsDto baseTaskParamsDto);
    }

    public static interface GstInfoResponseStep {
        GstInfoTaskParamsDtoStep withGstInfoResponse(GstInfoResponse gstInfoResponse);
    }

    public static interface GstInfoTaskParamsDtoStep {
        BuildStep withGstInfoTaskParamsDto(GstInfoTaskParamsDto gstInfoTaskParamsDto);
    }

    public static interface BuildStep {
        GstInfoResponseDto build();
    }


    public static class Builder implements ParsingIdStep, TaskTypeStep, ParsingTimeStep, BaseTaskParamsDtoStep, GstInfoResponseStep, GstInfoTaskParamsDtoStep, BuildStep {
        private String parsingId;
        private TaskType taskType;
        private long parsingTime;
        private BaseTaskParamsDto baseTaskParamsDto;
        private GstInfoResponse gstInfoResponse;
        private GstInfoTaskParamsDto gstInfoTaskParamsDto;

        private Builder() {
        }

        public static ParsingIdStep gstInfoResponseDto() {
            return new Builder();
        }

        @Override
        public TaskTypeStep withParsingId(String parsingId) {
            this.parsingId = parsingId;
            return this;
        }

        @Override
        public ParsingTimeStep withTaskType(TaskType taskType) {
            this.taskType = taskType;
            return this;
        }

        @Override
        public BaseTaskParamsDtoStep withParsingTime(long parsingTime) {
            this.parsingTime = parsingTime;
            return this;
        }

        @Override
        public GstInfoResponseStep withBaseTaskParamsDto(BaseTaskParamsDto baseTaskParamsDto) {
            this.baseTaskParamsDto = baseTaskParamsDto;
            return this;
        }

        @Override
        public GstInfoTaskParamsDtoStep withGstInfoResponse(GstInfoResponse gstInfoResponse) {
            this.gstInfoResponse = gstInfoResponse;
            return this;
        }

        @Override
        public BuildStep withGstInfoTaskParamsDto(GstInfoTaskParamsDto gstInfoTaskParamsDto) {
            this.gstInfoTaskParamsDto = gstInfoTaskParamsDto;
            return this;
        }

        @Override
        public GstInfoResponseDto build() {
            return new GstInfoResponseDto(
                    this.parsingId,
                    this.taskType,
                    this.parsingTime,
                    this.baseTaskParamsDto,
                    this.gstInfoResponse,
                    this.gstInfoTaskParamsDto
            );
        }
    }
}

package com.ofb.crawler.commons.types.gstReturn.dto.response;

@Data
@NoArgsConstructor
public class GstReturnResponseDto extends BaseS3ResponseDto {

    private List<GstFiledDetailsDto> efiledList;

    private GstReturnTaskParamsDto gstReturnTaskParamsDto;

    public GstReturnResponseDto(List<GstFiledDetailsDto> efiledList, GstReturnTaskParamsDto gstReturnTaskParamsDto) {
        this.efiledList = efiledList;
        this.gstReturnTaskParamsDto = gstReturnTaskParamsDto;
    }

    public GstReturnResponseDto(String parsingId, TaskType taskType, long parsingTime, BaseTaskParamsDto baseTaskParamsDto, List<GstFiledDetailsDto> efiledList, GstReturnTaskParamsDto gstReturnTaskParamsDto) {
        super(parsingId, taskType, parsingTime, baseTaskParamsDto);
        this.efiledList = efiledList;
        this.gstReturnTaskParamsDto = gstReturnTaskParamsDto;
    }

    public static interface ParsingIdStep {
        TaskTypeStep withParsingId(String parsingId);
    }

    public static interface TaskTypeStep {
        ParsingTimeStep withTaskType(TaskType taskType);
    }

    public static interface ParsingTimeStep {
        BaseTaskParamsDtoStep withParsingTime(long parsingTime);
    }

    public static interface BaseTaskParamsDtoStep {
        EfiledListStep withBaseTaskParamsDto(BaseTaskParamsDto baseTaskParamsDto);
    }

    public static interface EfiledListStep {
        GstReturnTaskParamsDtoStep withEfiledList(List<GstFiledDetailsDto> efiledList);
    }

    public static interface GstReturnTaskParamsDtoStep {
        BuildStep withGstReturnTaskParamsDto(GstReturnTaskParamsDto gstReturnTaskParamsDto);
    }

    public static interface BuildStep {
        GstReturnResponseDto build();
    }


    public static class Builder implements ParsingIdStep, TaskTypeStep, ParsingTimeStep, BaseTaskParamsDtoStep, EfiledListStep, GstReturnTaskParamsDtoStep, BuildStep {
        private String parsingId;
        private TaskType taskType;
        private long parsingTime;
        private BaseTaskParamsDto baseTaskParamsDto;
        private List<GstFiledDetailsDto> efiledList;
        private GstReturnTaskParamsDto gstReturnTaskParamsDto;

        private Builder() {
        }

        public static ParsingIdStep gstReturnResponseDto() {
            return new Builder();
        }

        @Override
        public TaskTypeStep withParsingId(String parsingId) {
            this.parsingId = parsingId;
            return this;
        }

        @Override
        public ParsingTimeStep withTaskType(TaskType taskType) {
            this.taskType = taskType;
            return this;
        }

        @Override
        public BaseTaskParamsDtoStep withParsingTime(long parsingTime) {
            this.parsingTime = parsingTime;
            return this;
        }

        @Override
        public EfiledListStep withBaseTaskParamsDto(BaseTaskParamsDto baseTaskParamsDto) {
            this.baseTaskParamsDto = baseTaskParamsDto;
            return this;
        }

        @Override
        public GstReturnTaskParamsDtoStep withEfiledList(List<GstFiledDetailsDto> efiledList) {
            this.efiledList = efiledList;
            return this;
        }

        @Override
        public BuildStep withGstReturnTaskParamsDto(GstReturnTaskParamsDto gstReturnTaskParamsDto) {
            this.gstReturnTaskParamsDto = gstReturnTaskParamsDto;
            return this;
        }

        @Override
        public GstReturnResponseDto build() {
            return new GstReturnResponseDto(
                    this.parsingId,
                    this.taskType,
                    this.parsingTime,
                    this.baseTaskParamsDto,
                    this.efiledList,
                    this.gstReturnTaskParamsDto
            );
        }
    }
}

package com.ofb.crawler.core.types.panToGst.service;

@Service
public class PanToGstParserCallback extends BaseParserCallback<PanToGstDetailResponseDto, PanToGstTaskParamsDto> {

    private static final Logger logger = LoggerFactory.getLogger(GstInfoParserCallback.class);

    private static final ObjectMapper objectMapper = ObjectUtils.objectMapper();

    private static final String homePageUrl =
            "https:

    private static final String gstListUrl = "https:

    private static final String stateCodeUrl = "https:

    private static final String captchaUrl = "https:

    private static final Integer NUMBER_OF_ATTEMPTS_TO_BREAK_CAPTCHA = 15;

    private static final String CAPTCHA_SERVER_PATH = "/gst_info/captcha";

    private static final Map<String, String> STATE_CODE_MAP = new HashMap<>();

    @Override
    public PanToGstDetailResponseDto parse(PanToGstTaskParamsDto parsingParams) throws Throwable {
        List<GstInfoResponse> finalList = parsePanToGst(parsingParams);
        return PanToGstDetailResponseDto.Builder.panToGstDetailResponseDto()
            .withParsingId(String.valueOf(UUID.randomUUID()))
            .withTaskType(getTaskType())
            .withParsingTime(System.currentTimeMillis())
            .withBaseTaskParamsDto(null)
            .withGstInfoResponsesList(finalList)
            .build();
    }

    private static List<GstInfoResponse> parsePanToGst(PanToGstTaskParamsDto panToGstTaskParamsDto) throws Exception {
        Long startTime = System.currentTimeMillis();
        Integer totalAttempts = 0;
        String cookie = getHomePageCookie();
        logger.info(String.format("Pan to Gst detail API || %s || Getting initial cookies took : %s ms", panToGstTaskParamsDto.getPan(), System.currentTimeMillis() - startTime));
        File tempFile = getTempFile(TaskType.GST_INFO, "captcha", ".jpeg");
        List<GstInfoResponse> finalList = new ArrayList<>();
        if (!tempFile.createNewFile()) {
            throw new IOException("Failed to create a temporary file.");
        }
        try {
            for (int iterator = 0; iterator < NUMBER_OF_ATTEMPTS_TO_BREAK_CAPTCHA; iterator++) {
                logger.info(String.format("Pan to GST detail API || %s || Iteration number %d", panToGstTaskParamsDto.getPan(), iterator));
                Long iterationStartTime = System.currentTimeMillis();

                List<PanToGstElementDto> panToGstElementDtos = getCaptchaAndTry(cookie, tempFile, panToGstTaskParamsDto.getPan());

                totalAttempts++;
                logger.info(String.format("GST detail API || %s || Complete iteration took : %s ms", panToGstTaskParamsDto.getPan(), System.currentTimeMillis() - iterationStartTime));
                if (panToGstElementDtos != null) {
                    for (PanToGstElementDto element : panToGstElementDtos) {
                        if(getDetails(element.getGstIn()) == null) {
                            continue;
                        }
                        finalList.add(getDetails(element.getGstIn()));
                    }
                    System.out.println(finalList);
                    logger.info(String.format("GST detail API || %s || Total number of captcha attempts is %s", panToGstTaskParamsDto.getPan(), totalAttempts));
                    logger.info(String.format("GST detail API || %s || Complete service layer took: %s ms", panToGstTaskParamsDto.getPan(), System.currentTimeMillis() - startTime));
                    return finalList ;
                }
            }
        } catch (Exception e) {
            throw e;
        } finally {
            FileUtils.deleteSilently(tempFile);
        }
        throw new Exception("Unable to break captcha, max attempts reached");

    }

    private static List<PanToGstElementDto> getCaptchaAndTry(String cookie, File tempFile, String pan) throws Exception {
        Long startTime = System.currentTimeMillis();
        String responseCookies = CaptchaSaver.saveCaptchaImage(TaskType.PAN_TO_GST, captchaUrl, getHeadersForCaptcha(cookie), tempFile);
        logger.info(String.format("Pan to GST detail API || %s || Getting captcha and captcha cookies took : %d ms", pan, System.currentTimeMillis() - startTime));
        startTime = System.currentTimeMillis();
        String captchaResult = null;
        File clearFile = PreProcessCaptcha.preProcessImage(TaskType.GST_INFO, tempFile);
        try {
            logger.info(String.format("Pan to GST detail API || %s || preprocessing captcha file took : %d ms", pan,
                    System.currentTimeMillis() - startTime));
            startTime = System.currentTimeMillis();
            captchaResult =
                    CaptchaServer.solveCaptchaNew(CAPTCHA_SERVER_PATH, clearFile);
        } finally {
            FileUtils.deleteSilently(clearFile);
        }
        logger.info(String.format("Pan to GST detail API || %s || Solving captcha took : %d ms", pan, System.currentTimeMillis() - startTime));

        List<PanToGstElementDto> panToGstElementDtos = getPanToGstList(captchaResult, responseCookies, pan);

        return panToGstElementDtos;
    }

    private static List<PanToGstElementDto> getPanToGstList(String captchaResult, String responseCookies, String pan) {
        if (captchaResult == null || captchaResult.length() != 6) {
            logger.info(
                    String.format("GST detail API || %s || invalid Captcha Received From Captcha Server Retrying ", pan));
            return null;
        }
        HashMap<String, String> apiHeaders = new HashMap<>();
        apiHeaders.put("Content-Type", "application/json;charset=UTF-8");
        apiHeaders.put("cookie", responseCookies);
        apiHeaders.put("Origin", "https:
        apiHeaders.put("Referer", homePageUrl);

        List<PanToGstElementDto> panToGstElementDtos = new ArrayList<>();
        String apiResponse;
        try {
            JSONObject obj = new JSONObject();
            obj.put("panNO", pan);
            obj.put("captcha", captchaResult);
            apiResponse = HttpAsyncClientUtils.quietPost(TaskType.PAN_TO_GST, gstListUrl, obj.toString(), apiHeaders);
            JSONObject jsonObject = new JSONObject(apiResponse);
            JSONArray gstinResListArray = jsonObject.getJSONArray("gstinResList");
            for (int i = 0; i < gstinResListArray.length(); i++) {
                JSONObject gstinObject = gstinResListArray.getJSONObject(i);
                panToGstElementDtos.add(PanToGstElementDto.Builder.panToGstListResponseDto()
                    .withGstin(gstinObject.getString("gstin"))
                    .build());
            }
        } catch (Exception e) {
            logger.error(String.format("Govt Gst Return API Failed for gstIn : %s", pan), e);
            return null;
        }

        return panToGstElementDtos;
    }


    @Override
    public TaskType getTaskType() {
        return TaskType.PAN_TO_GST;
    }

    public static void main(String[] args) throws Throwable {
        String pan = "AAACR5055K";
        long startTime = System.currentTimeMillis();
        PanToGstTaskParamsDto panToGstTaskParamsDto = PanToGstTaskParamsDto.Builder.panToGstTaskParamsDto()
                .withRequestId(null)
                .withCompanyName(null)
                .withCin(null)
                .withGstIn(null)
                .withPan(pan)
                .build();
        List<GstInfoResponse> panToGstDetailResponseDto = parsePanToGst(panToGstTaskParamsDto);
        Long fetchtime = System.currentTimeMillis() - startTime;
        System.out.println("Fetched in: " + fetchtime);
        System.out.println(panToGstDetailResponseDto);
    }
}


package com.ofb.crawler.commons.types.mca.dto;

public class CompanyChargesDataCrawlDto {

    @JsonProperty("chargeId")
    private String chargeId;

    @JsonProperty("SRN")
    private String srn;

    @JsonProperty("chargeHolderName")
    private String chargeHolderName;

    @JsonProperty("dateOfCreation")
    private String dateOfCreation;

    @JsonProperty("dateOfModification")
    private String dateOfModification;

    @JsonProperty("dateOfSatisfaction")
    private String dateOfSatisfaction;

    @JsonProperty("amount")
    private BigDecimal amount;

    @JsonProperty("StreetAddress")
    private String streetAddress;

    @JsonProperty("StreetAddress2")
    private String streetAddress2;

    @JsonProperty("StreetAddress3")
    private String streetAddress3;

    @JsonProperty("StreetAddress4")
    private String streetAddress4;

    @JsonProperty("Country")
    private String country;

    @JsonProperty("Locality")
    private String locality;

    @JsonProperty("State")
    private String state;

    @JsonProperty("District")
    private String district;

    @JsonProperty("City")
    private String city;

    @JsonProperty("PostalCode")
    private Integer postalCode;

    @JsonProperty("registeredName")
    private String registeredName;

    @JsonProperty("propertyIntUnRegdFlag")
    private String propertyIntUnRegdFlag;

    @JsonProperty("chName")
    private String chargeName;

    @JsonProperty("chargeStatus")
    private String chargeStatus;

    public CompanyChargesDataCrawlDto() {
    }

    public CompanyChargesDataCrawlDto(String chargeId, String srn, String chargeHolderName, String dateOfCreation,
        String dateOfModification, String dateOfSatisfaction, BigDecimal amount, String streetAddress,
        String streetAddress2, String streetAddress3, String streetAddress4, String country, String locality,
        String state, String district, String city, Integer postalCode, String registeredName,
        String propertyIntUnRegdFlag, String chargeName, String chargeStatus) {
        this.chargeId = chargeId;
        this.srn = srn;
        this.chargeHolderName = chargeHolderName;
        this.dateOfCreation = dateOfCreation;
        this.dateOfModification = dateOfModification;
        this.dateOfSatisfaction = dateOfSatisfaction;
        this.amount = amount;
        this.streetAddress = streetAddress;
        this.streetAddress2 = streetAddress2;
        this.streetAddress3 = streetAddress3;
        this.streetAddress4 = streetAddress4;
        this.country = country;
        this.locality = locality;
        this.state = state;
        this.district = district;
        this.city = city;
        this.postalCode = postalCode;
        this.registeredName = registeredName;
        this.propertyIntUnRegdFlag = propertyIntUnRegdFlag;
        this.chargeName = chargeName;
        this.chargeStatus = chargeStatus;
    }

    public String getChargeId() {
        return chargeId;
    }

    public void setChargeId(String chargeId) {
        this.chargeId = chargeId;
    }

    public String getSrn() {
        return srn;
    }

    public void setSrn(String srn) {
        this.srn = srn;
    }

    public String getChargeHolderName() {
        return chargeHolderName;
    }

    public void setChargeHolderName(String chargeHolderName) {
        this.chargeHolderName = chargeHolderName;
    }

    public String getDateOfCreation() {
        return dateOfCreation;
    }

    public void setDateOfCreation(String dateOfCreation) {
        this.dateOfCreation = dateOfCreation;
    }

    public String getDateOfModification() {
        return dateOfModification;
    }

    public void setDateOfModification(String dateOfModification) {
        this.dateOfModification = dateOfModification;
    }

    public String getDateOfSatisfaction() {
        return dateOfSatisfaction;
    }

    public void setDateOfSatisfaction(String dateOfSatisfaction) {
        this.dateOfSatisfaction = dateOfSatisfaction;
    }

    public BigDecimal getAmount() {
        return amount;
    }

    public void setAmount(BigDecimal amount) {
        this.amount = amount;
    }

    public String getStreetAddress() {
        return streetAddress;
    }

    public void setStreetAddress(String streetAddress) {
        this.streetAddress = streetAddress;
    }

    public String getStreetAddress2() {
        return streetAddress2;
    }

    public void setStreetAddress2(String streetAddress2) {
        this.streetAddress2 = streetAddress2;
    }

    public String getStreetAddress3() {
        return streetAddress3;
    }

    public void setStreetAddress3(String streetAddress3) {
        this.streetAddress3 = streetAddress3;
    }

    public String getStreetAddress4() {
        return streetAddress4;
    }

    public void setStreetAddress4(String streetAddress4) {
        this.streetAddress4 = streetAddress4;
    }

    public String getCountry() {
        return country;
    }

    public void setCountry(String country) {
        this.country = country;
    }

    public String getLocality() {
        return locality;
    }

    public void setLocality(String locality) {
        this.locality = locality;
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }

    public String getDistrict() {
        return district;
    }

    public void setDistrict(String district) {
        this.district = district;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public Integer getPostalCode() {
        return postalCode;
    }

    public void setPostalCode(Integer postalCode) {
        this.postalCode = postalCode;
    }

    public String getRegisteredName() {
        return registeredName;
    }

    public void setRegisteredName(String registeredName) {
        this.registeredName = registeredName;
    }

    public String getPropertyIntUnRegdFlag() {
        return propertyIntUnRegdFlag;
    }

    public void setPropertyIntUnRegdFlag(String propertyIntUnRegdFlag) {
        this.propertyIntUnRegdFlag = propertyIntUnRegdFlag;
    }

    public String getChargeName() {
        return chargeName;
    }

    public void setChargeName(String chargeName) {
        this.chargeName = chargeName;
    }

    public String getChargeStatus() {
        return chargeStatus;
    }

    public void setChargeStatus(String chargeStatus) {
        this.chargeStatus = chargeStatus;
    }

    public static interface ChargeIdStep {
        SrnStep withChargeId(String chargeId);
    }

    public static interface SrnStep {
        ChargeHolderNameStep withSrn(String srn);
    }

    public static interface ChargeHolderNameStep {
        DateOfCreationStep withChargeHolderName(String chargeHolderName);
    }

    public static interface DateOfCreationStep {
        DateOfModificationStep withDateOfCreation(String dateOfCreation);
    }

    public static interface DateOfModificationStep {
        DateOfSatisfactionStep withDateOfModification(String dateOfModification);
    }

    public static interface DateOfSatisfactionStep {
        AmountStep withDateOfSatisfaction(String dateOfSatisfaction);
    }

    public static interface AmountStep {
        StreetAddressStep withAmount(BigDecimal amount);
    }

    public static interface StreetAddressStep {
        StreetAddress2Step withStreetAddress(String streetAddress);
    }

    public static interface StreetAddress2Step {
        StreetAddress3Step withStreetAddress2(String streetAddress2);
    }

    public static interface StreetAddress3Step {
        StreetAddress4Step withStreetAddress3(String streetAddress3);
    }

    public static interface StreetAddress4Step {
        CountryStep withStreetAddress4(String streetAddress4);
    }

    public static interface CountryStep {
        LocalityStep withCountry(String country);
    }

    public static interface LocalityStep {
        StateStep withLocality(String locality);
    }

    public static interface StateStep {
        DistrictStep withState(String state);
    }

    public static interface DistrictStep {
        CityStep withDistrict(String district);
    }

    public static interface CityStep {
        PostalCodeStep withCity(String city);
    }

    public static interface PostalCodeStep {
        RegisteredNameStep withPostalCode(Integer postalCode);
    }

    public static interface RegisteredNameStep {
        PropertyIntUnRegdFlagStep withRegisteredName(String registeredName);
    }

    public static interface PropertyIntUnRegdFlagStep {
        ChargeNameStep withPropertyIntUnRegdFlag(String propertyIntUnRegdFlag);
    }

    public static interface ChargeNameStep {
        ChargeStatusStep withChargeName(String chargeName);
    }

    public static interface ChargeStatusStep {
        BuildStep withChargeStatus(String chargeStatus);
    }

    public static interface BuildStep {
        CompanyChargesDataCrawlDto build();
    }

    public static class Builder
        implements ChargeIdStep, SrnStep, ChargeHolderNameStep, DateOfCreationStep, DateOfModificationStep,
        DateOfSatisfactionStep, AmountStep, StreetAddressStep, StreetAddress2Step, StreetAddress3Step,
        StreetAddress4Step, CountryStep, LocalityStep, StateStep, DistrictStep, CityStep, PostalCodeStep,
        RegisteredNameStep, PropertyIntUnRegdFlagStep, ChargeNameStep, ChargeStatusStep, BuildStep {
        private String chargeId;
        private String srn;
        private String chargeHolderName;
        private String dateOfCreation;
        private String dateOfModification;
        private String dateOfSatisfaction;
        private BigDecimal amount;
        private String streetAddress;
        private String streetAddress2;
        private String streetAddress3;
        private String streetAddress4;
        private String country;
        private String locality;
        private String state;
        private String district;
        private String city;
        private Integer postalCode;
        private String registeredName;
        private String propertyIntUnRegdFlag;
        private String chargeName;
        private String chargeStatus;

        private Builder() {
        }

        public static ChargeIdStep companyChargesDataCrawlDto() {
            return new Builder();
        }

        @Override
        public SrnStep withChargeId(String chargeId) {
            this.chargeId = chargeId;
            return this;
        }

        @Override
        public ChargeHolderNameStep withSrn(String srn) {
            this.srn = srn;
            return this;
        }

        @Override
        public DateOfCreationStep withChargeHolderName(String chargeHolderName) {
            this.chargeHolderName = chargeHolderName;
            return this;
        }

        @Override
        public DateOfModificationStep withDateOfCreation(String dateOfCreation) {
            this.dateOfCreation = dateOfCreation;
            return this;
        }

        @Override
        public DateOfSatisfactionStep withDateOfModification(String dateOfModification) {
            this.dateOfModification = dateOfModification;
            return this;
        }

        @Override
        public AmountStep withDateOfSatisfaction(String dateOfSatisfaction) {
            this.dateOfSatisfaction = dateOfSatisfaction;
            return this;
        }

        @Override
        public StreetAddressStep withAmount(BigDecimal amount) {
            this.amount = amount;
            return this;
        }

        @Override
        public StreetAddress2Step withStreetAddress(String streetAddress) {
            this.streetAddress = streetAddress;
            return this;
        }

        @Override
        public StreetAddress3Step withStreetAddress2(String streetAddress2) {
            this.streetAddress2 = streetAddress2;
            return this;
        }

        @Override
        public StreetAddress4Step withStreetAddress3(String streetAddress3) {
            this.streetAddress3 = streetAddress3;
            return this;
        }

        @Override
        public CountryStep withStreetAddress4(String streetAddress4) {
            this.streetAddress4 = streetAddress4;
            return this;
        }

        @Override
        public LocalityStep withCountry(String country) {
            this.country = country;
            return this;
        }

        @Override
        public StateStep withLocality(String locality) {
            this.locality = locality;
            return this;
        }

        @Override
        public DistrictStep withState(String state) {
            this.state = state;
            return this;
        }

        @Override
        public CityStep withDistrict(String district) {
            this.district = district;
            return this;
        }

        @Override
        public PostalCodeStep withCity(String city) {
            this.city = city;
            return this;
        }

        @Override
        public RegisteredNameStep withPostalCode(Integer postalCode) {
            this.postalCode = postalCode;
            return this;
        }

        @Override
        public PropertyIntUnRegdFlagStep withRegisteredName(String registeredName) {
            this.registeredName = registeredName;
            return this;
        }

        @Override
        public ChargeNameStep withPropertyIntUnRegdFlag(String propertyIntUnRegdFlag) {
            this.propertyIntUnRegdFlag = propertyIntUnRegdFlag;
            return this;
        }

        @Override
        public ChargeStatusStep withChargeName(String chargeName) {
            this.chargeName = chargeName;
            return this;
        }

        @Override
        public BuildStep withChargeStatus(String chargeStatus) {
            this.chargeStatus = chargeStatus;
            return this;
        }

        @Override
        public CompanyChargesDataCrawlDto build() {
            return new CompanyChargesDataCrawlDto(
                this.chargeId,
                this.srn,
                this.chargeHolderName,
                this.dateOfCreation,
                this.dateOfModification,
                this.dateOfSatisfaction,
                this.amount,
                this.streetAddress,
                this.streetAddress2,
                this.streetAddress3,
                this.streetAddress4,
                this.country,
                this.locality,
                this.state,
                this.district,
                this.city,
                this.postalCode,
                this.registeredName,
                this.propertyIntUnRegdFlag,
                this.chargeName,
                this.chargeStatus
            );
        }
    }
}


package com.ofb.crawler.commons.util;

public class EventUtils {

    private static final Logger logger = LoggerFactory.getLogger(EventUtils.class);

    public static <T> void consumeEvent(Request<T> request, Callback callback, Callback exceptionCallback) throws Exception {

        Long jmsOutTimeStamp = System.currentTimeMillis();
        Long jmsInTimeStamp = null;
        Long timeInBroker = null;
        try {
            jmsInTimeStamp = request.getMessage().getJMSTimestamp();
            timeInBroker = (jmsOutTimeStamp - jmsInTimeStamp);
        } catch (JMSException ignore) {
        }

        T event = request.getPayload();
        String classNameOfEvent = Optional.ofNullable(event.getClass().getName()).orElse("");
        String eventStr = getEventString(event);

        logger.info(String.format("JMS Received : event message of class [%s] and payload [%s]." +
                " Broker in time [%s], Broker out time [%s], Time in broker [%s] ms",
            classNameOfEvent, eventStr,
            jmsInTimeStamp, jmsOutTimeStamp, timeInBroker));

        try {
            callback.call();
        } catch (Throwable throwable) {
            logger.error("Exception occurred while executing callback during event consumption {}", throwable);
            try {
                exceptionCallback.call();
            } catch (Throwable throwable1) {
                logger.error("Exception occurred while executing exception callback during event consumption {}",
                    throwable1);
                throw new Exception(throwable);
            }
        }

        long processingTime = System.currentTimeMillis() - jmsOutTimeStamp;
        logger.info(String.format("JMS Processed : event message of class [%s] and payload [%s]." +
                " Broker in time [%s], Broker out time [%s], Time in broker [%s] ms. Processing time [%s] ms",
            classNameOfEvent, eventStr,
            jmsInTimeStamp, jmsOutTimeStamp, timeInBroker, processingTime));
    }

    private static <T> String getEventString(T event) {
        try {
            return ObjectUtils.objectMapper().writeValueAsString(event);
        } catch (JsonProcessingException e) {
            return event.toString();
        }
    }
}


package com.ofb.crawler.commons.types.gstReturn.dto.response;

@Data
@NoArgsConstructor
public class GstFiledDetailsDto {

    @JsonProperty("fy")
    private String fiscalYear;

    @JsonProperty("mof")
    private String modeOfFiling;

    @JsonProperty("dof")
    private String dateOfFiling;

    @JsonProperty("rtntype")
    private String returnType;

    @JsonProperty("taxp")
    private String taxPeriod;

    @JsonProperty("arn")
    private String arnNumber;

    @JsonProperty("status")
    private String status;

    @JsonProperty("valid")
    private String valid;

    public GstFiledDetailsDto(String fiscalYear, String modeOfFiling, String dateOfFiling, String returnType, String taxPeriod, String arnNumber, String status, String valid) {
        this.fiscalYear = fiscalYear;
        this.modeOfFiling = modeOfFiling;
        this.dateOfFiling = dateOfFiling;
        this.returnType = returnType;
        this.taxPeriod = taxPeriod;
        this.arnNumber = arnNumber;
        this.status = status;
        this.valid = valid;
    }

    public static interface FiscalYearStep {
        ModeOfFilingStep withFiscalYear(String fiscalYear);
    }

    public static interface ModeOfFilingStep {
        DateOfFilingStep withModeOfFiling(String modeOfFiling);
    }

    public static interface DateOfFilingStep {
        ReturnTypeStep withDateOfFiling(String dateOfFiling);
    }

    public static interface ReturnTypeStep {
        TaxPeriodStep withReturnType(String returnType);
    }

    public static interface TaxPeriodStep {
        ArnNumberStep withTaxPeriod(String taxPeriod);
    }

    public static interface ArnNumberStep {
        StatusStep withArnNumber(String arnNumber);
    }

    public static interface StatusStep {
        ValidStep withStatus(String status);
    }

    public static interface ValidStep {
        BuildStep withValid(String valid);
    }

    public static interface BuildStep {
        GstFiledDetailsDto build();
    }


    public static class Builder implements FiscalYearStep, ModeOfFilingStep, DateOfFilingStep, ReturnTypeStep, TaxPeriodStep, ArnNumberStep, StatusStep, ValidStep, BuildStep {
        private String fiscalYear;
        private String modeOfFiling;
        private String dateOfFiling;
        private String returnType;
        private String taxPeriod;
        private String arnNumber;
        private String status;
        private String valid;

        private Builder() {
        }

        public static FiscalYearStep GstFiledDetailsDto() {
            return new Builder();
        }

        @Override
        public ModeOfFilingStep withFiscalYear(String fiscalYear) {
            this.fiscalYear = fiscalYear;
            return this;
        }

        @Override
        public DateOfFilingStep withModeOfFiling(String modeOfFiling) {
            this.modeOfFiling = modeOfFiling;
            return this;
        }

        @Override
        public ReturnTypeStep withDateOfFiling(String dateOfFiling) {
            this.dateOfFiling = dateOfFiling;
            return this;
        }

        @Override
        public TaxPeriodStep withReturnType(String returnType) {
            this.returnType = returnType;
            return this;
        }

        @Override
        public ArnNumberStep withTaxPeriod(String taxPeriod) {
            this.taxPeriod = taxPeriod;
            return this;
        }

        @Override
        public StatusStep withArnNumber(String arnNumber) {
            this.arnNumber = arnNumber;
            return this;
        }

        @Override
        public ValidStep withStatus(String status) {
            this.status = status;
            return this;
        }

        @Override
        public BuildStep withValid(String valid) {
            this.valid = valid;
            return this;
        }

        @Override
        public GstFiledDetailsDto build() {
            return new GstFiledDetailsDto(
                    this.fiscalYear,
                    this.modeOfFiling,
                    this.dateOfFiling,
                    this.returnType,
                    this.taxPeriod,
                    this.arnNumber,
                    this.status,
                    this.valid
            );
        }
    }
}


package com.ofb.crawler.commons.types.mca.dto;

public class CompanyDataDto {

    private String cin;

    private String companyName;

    private String companyType;

    private String companyOrigin;

    private String registrationNumber;

    private Long dateOfIncorporation;

    private String emailAddress;

    private String whetherListedOrNot;

    private String companyCategory;

    private String companySubcategory;

    private String classOfCompany;

    private BigDecimal authorisedCapital;

    private BigDecimal paidUpCapital;

    private Long numberOfMembers;

    private Long dateOfLastAGM;

    private Long strikeOffAmalgamatedTransferredDate;

    private String llpStatus;

    private String statusUnderCIRP;

    private Long numberOfPartners;

    private Long numberOfDesignatedPartners;

    private Long totalObligationOfContribution;

    private String mainDivision;

    private String mainDivisionDescription;

    private Long statementDate;

    private String BSDefaulter2Yrs;

    private String BSDefaulter3Yrs;

    private String ARDefaulter2Yrs;

    private String ARDefaulter3Yrs;

    private String suspendedAtStockExchange;

    private List<CompanyAddressDto> companyAddress;

    private List<CompanyFilingEntryDto> balanceSheet3years;

    private List<CompanyFilingEntryDto> annualReturns3years;

    private String rocName;

    private String shareCapitalFlag;

    private String maximumNumberOfMembers;

    private String subscribedCapital;

    private String rdName;

    private String rdRegion;

    private Long balanceSheetDate;

    private String inc22Aflag;

    public CompanyDataDto() {
    }

    public CompanyDataDto(String cin, String companyName, String companyType, String companyOrigin,
        String registrationNumber, Long dateOfIncorporation, String emailAddress, String whetherListedOrNot,
        String companyCategory, String companySubcategory, String classOfCompany, BigDecimal authorisedCapital,
        BigDecimal paidUpCapital, Long numberOfMembers, Long dateOfLastAGM, Long strikeOffAmalgamatedTransferredDate,
        String llpStatus, String statusUnderCIRP, Long numberOfPartners, Long numberOfDesignatedPartners,
        Long totalObligationOfContribution, String mainDivision, String mainDivisionDescription,
        Long statementDate, String BSDefaulter2Yrs, String BSDefaulter3Yrs, String ARDefaulter2Yrs,
        String ARDefaulter3Yrs, String suspendedAtStockExchange,
        List<CompanyAddressDto> companyAddress,
        List<CompanyFilingEntryDto> balanceSheet3years,
        List<CompanyFilingEntryDto> annualReturns3years, String rocName, String shareCapitalFlag,
        String maximumNumberOfMembers, String subscribedCapital, String rdName, String rdRegion,
        Long balanceSheetDate, String inc22Aflag) {
        this.cin = cin;
        this.companyName = companyName;
        this.companyType = companyType;
        this.companyOrigin = companyOrigin;
        this.registrationNumber = registrationNumber;
        this.dateOfIncorporation = dateOfIncorporation;
        this.emailAddress = emailAddress;
        this.whetherListedOrNot = whetherListedOrNot;
        this.companyCategory = companyCategory;
        this.companySubcategory = companySubcategory;
        this.classOfCompany = classOfCompany;
        this.authorisedCapital = authorisedCapital;
        this.paidUpCapital = paidUpCapital;
        this.numberOfMembers = numberOfMembers;
        this.dateOfLastAGM = dateOfLastAGM;
        this.strikeOffAmalgamatedTransferredDate = strikeOffAmalgamatedTransferredDate;
        this.llpStatus = llpStatus;
        this.statusUnderCIRP = statusUnderCIRP;
        this.numberOfPartners = numberOfPartners;
        this.numberOfDesignatedPartners = numberOfDesignatedPartners;
        this.totalObligationOfContribution = totalObligationOfContribution;
        this.mainDivision = mainDivision;
        this.mainDivisionDescription = mainDivisionDescription;
        this.statementDate = statementDate;
        this.BSDefaulter2Yrs = BSDefaulter2Yrs;
        this.BSDefaulter3Yrs = BSDefaulter3Yrs;
        this.ARDefaulter2Yrs = ARDefaulter2Yrs;
        this.ARDefaulter3Yrs = ARDefaulter3Yrs;
        this.suspendedAtStockExchange = suspendedAtStockExchange;
        this.companyAddress = companyAddress;
        this.balanceSheet3years = balanceSheet3years;
        this.annualReturns3years = annualReturns3years;
        this.rocName = rocName;
        this.shareCapitalFlag = shareCapitalFlag;
        this.maximumNumberOfMembers = maximumNumberOfMembers;
        this.subscribedCapital = subscribedCapital;
        this.rdName = rdName;
        this.rdRegion = rdRegion;
        this.balanceSheetDate = balanceSheetDate;
        this.inc22Aflag = inc22Aflag;
    }

    public String getCin() {
        return cin;
    }

    public void setCin(String cin) {
        this.cin = cin;
    }

    public String getCompanyName() {
        return companyName;
    }

    public void setCompanyName(String companyName) {
        this.companyName = companyName;
    }

    public String getCompanyType() {
        return companyType;
    }

    public void setCompanyType(String companyType) {
        this.companyType = companyType;
    }

    public String getCompanyOrigin() {
        return companyOrigin;
    }

    public void setCompanyOrigin(String companyOrigin) {
        this.companyOrigin = companyOrigin;
    }

    public String getRegistrationNumber() {
        return registrationNumber;
    }

    public void setRegistrationNumber(String registrationNumber) {
        this.registrationNumber = registrationNumber;
    }

    public Long getDateOfIncorporation() {
        return dateOfIncorporation;
    }

    public void setDateOfIncorporation(Long dateOfIncorporation) {
        this.dateOfIncorporation = dateOfIncorporation;
    }

    public String getEmailAddress() {
        return emailAddress;
    }

    public void setEmailAddress(String emailAddress) {
        this.emailAddress = emailAddress;
    }

    public String getWhetherListedOrNot() {
        return whetherListedOrNot;
    }

    public void setWhetherListedOrNot(String whetherListedOrNot) {
        this.whetherListedOrNot = whetherListedOrNot;
    }

    public String getCompanyCategory() {
        return companyCategory;
    }

    public void setCompanyCategory(String companyCategory) {
        this.companyCategory = companyCategory;
    }

    public String getCompanySubcategory() {
        return companySubcategory;
    }

    public void setCompanySubcategory(String companySubcategory) {
        this.companySubcategory = companySubcategory;
    }

    public String getClassOfCompany() {
        return classOfCompany;
    }

    public void setClassOfCompany(String classOfCompany) {
        this.classOfCompany = classOfCompany;
    }

    public BigDecimal getAuthorisedCapital() {
        return authorisedCapital;
    }

    public void setAuthorisedCapital(BigDecimal authorisedCapital) {
        this.authorisedCapital = authorisedCapital;
    }

    public BigDecimal getPaidUpCapital() {
        return paidUpCapital;
    }

    public void setPaidUpCapital(BigDecimal paidUpCapital) {
        this.paidUpCapital = paidUpCapital;
    }

    public Long getNumberOfMembers() {
        return numberOfMembers;
    }

    public void setNumberOfMembers(Long numberOfMembers) {
        this.numberOfMembers = numberOfMembers;
    }

    public Long getDateOfLastAGM() {
        return dateOfLastAGM;
    }

    public void setDateOfLastAGM(Long dateOfLastAGM) {
        this.dateOfLastAGM = dateOfLastAGM;
    }

    public Long getStrikeOffAmalgamatedTransferredDate() {
        return strikeOffAmalgamatedTransferredDate;
    }

    public void setStrikeOffAmalgamatedTransferredDate(Long strikeOffAmalgamatedTransferredDate) {
        this.strikeOffAmalgamatedTransferredDate = strikeOffAmalgamatedTransferredDate;
    }

    public String getLlpStatus() {
        return llpStatus;
    }

    public void setLlpStatus(String llpStatus) {
        this.llpStatus = llpStatus;
    }

    public String getStatusUnderCIRP() {
        return statusUnderCIRP;
    }

    public void setStatusUnderCIRP(String statusUnderCIRP) {
        this.statusUnderCIRP = statusUnderCIRP;
    }

    public Long getNumberOfPartners() {
        return numberOfPartners;
    }

    public void setNumberOfPartners(Long numberOfPartners) {
        this.numberOfPartners = numberOfPartners;
    }

    public Long getNumberOfDesignatedPartners() {
        return numberOfDesignatedPartners;
    }

    public void setNumberOfDesignatedPartners(Long numberOfDesignatedPartners) {
        this.numberOfDesignatedPartners = numberOfDesignatedPartners;
    }

    public Long getTotalObligationOfContribution() {
        return totalObligationOfContribution;
    }

    public void setTotalObligationOfContribution(Long totalObligationOfContribution) {
        this.totalObligationOfContribution = totalObligationOfContribution;
    }

    public String getMainDivision() {
        return mainDivision;
    }

    public void setMainDivision(String mainDivision) {
        this.mainDivision = mainDivision;
    }

    public String getMainDivisionDescription() {
        return mainDivisionDescription;
    }

    public void setMainDivisionDescription(String mainDivisionDescription) {
        this.mainDivisionDescription = mainDivisionDescription;
    }

    public Long getStatementDate() {
        return statementDate;
    }

    public void setStatementDate(Long statementDate) {
        this.statementDate = statementDate;
    }

    public String getBSDefaulter2Yrs() {
        return BSDefaulter2Yrs;
    }

    public void setBSDefaulter2Yrs(String BSDefaulter2Yrs) {
        this.BSDefaulter2Yrs = BSDefaulter2Yrs;
    }

    public String getBSDefaulter3Yrs() {
        return BSDefaulter3Yrs;
    }

    public void setBSDefaulter3Yrs(String BSDefaulter3Yrs) {
        this.BSDefaulter3Yrs = BSDefaulter3Yrs;
    }

    public String getARDefaulter2Yrs() {
        return ARDefaulter2Yrs;
    }

    public void setARDefaulter2Yrs(String ARDefaulter2Yrs) {
        this.ARDefaulter2Yrs = ARDefaulter2Yrs;
    }

    public String getARDefaulter3Yrs() {
        return ARDefaulter3Yrs;
    }

    public void setARDefaulter3Yrs(String ARDefaulter3Yrs) {
        this.ARDefaulter3Yrs = ARDefaulter3Yrs;
    }

    public String getSuspendedAtStockExchange() {
        return suspendedAtStockExchange;
    }

    public void setSuspendedAtStockExchange(String suspendedAtStockExchange) {
        this.suspendedAtStockExchange = suspendedAtStockExchange;
    }

    public List<CompanyAddressDto> getCompanyAddress() {
        return companyAddress;
    }

    public void setCompanyAddress(List<CompanyAddressDto> companyAddress) {
        this.companyAddress = companyAddress;
    }

    public List<CompanyFilingEntryDto> getBalanceSheet3years() {
        return balanceSheet3years;
    }

    public void setBalanceSheet3years(
        List<CompanyFilingEntryDto> balanceSheet3years) {
        this.balanceSheet3years = balanceSheet3years;
    }

    public List<CompanyFilingEntryDto> getAnnualReturns3years() {
        return annualReturns3years;
    }

    public void setAnnualReturns3years(
        List<CompanyFilingEntryDto> annualReturns3years) {
        this.annualReturns3years = annualReturns3years;
    }

    public String getRocName() {
        return rocName;
    }

    public void setRocName(String rocName) {
        this.rocName = rocName;
    }

    public String getShareCapitalFlag() {
        return shareCapitalFlag;
    }

    public void setShareCapitalFlag(String shareCapitalFlag) {
        this.shareCapitalFlag = shareCapitalFlag;
    }

    public String getMaximumNumberOfMembers() {
        return maximumNumberOfMembers;
    }

    public void setMaximumNumberOfMembers(String maximumNumberOfMembers) {
        this.maximumNumberOfMembers = maximumNumberOfMembers;
    }

    public String getSubscribedCapital() {
        return subscribedCapital;
    }

    public void setSubscribedCapital(String subscribedCapital) {
        this.subscribedCapital = subscribedCapital;
    }

    public String getRdName() {
        return rdName;
    }

    public void setRdName(String rdName) {
        this.rdName = rdName;
    }

    public String getRdRegion() {
        return rdRegion;
    }

    public void setRdRegion(String rdRegion) {
        this.rdRegion = rdRegion;
    }

    public Long getBalanceSheetDate() {
        return balanceSheetDate;
    }

    public void setBalanceSheetDate(Long balanceSheetDate) {
        this.balanceSheetDate = balanceSheetDate;
    }

    public String getInc22Aflag() {
        return inc22Aflag;
    }

    public void setInc22Aflag(String inc22Aflag) {
        this.inc22Aflag = inc22Aflag;
    }

    public static interface CinStep {
        CompanyNameStep withCin(String cin);
    }

    public static interface CompanyNameStep {
        CompanyTypeStep withCompanyName(String companyName);
    }

    public static interface CompanyTypeStep {
        CompanyOriginStep withCompanyType(String companyType);
    }

    public static interface CompanyOriginStep {
        RegistrationNumberStep withCompanyOrigin(String companyOrigin);
    }

    public static interface RegistrationNumberStep {
        DateOfIncorporationStep withRegistrationNumber(String registrationNumber);
    }

    public static interface DateOfIncorporationStep {
        EmailAddressStep withDateOfIncorporation(Long dateOfIncorporation);
    }

    public static interface EmailAddressStep {
        WhetherListedOrNotStep withEmailAddress(String emailAddress);
    }

    public static interface WhetherListedOrNotStep {
        CompanyCategoryStep withWhetherListedOrNot(String whetherListedOrNot);
    }

    public static interface CompanyCategoryStep {
        CompanySubcategoryStep withCompanyCategory(String companyCategory);
    }

    public static interface CompanySubcategoryStep {
        ClassOfCompanyStep withCompanySubcategory(String companySubcategory);
    }

    public static interface ClassOfCompanyStep {
        AuthorisedCapitalStep withClassOfCompany(String classOfCompany);
    }

    public static interface AuthorisedCapitalStep {
        PaidUpCapitalStep withAuthorisedCapital(BigDecimal authorisedCapital);
    }

    public static interface PaidUpCapitalStep {
        NumberOfMembersStep withPaidUpCapital(BigDecimal paidUpCapital);
    }

    public static interface NumberOfMembersStep {
        DateOfLastAGMStep withNumberOfMembers(Long numberOfMembers);
    }

    public static interface DateOfLastAGMStep {
        StrikeOffAmalgamatedTransferredDateStep withDateOfLastAGM(Long dateOfLastAGM);
    }

    public static interface StrikeOffAmalgamatedTransferredDateStep {
        LlpStatusStep withStrikeOffAmalgamatedTransferredDate(Long strikeOffAmalgamatedTransferredDate);
    }

    public static interface LlpStatusStep {
        StatusUnderCIRPStep withLlpStatus(String llpStatus);
    }

    public static interface StatusUnderCIRPStep {
        NumberOfPartnersStep withStatusUnderCIRP(String statusUnderCIRP);
    }

    public static interface NumberOfPartnersStep {
        NumberOfDesignatedPartnersStep withNumberOfPartners(Long numberOfPartners);
    }

    public static interface NumberOfDesignatedPartnersStep {
        TotalObligationOfContributionStep withNumberOfDesignatedPartners(Long numberOfDesignatedPartners);
    }

    public static interface TotalObligationOfContributionStep {
        MainDivisionStep withTotalObligationOfContribution(Long totalObligationOfContribution);
    }

    public static interface MainDivisionStep {
        MainDivisionDescriptionStep withMainDivision(String mainDivision);
    }

    public static interface MainDivisionDescriptionStep {
        StatementDateStep withMainDivisionDescription(String mainDivisionDescription);
    }

    public static interface StatementDateStep {
        BSDefaulter2YrsStep withStatementDate(Long statementDate);
    }

    public static interface BSDefaulter2YrsStep {
        BSDefaulter3YrsStep withBSDefaulter2Yrs(String BSDefaulter2Yrs);
    }

    public static interface BSDefaulter3YrsStep {
        ARDefaulter2YrsStep withBSDefaulter3Yrs(String BSDefaulter3Yrs);
    }

    public static interface ARDefaulter2YrsStep {
        ARDefaulter3YrsStep withARDefaulter2Yrs(String ARDefaulter2Yrs);
    }

    public static interface ARDefaulter3YrsStep {
        SuspendedAtStockExchangeStep withARDefaulter3Yrs(String ARDefaulter3Yrs);
    }

    public static interface SuspendedAtStockExchangeStep {
        CompanyAddressStep withSuspendedAtStockExchange(String suspendedAtStockExchange);
    }

    public static interface CompanyAddressStep {
        BalanceSheet3yearsStep withCompanyAddress(List<CompanyAddressDto> companyAddress);
    }

    public static interface BalanceSheet3yearsStep {
        AnnualReturns3yearsStep withBalanceSheet3years(List<CompanyFilingEntryDto> balanceSheet3years);
    }

    public static interface AnnualReturns3yearsStep {
        RocNameStep withAnnualReturns3years(List<CompanyFilingEntryDto> annualReturns3years);
    }

    public static interface RocNameStep {
        ShareCapitalFlagStep withRocName(String rocName);
    }

    public static interface ShareCapitalFlagStep {
        MaximumNumberOfMembersStep withShareCapitalFlag(String shareCapitalFlag);
    }

    public static interface MaximumNumberOfMembersStep {
        SubscribedCapitalStep withMaximumNumberOfMembers(String maximumNumberOfMembers);
    }

    public static interface SubscribedCapitalStep {
        RdNameStep withSubscribedCapital(String subscribedCapital);
    }

    public static interface RdNameStep {
        RdRegionStep withRdName(String rdName);
    }

    public static interface RdRegionStep {
        BalanceSheetDateStep withRdRegion(String rdRegion);
    }

    public static interface BalanceSheetDateStep {
        Inc22AflagStep withBalanceSheetDate(Long balanceSheetDate);
    }

    public static interface Inc22AflagStep {
        BuildStep withInc22Aflag(String inc22Aflag);
    }

    public static interface BuildStep {
        CompanyDataDto build();
    }

    public static class Builder
        implements CinStep, CompanyNameStep, CompanyTypeStep, CompanyOriginStep, RegistrationNumberStep,
        DateOfIncorporationStep, EmailAddressStep, WhetherListedOrNotStep, CompanyCategoryStep, CompanySubcategoryStep,
        ClassOfCompanyStep, AuthorisedCapitalStep, PaidUpCapitalStep, NumberOfMembersStep, DateOfLastAGMStep,
        StrikeOffAmalgamatedTransferredDateStep, LlpStatusStep, StatusUnderCIRPStep, NumberOfPartnersStep,
        NumberOfDesignatedPartnersStep, TotalObligationOfContributionStep, MainDivisionStep,
        MainDivisionDescriptionStep, StatementDateStep, BSDefaulter2YrsStep, BSDefaulter3YrsStep, ARDefaulter2YrsStep,
        ARDefaulter3YrsStep, SuspendedAtStockExchangeStep, CompanyAddressStep, BalanceSheet3yearsStep,
        AnnualReturns3yearsStep, RocNameStep, ShareCapitalFlagStep, MaximumNumberOfMembersStep, SubscribedCapitalStep,
        RdNameStep, RdRegionStep, BalanceSheetDateStep, Inc22AflagStep, BuildStep {
        private String cin;
        private String companyName;
        private String companyType;
        private String companyOrigin;
        private String registrationNumber;
        private Long dateOfIncorporation;
        private String emailAddress;
        private String whetherListedOrNot;
        private String companyCategory;
        private String companySubcategory;
        private String classOfCompany;
        private BigDecimal authorisedCapital;
        private BigDecimal paidUpCapital;
        private Long numberOfMembers;
        private Long dateOfLastAGM;
        private Long strikeOffAmalgamatedTransferredDate;
        private String llpStatus;
        private String statusUnderCIRP;
        private Long numberOfPartners;
        private Long numberOfDesignatedPartners;
        private Long totalObligationOfContribution;
        private String mainDivision;
        private String mainDivisionDescription;
        private Long statementDate;
        private String BSDefaulter2Yrs;
        private String BSDefaulter3Yrs;
        private String ARDefaulter2Yrs;
        private String ARDefaulter3Yrs;
        private String suspendedAtStockExchange;
        private List<CompanyAddressDto> companyAddress;
        private List<CompanyFilingEntryDto> balanceSheet3years;
        private List<CompanyFilingEntryDto> annualReturns3years;
        private String rocName;
        private String shareCapitalFlag;
        private String maximumNumberOfMembers;
        private String subscribedCapital;
        private String rdName;
        private String rdRegion;
        private Long balanceSheetDate;
        private String inc22Aflag;

        private Builder() {
        }

        public static CinStep companyDataDto() {
            return new Builder();
        }

        @Override
        public CompanyNameStep withCin(String cin) {
            this.cin = cin;
            return this;
        }

        @Override
        public CompanyTypeStep withCompanyName(String companyName) {
            this.companyName = companyName;
            return this;
        }

        @Override
        public CompanyOriginStep withCompanyType(String companyType) {
            this.companyType = companyType;
            return this;
        }

        @Override
        public RegistrationNumberStep withCompanyOrigin(String companyOrigin) {
            this.companyOrigin = companyOrigin;
            return this;
        }

        @Override
        public DateOfIncorporationStep withRegistrationNumber(String registrationNumber) {
            this.registrationNumber = registrationNumber;
            return this;
        }

        @Override
        public EmailAddressStep withDateOfIncorporation(Long dateOfIncorporation) {
            this.dateOfIncorporation = dateOfIncorporation;
            return this;
        }

        @Override
        public WhetherListedOrNotStep withEmailAddress(String emailAddress) {
            this.emailAddress = emailAddress;
            return this;
        }

        @Override
        public CompanyCategoryStep withWhetherListedOrNot(String whetherListedOrNot) {
            this.whetherListedOrNot = whetherListedOrNot;
            return this;
        }

        @Override
        public CompanySubcategoryStep withCompanyCategory(String companyCategory) {
            this.companyCategory = companyCategory;
            return this;
        }

        @Override
        public ClassOfCompanyStep withCompanySubcategory(String companySubcategory) {
            this.companySubcategory = companySubcategory;
            return this;
        }

        @Override
        public AuthorisedCapitalStep withClassOfCompany(String classOfCompany) {
            this.classOfCompany = classOfCompany;
            return this;
        }

        @Override
        public PaidUpCapitalStep withAuthorisedCapital(BigDecimal authorisedCapital) {
            this.authorisedCapital = authorisedCapital;
            return this;
        }

        @Override
        public NumberOfMembersStep withPaidUpCapital(BigDecimal paidUpCapital) {
            this.paidUpCapital = paidUpCapital;
            return this;
        }

        @Override
        public DateOfLastAGMStep withNumberOfMembers(Long numberOfMembers) {
            this.numberOfMembers = numberOfMembers;
            return this;
        }

        @Override
        public StrikeOffAmalgamatedTransferredDateStep withDateOfLastAGM(Long dateOfLastAGM) {
            this.dateOfLastAGM = dateOfLastAGM;
            return this;
        }

        @Override
        public LlpStatusStep withStrikeOffAmalgamatedTransferredDate(Long strikeOffAmalgamatedTransferredDate) {
            this.strikeOffAmalgamatedTransferredDate = strikeOffAmalgamatedTransferredDate;
            return this;
        }

        @Override
        public StatusUnderCIRPStep withLlpStatus(String llpStatus) {
            this.llpStatus = llpStatus;
            return this;
        }

        @Override
        public NumberOfPartnersStep withStatusUnderCIRP(String statusUnderCIRP) {
            this.statusUnderCIRP = statusUnderCIRP;
            return this;
        }

        @Override
        public NumberOfDesignatedPartnersStep withNumberOfPartners(Long numberOfPartners) {
            this.numberOfPartners = numberOfPartners;
            return this;
        }

        @Override
        public TotalObligationOfContributionStep withNumberOfDesignatedPartners(Long numberOfDesignatedPartners) {
            this.numberOfDesignatedPartners = numberOfDesignatedPartners;
            return this;
        }

        @Override
        public MainDivisionStep withTotalObligationOfContribution(Long totalObligationOfContribution) {
            this.totalObligationOfContribution = totalObligationOfContribution;
            return this;
        }

        @Override
        public MainDivisionDescriptionStep withMainDivision(String mainDivision) {
            this.mainDivision = mainDivision;
            return this;
        }

        @Override
        public StatementDateStep withMainDivisionDescription(String mainDivisionDescription) {
            this.mainDivisionDescription = mainDivisionDescription;
            return this;
        }

        @Override
        public BSDefaulter2YrsStep withStatementDate(Long statementDate) {
            this.statementDate = statementDate;
            return this;
        }

        @Override
        public BSDefaulter3YrsStep withBSDefaulter2Yrs(String BSDefaulter2Yrs) {
            this.BSDefaulter2Yrs = BSDefaulter2Yrs;
            return this;
        }

        @Override
        public ARDefaulter2YrsStep withBSDefaulter3Yrs(String BSDefaulter3Yrs) {
            this.BSDefaulter3Yrs = BSDefaulter3Yrs;
            return this;
        }

        @Override
        public ARDefaulter3YrsStep withARDefaulter2Yrs(String ARDefaulter2Yrs) {
            this.ARDefaulter2Yrs = ARDefaulter2Yrs;
            return this;
        }

        @Override
        public SuspendedAtStockExchangeStep withARDefaulter3Yrs(String ARDefaulter3Yrs) {
            this.ARDefaulter3Yrs = ARDefaulter3Yrs;
            return this;
        }

        @Override
        public CompanyAddressStep withSuspendedAtStockExchange(String suspendedAtStockExchange) {
            this.suspendedAtStockExchange = suspendedAtStockExchange;
            return this;
        }

        @Override
        public BalanceSheet3yearsStep withCompanyAddress(List<CompanyAddressDto> companyAddress) {
            this.companyAddress = companyAddress;
            return this;
        }

        @Override
        public AnnualReturns3yearsStep withBalanceSheet3years(List<CompanyFilingEntryDto> balanceSheet3years) {
            this.balanceSheet3years = balanceSheet3years;
            return this;
        }

        @Override
        public RocNameStep withAnnualReturns3years(List<CompanyFilingEntryDto> annualReturns3years) {
            this.annualReturns3years = annualReturns3years;
            return this;
        }

        @Override
        public ShareCapitalFlagStep withRocName(String rocName) {
            this.rocName = rocName;
            return this;
        }

        @Override
        public MaximumNumberOfMembersStep withShareCapitalFlag(String shareCapitalFlag) {
            this.shareCapitalFlag = shareCapitalFlag;
            return this;
        }

        @Override
        public SubscribedCapitalStep withMaximumNumberOfMembers(String maximumNumberOfMembers) {
            this.maximumNumberOfMembers = maximumNumberOfMembers;
            return this;
        }

        @Override
        public RdNameStep withSubscribedCapital(String subscribedCapital) {
            this.subscribedCapital = subscribedCapital;
            return this;
        }

        @Override
        public RdRegionStep withRdName(String rdName) {
            this.rdName = rdName;
            return this;
        }

        @Override
        public BalanceSheetDateStep withRdRegion(String rdRegion) {
            this.rdRegion = rdRegion;
            return this;
        }

        @Override
        public Inc22AflagStep withBalanceSheetDate(Long balanceSheetDate) {
            this.balanceSheetDate = balanceSheetDate;
            return this;
        }

        @Override
        public BuildStep withInc22Aflag(String inc22Aflag) {
            this.inc22Aflag = inc22Aflag;
            return this;
        }

        @Override
        public CompanyDataDto build() {
            return new CompanyDataDto(
                this.cin,
                this.companyName,
                this.companyType,
                this.companyOrigin,
                this.registrationNumber,
                this.dateOfIncorporation,
                this.emailAddress,
                this.whetherListedOrNot,
                this.companyCategory,
                this.companySubcategory,
                this.classOfCompany,
                this.authorisedCapital,
                this.paidUpCapital,
                this.numberOfMembers,
                this.dateOfLastAGM,
                this.strikeOffAmalgamatedTransferredDate,
                this.llpStatus,
                this.statusUnderCIRP,
                this.numberOfPartners,
                this.numberOfDesignatedPartners,
                this.totalObligationOfContribution,
                this.mainDivision,
                this.mainDivisionDescription,
                this.statementDate,
                this.BSDefaulter2Yrs,
                this.BSDefaulter3Yrs,
                this.ARDefaulter2Yrs,
                this.ARDefaulter3Yrs,
                this.suspendedAtStockExchange,
                this.companyAddress,
                this.balanceSheet3years,
                this.annualReturns3years,
                this.rocName,
                this.shareCapitalFlag,
                this.maximumNumberOfMembers,
                this.subscribedCapital,
                this.rdName,
                this.rdRegion,
                this.balanceSheetDate,
                this.inc22Aflag
            );
        }
    }
}


package com.ofb.crawler.commons.types.mca.dto;

@Data
@ToString
public class McaCompanyDetailDto extends BaseS3ResponseDto {

    private CompanyDetailDto companyDetailDto;

    private McaCompanyMasterDataDto companyDetailDtoV2;

    public McaCompanyDetailDto() {
    }

    public McaCompanyDetailDto(String parsingId, TaskType taskType, long parsingTime,
        BaseTaskParamsDto baseTaskParamsDto, CompanyDetailDto companyDetailDto,
        McaCompanyMasterDataDto companyDetailDtoV2) {
        super(parsingId, taskType, parsingTime, baseTaskParamsDto);
        this.companyDetailDto = companyDetailDto;
        this.companyDetailDtoV2 = companyDetailDtoV2;
    }

    @Override public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
        McaCompanyDetailDto that = (McaCompanyDetailDto) o;
        return Objects.equals(companyDetailDto, that.companyDetailDto) &&
            Objects.equals(companyDetailDtoV2, that.companyDetailDtoV2);
    }

    @Override public int hashCode() {
        return Objects.hash(super.hashCode(), companyDetailDto, companyDetailDtoV2);
    }

    public static interface ParsingIdStep {
        TaskTypeStep withParsingId(String parsingId);
    }

    public static interface TaskTypeStep {
        ParsingTimeStep withTaskType(TaskType taskType);
    }

    public static interface ParsingTimeStep {
        BaseTaskParamsDtoStep withParsingTime(long parsingTime);
    }

    public static interface BaseTaskParamsDtoStep {
        CompanyDetailDtoStep withBaseTaskParamsDto(BaseTaskParamsDto baseTaskParamsDto);
    }

    public static interface CompanyDetailDtoStep {
        CompanyDetailDtoV2Step withCompanyDetailDto(CompanyDetailDto companyDetailDto);
    }

    public static interface CompanyDetailDtoV2Step {
        BuildStep withCompanyDetailDtoV2(McaCompanyMasterDataDto companyDetailDtoV2);
    }

    public static interface BuildStep {
        McaCompanyDetailDto build();
    }

    public static class Builder
        implements ParsingIdStep, TaskTypeStep, ParsingTimeStep, BaseTaskParamsDtoStep, CompanyDetailDtoStep,
        CompanyDetailDtoV2Step, BuildStep {
        private String parsingId;
        private TaskType taskType;
        private long parsingTime;
        private BaseTaskParamsDto baseTaskParamsDto;
        private CompanyDetailDto companyDetailDto;
        private McaCompanyMasterDataDto companyDetailDtoV2;

        private Builder() {
        }

        public static ParsingIdStep mcaCompanyDetailDto() {
            return new Builder();
        }

        @Override
        public TaskTypeStep withParsingId(String parsingId) {
            this.parsingId = parsingId;
            return this;
        }

        @Override
        public ParsingTimeStep withTaskType(TaskType taskType) {
            this.taskType = taskType;
            return this;
        }

        @Override
        public BaseTaskParamsDtoStep withParsingTime(long parsingTime) {
            this.parsingTime = parsingTime;
            return this;
        }

        @Override
        public CompanyDetailDtoStep withBaseTaskParamsDto(BaseTaskParamsDto baseTaskParamsDto) {
            this.baseTaskParamsDto = baseTaskParamsDto;
            return this;
        }

        @Override
        public CompanyDetailDtoV2Step withCompanyDetailDto(CompanyDetailDto companyDetailDto) {
            this.companyDetailDto = companyDetailDto;
            return this;
        }

        @Override
        public BuildStep withCompanyDetailDtoV2(McaCompanyMasterDataDto companyDetailDtoV2) {
            this.companyDetailDtoV2 = companyDetailDtoV2;
            return this;
        }

        @Override
        public McaCompanyDetailDto build() {
            return new McaCompanyDetailDto(
                this.parsingId,
                this.taskType,
                this.parsingTime,
                this.baseTaskParamsDto,
                this.companyDetailDto,
                this.companyDetailDtoV2
            );
        }
    }
}


package com.ofb.crawler.commons.types.mca.dto;

public class CompanyDetail {

    private String detailUrl;

    private BasicDetail basicDetail;

    private FinancialDetail financialDetail;

    private List<DirectorDetail> directorDetails;

    private ContactDetail contactDetail;

    private ComplianceDetail complianceDetail;

    private List<ChargesDetail> chargesDetail ;

    private EstablishmentDetail establishmentDetail ;

    private List<SimilarCompanyDetail> similarCompanyDetail;

    public String getDetailUrl() {
        return detailUrl;
    }

    public void setDetailUrl(String detailUrl) {
        this.detailUrl = detailUrl;
    }

    public BasicDetail getBasicDetail() {
        return basicDetail;
    }

    public void setBasicDetail(BasicDetail basicDetail) {
        this.basicDetail = basicDetail;
    }

    public FinancialDetail getFinancialDetail() {
        return financialDetail;
    }

    public void setFinancialDetail(FinancialDetail financialDetail) {
        this.financialDetail = financialDetail;
    }

    public List<DirectorDetail> getDirectorDetails() {
        return directorDetails;
    }

    public void setDirectorDetails(List<DirectorDetail> directorDetails) {
        this.directorDetails = directorDetails;
    }

    public ContactDetail getContactDetail() {
        return contactDetail;
    }

    public void setContactDetail(ContactDetail contactDetail) {
        this.contactDetail = contactDetail;
    }

    public ComplianceDetail getComplianceDetail() {
        return complianceDetail;
    }

    public void setComplianceDetail(ComplianceDetail complianceDetail) {
        this.complianceDetail = complianceDetail;
    }

    public List<ChargesDetail> getChargesDetail() {
        return chargesDetail;
    }

    public void setChargesDetail(List<ChargesDetail> chargesDetail) {
        this.chargesDetail = chargesDetail;
    }

    public EstablishmentDetail getEstablishmentDetail() {
        return establishmentDetail;
    }

    public void setEstablishmentDetail(EstablishmentDetail establishmentDetail) {
        this.establishmentDetail = establishmentDetail;
    }

    public List<SimilarCompanyDetail> getSimilarCompanyDetail() {
        return similarCompanyDetail;
    }

    public void setSimilarCompanyDetail(List<SimilarCompanyDetail> similarCompanyDetail) {
        this.similarCompanyDetail = similarCompanyDetail;
    }

    public CompanyDetail(String detailUrl, BasicDetail basicDetail, FinancialDetail financialDetail, List<DirectorDetail> directorDetails, ContactDetail contactDetail, ComplianceDetail complianceDetail, List<ChargesDetail> chargesDetail, EstablishmentDetail establishmentDetail, List<SimilarCompanyDetail> similarCompanyDetail) {
        this.detailUrl = detailUrl;
        this.basicDetail = basicDetail;
        this.financialDetail = financialDetail;
        this.directorDetails = directorDetails;
        this.contactDetail = contactDetail;
        this.complianceDetail = complianceDetail;
        this.chargesDetail = chargesDetail;
        this.establishmentDetail = establishmentDetail;
        this.similarCompanyDetail = similarCompanyDetail;
    }

    public static interface DetailUrlStep {
        BasicDetailStep withDetailUrl(String detailUrl);
    }

    public static interface BasicDetailStep {
        FinancialDetailStep withBasicDetail(BasicDetail basicDetail);
    }

    public static interface FinancialDetailStep {
        DirectorDetailsStep withFinancialDetail(FinancialDetail financialDetail);
    }

    public static interface DirectorDetailsStep {
        ContactDetailStep withDirectorDetails(List<DirectorDetail> directorDetails);
    }

    public static interface ContactDetailStep {
        ComplianceDetailStep withContactDetail(ContactDetail contactDetail);
    }

    public static interface ComplianceDetailStep {
        ChargesDetailStep withComplianceDetail(ComplianceDetail complianceDetail);
    }

    public static interface ChargesDetailStep {
        EstablishmentDetailStep withChargesDetail(List<ChargesDetail> chargesDetail);
    }

    public static interface EstablishmentDetailStep {
        SimilarCompanyDetailStep withEstablishmentDetail(EstablishmentDetail establishmentDetail);
    }

    public static interface SimilarCompanyDetailStep {
        BuildStep withSimilarCompanyDetail(List<SimilarCompanyDetail> similarCompanyDetail);
    }

    public static interface BuildStep {
        CompanyDetail build();
    }

    public static class Builder implements DetailUrlStep, BasicDetailStep, FinancialDetailStep, DirectorDetailsStep, ContactDetailStep, ComplianceDetailStep, ChargesDetailStep, EstablishmentDetailStep, SimilarCompanyDetailStep, BuildStep {
        private String detailUrl;
        private BasicDetail basicDetail;
        private FinancialDetail financialDetail;
        private List<DirectorDetail> directorDetails;
        private ContactDetail contactDetail;
        private ComplianceDetail complianceDetail;
        private List<ChargesDetail> chargesDetail;
        private EstablishmentDetail establishmentDetail;
        private List<SimilarCompanyDetail> similarCompanyDetail;

        private Builder() {
        }

        public static DetailUrlStep companyDetail() {
            return new Builder();
        }

        @Override
        public BasicDetailStep withDetailUrl(String detailUrl) {
            this.detailUrl = detailUrl;
            return this;
        }

        @Override
        public FinancialDetailStep withBasicDetail(BasicDetail basicDetail) {
            this.basicDetail = basicDetail;
            return this;
        }

        @Override
        public DirectorDetailsStep withFinancialDetail(FinancialDetail financialDetail) {
            this.financialDetail = financialDetail;
            return this;
        }

        @Override
        public ContactDetailStep withDirectorDetails(List<DirectorDetail> directorDetails) {
            this.directorDetails = directorDetails;
            return this;
        }

        @Override
        public ComplianceDetailStep withContactDetail(ContactDetail contactDetail) {
            this.contactDetail = contactDetail;
            return this;
        }

        @Override
        public ChargesDetailStep withComplianceDetail(ComplianceDetail complianceDetail) {
            this.complianceDetail = complianceDetail;
            return this;
        }

        @Override
        public EstablishmentDetailStep withChargesDetail(List<ChargesDetail> chargesDetail) {
            this.chargesDetail = chargesDetail;
            return this;
        }

        @Override
        public SimilarCompanyDetailStep withEstablishmentDetail(EstablishmentDetail establishmentDetail) {
            this.establishmentDetail = establishmentDetail;
            return this;
        }

        @Override
        public BuildStep withSimilarCompanyDetail(List<SimilarCompanyDetail> similarCompanyDetail) {
            this.similarCompanyDetail = similarCompanyDetail;
            return this;
        }

        @Override
        public CompanyDetail build() {
            return new CompanyDetail(
                    this.detailUrl,
                    this.basicDetail,
                    this.financialDetail,
                    this.directorDetails,
                    this.contactDetail,
                    this.complianceDetail,
                    this.chargesDetail,
                    this.establishmentDetail,
                    this.similarCompanyDetail
            );
        }
    }
}


package com.ofb.crawler.commons.types.litigation.itat.dto.task;

@Data
@NoArgsConstructor
public class ItatTaskParamsDto extends BaseTaskParamsDto {

    public ItatTaskParamsDto(String requestId, String companyName, String cin, String gstIn) {
        super(requestId, companyName, cin ,gstIn);
    }

    public static interface RequestIdStep {
        CompanyNameStep withRequestId(String requestId);
    }

    public static interface CompanyNameStep {
        CinStep withCompanyName(String companyName);
    }

    public static interface CinStep {
        GstInStep withCin(String cin);
    }

    public static interface GstInStep {
        BuildStep withGstIn(String gstIn);
    }

    public static interface BuildStep {
        ItatTaskParamsDto build();
    }


    public static class Builder implements RequestIdStep, CompanyNameStep, CinStep, GstInStep, BuildStep {
        private String requestId;
        private String companyName;
        private String cin;
        private String gstIn;

        private Builder() {
        }

        public static RequestIdStep itatTaskParamsDto() {
            return new Builder();
        }

        @Override
        public CompanyNameStep withRequestId(String requestId) {
            this.requestId = requestId;
            return this;
        }

        @Override
        public CinStep withCompanyName(String companyName) {
            this.companyName = companyName;
            return this;
        }

        @Override
        public GstInStep withCin(String cin) {
            this.cin = cin;
            return this;
        }

        @Override
        public BuildStep withGstIn(String gstIn) {
            this.gstIn = gstIn;
            return this;
        }

        @Override
        public ItatTaskParamsDto build() {
            return new ItatTaskParamsDto(
                    this.requestId,
                    this.companyName,
                    this.cin,
                    this.gstIn
            );
        }
    }
}


package com.ofb.crawler.commons.types.gstToPan.dto.response;

public class PanToGstDetailResponseDto extends BaseS3ResponseDto {

    private List<GstInfoResponse> gstInfoResponsesList;

    public PanToGstDetailResponseDto(List<GstInfoResponse> gstInfoResponsesList) {
        this.gstInfoResponsesList = gstInfoResponsesList;
    }

    public PanToGstDetailResponseDto(String parsingId, TaskType taskType, long parsingTime,
        BaseTaskParamsDto baseTaskParamsDto,
        List<GstInfoResponse> gstInfoResponsesList) {
        super(parsingId, taskType, parsingTime, baseTaskParamsDto);
        this.gstInfoResponsesList = gstInfoResponsesList;
    }

    public List<GstInfoResponse> getGstInfoResponsesList() {
        return gstInfoResponsesList;
    }

    public void setGstInfoResponsesList(
        List<GstInfoResponse> gstInfoResponsesList) {
        this.gstInfoResponsesList = gstInfoResponsesList;
    }

    public static interface ParsingIdStep {
        TaskTypeStep withParsingId(String parsingId);
    }

    public static interface TaskTypeStep {
        ParsingTimeStep withTaskType(TaskType taskType);
    }

    public static interface ParsingTimeStep {
        BaseTaskParamsDtoStep withParsingTime(long parsingTime);
    }

    public static interface BaseTaskParamsDtoStep {
        GstInfoResponsesListStep withBaseTaskParamsDto(BaseTaskParamsDto baseTaskParamsDto);
    }

    public static interface GstInfoResponsesListStep {
        BuildStep withGstInfoResponsesList(List<GstInfoResponse> gstInfoResponsesList);
    }

    public static interface BuildStep {
        PanToGstDetailResponseDto build();
    }

    public static class Builder
        implements ParsingIdStep, TaskTypeStep, ParsingTimeStep, BaseTaskParamsDtoStep, GstInfoResponsesListStep,
        BuildStep {
        private String parsingId;
        private TaskType taskType;
        private long parsingTime;
        private BaseTaskParamsDto baseTaskParamsDto;
        private List<GstInfoResponse> gstInfoResponsesList;

        private Builder() {
        }

        public static ParsingIdStep panToGstDetailResponseDto() {
            return new Builder();
        }

        @Override
        public TaskTypeStep withParsingId(String parsingId) {
            this.parsingId = parsingId;
            return this;
        }

        @Override
        public ParsingTimeStep withTaskType(TaskType taskType) {
            this.taskType = taskType;
            return this;
        }

        @Override
        public BaseTaskParamsDtoStep withParsingTime(long parsingTime) {
            this.parsingTime = parsingTime;
            return this;
        }

        @Override
        public GstInfoResponsesListStep withBaseTaskParamsDto(BaseTaskParamsDto baseTaskParamsDto) {
            this.baseTaskParamsDto = baseTaskParamsDto;
            return this;
        }

        @Override
        public BuildStep withGstInfoResponsesList(List<GstInfoResponse> gstInfoResponsesList) {
            this.gstInfoResponsesList = gstInfoResponsesList;
            return this;
        }

        @Override
        public PanToGstDetailResponseDto build() {
            return new PanToGstDetailResponseDto(
                this.parsingId,
                this.taskType,
                this.parsingTime,
                this.baseTaskParamsDto,
                this.gstInfoResponsesList
            );
        }
    }
}


package com.ofb.crawler.commons.types.gstInfo.dto.response;

@Data
@NoArgsConstructor
public class GstInfoResponse {
    private GstAddress principalPlaceOfBusinessFields;

    private List<GstAddress> additionalPlacePOfBusinessFields;

    private List<String> natureOfBusiness;

    private String stateJurisdictionCode;

    private String taxPayerType;

    private String businessName;

    private String stateJurisdiction;

    private String dateOfCancellation;

    private String gstin;

    private String lastUpdateDate;

    private String constitutionOfBusiness;

    private String registrationDate;

    private String tradeName;

    private String centerJurisdictionCode;

    private String gstinStatus;

    private String centerJurisdiction;

    public GstInfoResponse(GstAddress principalPlaceOfBusinessFields, List<GstAddress> additionalPlacePOfBusinessFields, List<String> natureOfBusiness, String stateJurisdictionCode, String taxPayerType, String businessName, String stateJurisdiction, String dateOfCancellation, String gstin, String lastUpdateDate, String constitutionOfBusiness, String registrationDate, String tradeName, String centerJurisdictionCode, String gstinStatus, String centerJurisdiction) {
        this.principalPlaceOfBusinessFields = principalPlaceOfBusinessFields;
        this.additionalPlacePOfBusinessFields = additionalPlacePOfBusinessFields;
        this.natureOfBusiness = natureOfBusiness;
        this.stateJurisdictionCode = stateJurisdictionCode;
        this.taxPayerType = taxPayerType;
        this.businessName = businessName;
        this.stateJurisdiction = stateJurisdiction;
        this.dateOfCancellation = dateOfCancellation;
        this.gstin = gstin;
        this.lastUpdateDate = lastUpdateDate;
        this.constitutionOfBusiness = constitutionOfBusiness;
        this.registrationDate = registrationDate;
        this.tradeName = tradeName;
        this.centerJurisdictionCode = centerJurisdictionCode;
        this.gstinStatus = gstinStatus;
        this.centerJurisdiction = centerJurisdiction;
    }

    public static interface PrincipalPlaceOfBusinessFieldsStep {
        AdditionalPlacePOfBusinessFieldsStep withPrincipalPlaceOfBusinessFields(GstAddress principalPlaceOfBusinessFields);
    }

    public static interface AdditionalPlacePOfBusinessFieldsStep {
        NatureOfBusinessStep withAdditionalPlacePOfBusinessFields(List<GstAddress> additionalPlacePOfBusinessFields);
    }

    public static interface NatureOfBusinessStep {
        StateJurisdictionCodeStep withNatureOfBusiness(List<String> natureOfBusiness);
    }

    public static interface StateJurisdictionCodeStep {
        TaxPayerTypeStep withStateJurisdictionCode(String stateJurisdictionCode);
    }

    public static interface TaxPayerTypeStep {
        BusinessNameStep withTaxPayerType(String taxPayerType);
    }

    public static interface BusinessNameStep {
        StateJurisdictionStep withBusinessName(String businessName);
    }

    public static interface StateJurisdictionStep {
        DateOfCancellationStep withStateJurisdiction(String stateJurisdiction);
    }

    public static interface DateOfCancellationStep {
        GstinStep withDateOfCancellation(String dateOfCancellation);
    }

    public static interface GstinStep {
        LastUpdateDateStep withGstin(String gstin);
    }

    public static interface LastUpdateDateStep {
        ConstitutionOfBusinessStep withLastUpdateDate(String lastUpdateDate);
    }

    public static interface ConstitutionOfBusinessStep {
        RegistrationDateStep withConstitutionOfBusiness(String constitutionOfBusiness);
    }

    public static interface RegistrationDateStep {
        TradeNameStep withRegistrationDate(String registrationDate);
    }

    public static interface TradeNameStep {
        CenterJurisdictionCodeStep withTradeName(String tradeName);
    }

    public static interface CenterJurisdictionCodeStep {
        GstinStatusStep withCenterJurisdictionCode(String centerJurisdictionCode);
    }

    public static interface GstinStatusStep {
        CenterJurisdictionStep withGstinStatus(String gstinStatus);
    }

    public static interface CenterJurisdictionStep {
        BuildStep withCenterJurisdiction(String centerJurisdiction);
    }

    public static interface BuildStep {
        GstInfoResponse build();
    }


    public static class Builder implements PrincipalPlaceOfBusinessFieldsStep, AdditionalPlacePOfBusinessFieldsStep, NatureOfBusinessStep, StateJurisdictionCodeStep, TaxPayerTypeStep, BusinessNameStep, StateJurisdictionStep, DateOfCancellationStep, GstinStep, LastUpdateDateStep, ConstitutionOfBusinessStep, RegistrationDateStep, TradeNameStep, CenterJurisdictionCodeStep, GstinStatusStep, CenterJurisdictionStep, BuildStep {
        private GstAddress principalPlaceOfBusinessFields;
        private List<GstAddress> additionalPlacePOfBusinessFields;
        private List<String> natureOfBusiness;
        private String stateJurisdictionCode;
        private String taxPayerType;
        private String businessName;
        private String stateJurisdiction;
        private String dateOfCancellation;
        private String gstin;
        private String lastUpdateDate;
        private String constitutionOfBusiness;
        private String registrationDate;
        private String tradeName;
        private String centerJurisdictionCode;
        private String gstinStatus;
        private String centerJurisdiction;

        private Builder() {
        }

        public static PrincipalPlaceOfBusinessFieldsStep gstInfoResponse() {
            return new Builder();
        }

        @Override
        public AdditionalPlacePOfBusinessFieldsStep withPrincipalPlaceOfBusinessFields(GstAddress principalPlaceOfBusinessFields) {
            this.principalPlaceOfBusinessFields = principalPlaceOfBusinessFields;
            return this;
        }

        @Override
        public NatureOfBusinessStep withAdditionalPlacePOfBusinessFields(List<GstAddress> additionalPlacePOfBusinessFields) {
            this.additionalPlacePOfBusinessFields = additionalPlacePOfBusinessFields;
            return this;
        }

        @Override
        public StateJurisdictionCodeStep withNatureOfBusiness(List<String> natureOfBusiness) {
            this.natureOfBusiness = natureOfBusiness;
            return this;
        }

        @Override
        public TaxPayerTypeStep withStateJurisdictionCode(String stateJurisdictionCode) {
            this.stateJurisdictionCode = stateJurisdictionCode;
            return this;
        }

        @Override
        public BusinessNameStep withTaxPayerType(String taxPayerType) {
            this.taxPayerType = taxPayerType;
            return this;
        }

        @Override
        public StateJurisdictionStep withBusinessName(String businessName) {
            this.businessName = businessName;
            return this;
        }

        @Override
        public DateOfCancellationStep withStateJurisdiction(String stateJurisdiction) {
            this.stateJurisdiction = stateJurisdiction;
            return this;
        }

        @Override
        public GstinStep withDateOfCancellation(String dateOfCancellation) {
            this.dateOfCancellation = dateOfCancellation;
            return this;
        }

        @Override
        public LastUpdateDateStep withGstin(String gstin) {
            this.gstin = gstin;
            return this;
        }

        @Override
        public ConstitutionOfBusinessStep withLastUpdateDate(String lastUpdateDate) {
            this.lastUpdateDate = lastUpdateDate;
            return this;
        }

        @Override
        public RegistrationDateStep withConstitutionOfBusiness(String constitutionOfBusiness) {
            this.constitutionOfBusiness = constitutionOfBusiness;
            return this;
        }

        @Override
        public TradeNameStep withRegistrationDate(String registrationDate) {
            this.registrationDate = registrationDate;
            return this;
        }

        @Override
        public CenterJurisdictionCodeStep withTradeName(String tradeName) {
            this.tradeName = tradeName;
            return this;
        }

        @Override
        public GstinStatusStep withCenterJurisdictionCode(String centerJurisdictionCode) {
            this.centerJurisdictionCode = centerJurisdictionCode;
            return this;
        }

        @Override
        public CenterJurisdictionStep withGstinStatus(String gstinStatus) {
            this.gstinStatus = gstinStatus;
            return this;
        }

        @Override
        public BuildStep withCenterJurisdiction(String centerJurisdiction) {
            this.centerJurisdiction = centerJurisdiction;
            return this;
        }

        @Override
        public GstInfoResponse build() {
            return new GstInfoResponse(
                    this.principalPlaceOfBusinessFields,
                    this.additionalPlacePOfBusinessFields,
                    this.natureOfBusiness,
                    this.stateJurisdictionCode,
                    this.taxPayerType,
                    this.businessName,
                    this.stateJurisdiction,
                    this.dateOfCancellation,
                    this.gstin,
                    this.lastUpdateDate,
                    this.constitutionOfBusiness,
                    this.registrationDate,
                    this.tradeName,
                    this.centerJurisdictionCode,
                    this.gstinStatus,
                    this.centerJurisdiction
            );
        }
    }
}


package com.ofb.crawler.commons.types.gstInfo.dto.task;

@Data
@NoArgsConstructor
public class GstInfoTaskParamsDto extends BaseTaskParamsDto {

    public GstInfoTaskParamsDto(String requestId, String companyName, String cin, String gstIn) {
        super(requestId, companyName, cin, gstIn);
    }

    public static interface RequestIdStep {
        CompanyNameStep withRequestId(String requestId);
    }

    public static interface CompanyNameStep {
        CinStep withCompanyName(String companyName);
    }

    public static interface CinStep {
        GstInStep withCin(String cin);
    }

    public static interface GstInStep {
        BuildStep withGstIn(String gstIn);
    }

    public static interface BuildStep {
        GstInfoTaskParamsDto build();
    }


    public static class Builder implements RequestIdStep, CompanyNameStep, CinStep, GstInStep, BuildStep {
        private String requestId;
        private String companyName;
        private String cin;
        private String gstIn;

        private Builder() {
        }

        public static RequestIdStep gstInfoTaskParamsDto() {
            return new Builder();
        }

        @Override
        public CompanyNameStep withRequestId(String requestId) {
            this.requestId = requestId;
            return this;
        }

        @Override
        public CinStep withCompanyName(String companyName) {
            this.companyName = companyName;
            return this;
        }

        @Override
        public GstInStep withCin(String cin) {
            this.cin = cin;
            return this;
        }

        @Override
        public BuildStep withGstIn(String gstIn) {
            this.gstIn = gstIn;
            return this;
        }

        @Override
        public GstInfoTaskParamsDto build() {
            return new GstInfoTaskParamsDto(
                    this.requestId,
                    this.companyName,
                    this.cin,
                    this.gstIn
            );
        }
    }
}


package com.ofb.crawler.core.types.litigation.eHighCourt.service;

@Service
public class EHighCourtParserCallback extends BaseParserCallback<EHighCourtDetailDto, EHighCourtTaskParamsDto> {

    private static final Logger logger = LoggerFactory.getLogger(
        EHighCourtParserCallback.class);

    
    private static final String CAPTCHA_URL = "https:
        + ".in/ecourtindiaHC/securimage/securimage_show.php";

    private static final String DETAIL_URL =
        "https:

    
    private static final String SEARCH_RECORDS_URL =
        "https:

    
    private static final String CASE_HISTORY_URL =
        "https:

    private static final String ORDER_DOC_BASE_URL = "https:

    private static final String DATE_FORMAT = "dd-MM-yyyy";

    private static final String CAPTCHA_SERVER_END_POINT = "/e-court/captcha";

    private static final int THREAD_COUNT = 3;

    private static final int MAX_CAPTCHA_ATTEMPTS = 10;

    private static final Object lock = new Object();

    private static final int MAX_DETAIL_RETRY_ATTEMPTS = 4; 

    private static final IpDistributor IP_DISTRIBUTOR =
        new IpDistributor(TaskType.LITIGATION_E_HIGH_COURT, RotationIp.IPS_FOR_E_HIGH_COURT, 36);

    @Override public TaskType getTaskType() {
        return TaskType.LITIGATION_E_HIGH_COURT;
    }

    @Override public EHighCourtDetailDto parse(EHighCourtTaskParamsDto parsingParams) throws Throwable {
        return parseEHighCourt(parsingParams);
    }

    private static EHighCourtDetailDto parseEHighCourt(EHighCourtTaskParamsDto parsingParams) throws Throwable {
        String organisationName = parsingParams.getCompanyName();
        int year = 2021;
        if (parsingParams.getFromTime() != null && parsingParams.getFromTime() > 0) {
            int yearProvided = new DateTime(parsingParams.getFromTime()).getYear();
            if (yearProvided > year) {
                year = yearProvided;
            }
        }

        List<EHighCourtParsedResult> eHighCourtParsedResults =
            parseCaseByPartyName(organisationName, parsingParams.getRequestId(), year,
                new DateTime().getYear());

        return EHighCourtDetailDto.Builder.eHighCourtDetailDto()
            .withParsingId(String.valueOf(UUID.randomUUID()))
            .withTaskType(TaskType.LITIGATION_E_HIGH_COURT)
            .withParsingTime(System.currentTimeMillis())
            .withBaseTaskParamsDto(null)
            .withEHighCourtCases(eHighCourtParsedResults)
            .withBaseTaskParamsDtoWithDateRange(parsingParams)
            .build();
    }

    private static List<EHighCourtParsedResult> parseCaseByPartyName(String origPartyName, String requestId,
        int startYear, int endYear)
        throws RequestParsingException, InterruptedException {
        String partyName = LitigationUtils.sanitizeSearchName(origPartyName);
        List<Callable<List<EHighCourtParsedResult>>> callables = new ArrayList<>();
        List<EHighCourtParsedResult> finalECourtCaseDetailList = new ArrayList<>();
        for (HighCourt highCourt : HighCourt.getAllHighCourtSet()) {
            for (HighCourtBench bench : highCourt.getHighCourtBenches()) {
                callables.add(() -> {
                    IpInfoIpDistributor ip = IP_DISTRIBUTOR.getAvailableIp();
                    List<EHighCourtParsedResult> highCourtParsedResultList = new ArrayList<>();
                    try {
                        Map<String, String> variableMap =
                            getVariableMap(highCourt, bench, ip.getRotationIp());
                        Map<String, String> headerMap = getSessionIdHeaders(variableMap);
                        for (int year = startYear; year <= endYear; year++) {
                            highCourtParsedResultList.addAll(
                                searchWithSpecificIp(highCourt, bench, partyName, origPartyName, year,
                                    ip.getRotationIp(), variableMap, headerMap, endYear));
                        }
                    } catch (RequestParsingException e) {
                        throw e;
                    } catch (Exception e) {
                        logger.error(
                            MessageFormat.format(
                                "Error while parsing high court [{0}] and bench [{1}] case partyName : [{2}], year start: [{3}] : end [{4}] using IP {}",
                                highCourt.name(), bench.name(), origPartyName, startYear, endYear, ip.getRotationIp().name()), e);
                    } finally {
                        IP_DISTRIBUTOR.markIpAsAvailable(ip);
                    }
                    return highCourtParsedResultList;
                });
            }
        }
        ExecutorService ex =
            ExecutorServicesPool.fixedThreadPool(
                requestId, THREAD_COUNT);
        try {
            List<Future<List<EHighCourtParsedResult>>> futures = ex.invokeAll(callables);
            for (Future<List<EHighCourtParsedResult>> future : futures) {
                try {
                    finalECourtCaseDetailList.addAll(future.get());
                } catch (Exception e) {
                    if (e.getCause() instanceof RequestParsingException) {
                        throw (RequestParsingException) e.getCause();
                    }
                    logger.error("Failed to get future response", e);
                }
            }
            logger.info("FOUND_NUMBER_CASES : {}", finalECourtCaseDetailList.size());
            return finalECourtCaseDetailList;
        } finally {
            ExecutorServicesPool.shutDownExecutorService(requestId);
        }
    }


    private static List<EHighCourtParsedResult> searchWithSpecificIp(HighCourt highCourt, HighCourtBench bench,
        String partyName, String origPartyName, int year, RotationIp rotationIp, Map<String, String> variableMap,
        Map<String, String> headerMap, int currYear) throws InterruptedException, RequestParsingException {
        if (headerMap.get("Cookie") == null) {
            throw new RequestParsingException(
                MessageFormat.format(
                    "Cannot get Session Cookies For highCourt: [{0}] bench: [{1}] and partyName: [{2}] using ip [{3}]",
                    highCourt.name(),
                    bench.name(), origPartyName, rotationIp.name()), TaskError.SERVER_DOWN);
        }
        List<EHighCourtParsedResult> eCourtCaseDetailsList = new ArrayList<>();
        Pair<String, List<EHighCourtCaseListCrawlDto>> eHighCourtCaseListCrawlDtoPair =
            getTokenAndCrawlDtos(origPartyName, partyName, year, bench, highCourt, rotationIp, headerMap, variableMap);
        String token = eHighCourtCaseListCrawlDtoPair.first;
        List<EHighCourtCaseListCrawlDto> eHighCourtCaseListCrawlDtos = eHighCourtCaseListCrawlDtoPair.second;
        if (ObjectUtils.isBlankObject(eHighCourtCaseListCrawlDtos)) {
            return eCourtCaseDetailsList;
        }
        int counter = 0;
        for (EHighCourtCaseListCrawlDto eHighCourtCaseListCrawlDto : eHighCourtCaseListCrawlDtos) {
            if (LitigationUtils.getPartyInvolvementAndMatchingStatus(origPartyName,
                Collections.singleton(eHighCourtCaseListCrawlDto.getPetitionerName()),
                Collections.singleton(eHighCourtCaseListCrawlDto.getRespondentName())).getSystemAssignedStatus()
                == SystemAssignedStatus.UNMATCHED) {
                continue;
            }
            counter++;
            AtomicBoolean refetch = new AtomicBoolean(false);
            if (token == null) {
                refetch.set(true);
            }
            EHighCourtCaseDetailCrawlDto eHighCourtCaseDetailCrawlDto = null;
            int retryAttempts = 0;
            for (retryAttempts = 0; retryAttempts < MAX_DETAIL_RETRY_ATTEMPTS; retryAttempts++) {
                if (refetch.get()) {
                    try {
                        token = refetchTokenForData(origPartyName, partyName, year, bench, highCourt, headerMap,
                            variableMap, rotationIp);
                    } catch (RequestParsingException e) {
                        logger.error(MessageFormat.format("Error while refetching token in detail : using IP [{0}]",
                            rotationIp.name()), e);
                        if (year != DateUtils.getCurrentYear()) {
                            throw e;
                        }
                        logger.info("Current year case....... skipping");
                        continue;
                    }
                }
                if (token == null) {
                    logger.info("Cannot Refetch Token For this Case Skipping !!");
                    if (retryAttempts == MAX_DETAIL_RETRY_ATTEMPTS - 2) {
                        logger.info("sleeping for 60 seconds using ip [{}]", rotationIp.name());
                        Thread.sleep(60 * DateUtils.SECOND);
                    }
                    continue;
                }
                refetch.set(false);
                eHighCourtCaseDetailCrawlDto = getDetail(variableMap,
                    eHighCourtCaseListCrawlDto,
                    bench,
                    highCourt, headerMap, token, refetch, rotationIp);
                if (ObjectUtils.isNotBlankObject(eHighCourtCaseDetailCrawlDto)
                    || !refetch.get()) {
                    break;
                }
                if (retryAttempts == MAX_DETAIL_RETRY_ATTEMPTS - 2) {
                    Thread.sleep(60 * DateUtils.SECOND);
                }
            }
            if (retryAttempts == MAX_DETAIL_RETRY_ATTEMPTS && currYear != DateUtils.getCurrentYear()) {
                throw new RequestParsingException("Cannot Fetch Detail For Case ", TaskError.SERVER_DOWN);
            }
            if (ObjectUtils.isBlankObject(eHighCourtCaseDetailCrawlDto)) {
                continue;
            }
            try {
                EHighCourtParsedResult eHighCourtParsedResult =
                    convert(eHighCourtCaseDetailCrawlDto, partyName, origPartyName,
                        eHighCourtCaseListCrawlDto,
                        bench,
                        highCourt);
                eCourtCaseDetailsList.add(eHighCourtParsedResult);
            } catch (Exception e) {
                logger.error(MessageFormat.format(
                    "Parsing Exception while parsing case for bench {0} , highCourt {1} and partyName, {2}",
                    bench, highCourt, origPartyName), e);
            }
        }
        logger.info(MessageFormat.format(
            "FOUND_DETAIL_CASES Crawled : [{0}] , Fetched [{1}] , year [{2}], partyName [{3}]  bench [{4}]", counter,
            eCourtCaseDetailsList.size(), year + "", partyName, bench.name()));
        return eCourtCaseDetailsList;
    }

    
    private static Pair<String, List<EHighCourtCaseListCrawlDto>> getTokenAndCrawlDtos(String origPartyName,
        String partyName, int year, HighCourtBench bench, HighCourt highCourt, RotationIp rotationIp,
        Map<String, String> headerMap, Map<String, String> variableMap)
        throws InterruptedException, RequestParsingException {
        String token = null;
        String responseString = null;
        List<EHighCourtCaseListCrawlDto> eHighCourtCaseListCrawlDtos = new ArrayList<>();
        for (int searchRetryCount = 0; searchRetryCount < MAX_CAPTCHA_ATTEMPTS; searchRetryCount++) {
            responseString =
                getCaptchaAndTry(origPartyName, partyName, year, bench, highCourt, rotationIp, headerMap, variableMap,
                    searchRetryCount);
            if (responseString == null) {
                continue;
            }
            
            String[] responseList = responseString.split("##");
            if (ObjectUtils.isBlankObject(responseList)) {
                logger.info("No listing found for party {}", partyName);
                break;
            }
            

            for (String listed : responseList) {
                String[] values = listed.split("~");
                if (ObjectUtils.isBlankObject(values) || values.length < 5) {
                    continue;
                }
                String[] partiesInvolved = values[2].split("Versus");
                eHighCourtCaseListCrawlDtos.add(EHighCourtCaseListCrawlDto.Builder.eHighCourtCaseListCrawlDto()
                    .withPetitionerName(partiesInvolved[0])
                    .withRespondentName(partiesInvolved.length > 1 ? partiesInvolved[1] : "")
                    .withCaseNumber(values[0].replaceAll("[^a-z0-9 ]", ""))
                    .withCaseNumberId(values[4])
                    .withCino(values[3])
                    .build());
                if (token == null && values.length >= 8) {
                    token = values[7];
                }
            }
            logger.info("Found [{}] cases for party [{}] year[{}] bench[{}]",
                eHighCourtCaseListCrawlDtos.size(),
                partyName, year, bench);
            break;
        }
        if (responseString == null) {
            throw new RequestParsingException("Did not recieve detail after 10 retries ",
                TaskError.UNABLE_TO_BREAK_CAPTCHA);
        }
        return Pair.create(token, eHighCourtCaseListCrawlDtos);
    }

    private static String getCaptchaAndTry(String origPartyName, String partyName, int year, HighCourtBench bench,
        HighCourt highCourt, RotationIp rotationIp, Map<String, String> headerMap, Map<String, String> variableMap,
        int searchRetryCount)
        throws InterruptedException {
        String captcha = null;
        String responseString = null;
        try {
            captcha = getCaptcha(headerMap, rotationIp);
        } catch (Exception e) {
            logger.error(MessageFormat.format(
                "Cannot fetch captcha for highCourt: [{0}] bench: [{1}] and partyName: [{2}] searchRetryCount [{3}] using ip [{4}]",
                highCourt.name(), bench.name(), origPartyName, searchRetryCount, rotationIp.name()), e);
        }
        if (captcha == null) {
            logger.info(
                "Failed to Get Captcha highCourt: [{}] bench: [{}] and partyName: [{}] Sleeping for 15 sec... searchRetryCount [{}]  using ip [{}]",
                highCourt.name(),
                bench.name(), origPartyName, searchRetryCount, rotationIp.name());
            variableMap = getVariableMap(highCourt, bench, rotationIp);
            headerMap = getSessionIdHeaders(variableMap);
            Thread.sleep(15 * DateUtils.SECOND);
            return null;
        }
        if (captcha.length() < 5) {
            logger.info(
                "Invalid Captcha Received Retrying for highCourt: [{}] bench: [{}] partyName: [{}] searchRetryCount [{}]  using ip [{}]",
                highCourt.name(), bench.name(), origPartyName, searchRetryCount, rotationIp.name());
            return null;
        }
        List<BasicNameValuePair> formData = new ArrayList<>();
        formData.add(new BasicNameValuePair("__csrf_magic", variableMap.get("csrfMagicToken")));
        formData.add(new BasicNameValuePair("court_code", bench.getCourtCode()));
        formData.add(new BasicNameValuePair("state_code", highCourt.getStateCode()));
        formData.add(new BasicNameValuePair("dist_code", "1"));
        formData.add(new BasicNameValuePair("action_code", "showRecords"));
        formData.add(new BasicNameValuePair("f", "Both"));
        formData.add(new BasicNameValuePair("petres_name", partyName));
        formData.add(new BasicNameValuePair("rgyear", year + ""));
        formData.add(new BasicNameValuePair("captcha", captcha));
        try {
            String encodedFormData = encodeFormData(formData);
            HttpEntity multiPartEntity = new StringEntity(encodedFormData,
                ContentType.create(ContentType.APPLICATION_FORM_URLENCODED.getMimeType(), StandardCharsets.UTF_8));
            responseString =
                HttpAsyncClientUtils.putOrPostWithSpecificIp(TaskType.LITIGATION_E_HIGH_COURT, HttpMethod.POST,
                    SEARCH_RECORDS_URL, multiPartEntity, headerMap, 120 * (int) DateUtils.SECOND, rotationIp);
        } catch (Exception e) {
            logger.error(MessageFormat.format(
                "Cannot Post Search Request For party [{0}] year[{1}] bench[{2}] searchRetryCount [{3}]  using ip [{4}]",
                origPartyName,
                year, bench, searchRetryCount, rotationIp.name()), e);
        }
        if (responseString == null) {
            logger.info(
                "Null response received for PartyName : [{}] year[{}] bench[{}]  searchRetryCount [{}]  using ip [{}] Sleeping for 15 sec",
                origPartyName, year, bench, searchRetryCount, rotationIp.name());
            Thread.sleep(15 * DateUtils.SECOND);
            return null;
        }
        if (responseString.contains("Invalid Captcha") || responseString.contains("captcha tampering")) {
            logger.info(
                "Searching e-court case Invalid captcha for party [{}] year[{}] bench[{}]  searchRetryCount [{}] using ip [{}]",
                origPartyName, year, bench, searchRetryCount, rotationIp.name());
            return null;
        }
        if (responseString.contains("ERROR_VAL")
            || responseString.contains("ERROR")) {
            logger.info(
                "Error fetching response for party [{}] year[{}] bench[{}]  searchRetryCount [{}]  using ip [{}]",
                origPartyName, year, bench, searchRetryCount, rotationIp.name());
            return null;
        }
        return responseString;
    }

    private static String encodeFormData(List<BasicNameValuePair> formData) throws UnsupportedEncodingException {
        StringBuilder encodedForm = new StringBuilder();
        for (BasicNameValuePair pair : formData) {
            if (encodedForm.length() > 0) {
                encodedForm.append("&");
            }
            encodedForm.append(URLEncoder.encode(pair.getName(), StandardCharsets.UTF_8.toString()));
            encodedForm.append("=");
            encodedForm.append(URLEncoder.encode(pair.getValue(), StandardCharsets.UTF_8.toString()));
        }
        return encodedForm.toString();
    }

    private static Map<String, String> getVariableMap(HighCourt highCourt, HighCourtBench bench, RotationIp rotationIp)
        throws InterruptedException {
        return getVariables(1, highCourt, bench, rotationIp);
    }

    private static Map<String, String> getVariables(int tryCount, HighCourt highCourt, HighCourtBench bench,
        RotationIp rotationIp)
        throws InterruptedException {
        Map<String, String> variableMap = new HashMap<>();
        if (tryCount > 4) {
            return variableMap;
        }
        try {
            HttpResponse response =
                HttpAsyncClientUtils.getHttpResponseWithSpecifIp(TaskType.LITIGATION_E_HIGH_COURT, DETAIL_URL
                        + "?state_cd="
                        + highCourt.getStateCode()
                        + "&dist_cd=1&court_code="
                        + bench.getCourtCode(),
                    new HashMap<>(), (int) (60 * DateUtils.SECOND), rotationIp);
            Map<String, String> sessionIdMap = getSessionIdMapFromResponse(response);

            if (response == null) {
                logger.info("Null response received in fetching variable map for IP  {} Sleeping for 30 sec",
                    rotationIp.name());
                Thread.sleep(30 * DateUtils.SECOND);
            }
            if (ObjectUtils.isBlank(sessionIdMap.get("sessionId")) || ObjectUtils.isBlank(
                sessionIdMap.get("JSESSION"))) {
                return getVariables(tryCount + 1, highCourt, bench, rotationIp);
            }
            variableMap.put("sessionId", sessionIdMap.get("sessionId"));
            variableMap.put("JSESSION", sessionIdMap.get("JSESSION"));
            String rawHome = HttpUtils.getStringResponse(response);
            String csrfMagicTokenKey = "csrfMagicToken = ";
            if (rawHome.contains(csrfMagicTokenKey)) {
                int convIdStartIndex = rawHome.indexOf(csrfMagicTokenKey) + csrfMagicTokenKey.length();
                int convIdEndIndex = rawHome.indexOf(";", convIdStartIndex);
                String csrfMagicToken = rawHome.substring(convIdStartIndex, convIdEndIndex);
                csrfMagicToken = csrfMagicToken.replace("\"", "");
                variableMap.put("csrfMagicToken", csrfMagicToken);
            }
        } catch (Exception e) {
            logger.error("IO Error :", e);
            Thread.sleep(30 * DateUtils.SECOND);
            return getVariables(tryCount + 1, highCourt, bench, rotationIp);
        }
        return variableMap;
    }

    private static Map<String, String> getSessionIdMapFromResponse(HttpResponse response) {
        if (response == null) {
            return Collections.emptyMap();
        }
        Header[] headers = response.getHeaders("Set-Cookie");
        Map<String, String> sessionIdMap = new HashMap<>();
        for (int i = 0; i < headers.length; i++) {
            String[] cookies = headers[i].getValue().split(";");
            if (ObjectUtils.isBlankObject(cookies) || headers[i].getValue().contains("/hcservices")) {
                continue;
            }
            for (String cookie : cookies) {
                if (cookie.contains("PHPSESSID")) {
                    sessionIdMap.put("sessionId", cookie.split("=")[1].trim());
                }
                if (cookie.contains("JSESSION")) {
                    sessionIdMap.put("JSESSION", cookie.split("=")[1].trim());
                }
            }
        }

        return sessionIdMap;
    }

    private static Map<String, String> getSessionIdHeaders(Map<String, String> variableMap) {
        return getSessionIdHeaders(variableMap, new HashMap<>());
    }

    private static Map<String, String> getSessionIdHeaders(Map<String, String> variableMap,
        Map<String, String> headers) {
        String sessionId = variableMap.get("sessionId");
        String jSession = variableMap.get("JSESSION");
        if (headers == null) {
            headers = new HashMap<>();
        } else {
            headers.clear();
        }
        if (org.apache.commons.lang3.StringUtils.isNotBlank(sessionId)
            && org.apache.commons.lang3.StringUtils.isNotBlank(jSession)) {
            String cookieValue = "JSESSION=" + jSession + "; PHPSESSID=" + sessionId;
            headers.put(HttpHeaders.COOKIE, cookieValue);
        }
        headers.put("Referer", "https:
        headers.put("Origin", "https:
        headers.put("Host", "hcservices.ecourts.gov.in");
        headers.put("Accept", "*

    private static String getCaptcha(Map<String, String> headers, RotationIp rotationIp) throws Exception {
        headers.remove("Content-Type");
        return CaptchaServer.solveCaptchaWithSpecifcIp(TaskType.LITIGATION_E_HIGH_COURT, CAPTCHA_URL,
            headers, CAPTCHA_SERVER_END_POINT, "png", rotationIp);
    }

    private static String refetchTokenForData(String origPartyName, String partyName, int year, HighCourtBench bench,
        HighCourt highCourt, Map<String, String> headers, Map<String, String> variableMap, RotationIp rotationIp)
        throws RequestParsingException {
        String token = null;
        try {
            token =
                getTokenAndCrawlDtos(origPartyName, partyName, year, bench, highCourt, rotationIp, headers,
                    variableMap).first;
        } catch (RequestParsingException e) {
            throw e;
        } catch (Exception e) {
            logger.error("Caught exception while refetching token", e);
        }
        return token;
    }

    
    private static EHighCourtCaseDetailCrawlDto getDetail(Map<String, String> variableMap,
        EHighCourtCaseListCrawlDto eHighCourtCaseListCrawlDto,
        HighCourtBench highCourtBench, HighCourt highCourt, Map<String, String> headers,
        String token, AtomicBoolean refetchToken, RotationIp rotationIp) {
        if (token == null) {
            refetchToken.set(true);
            return null;
        }
        String csrfMagicToken = variableMap.get("csrfMagicToken");
        for (int detailRetry = 0; detailRetry < 3; detailRetry++) {
            try {
                List<BasicNameValuePair> formParams = new ArrayList<>();
                formParams.add(new BasicNameValuePair("__csrf_magic", csrfMagicToken));
                formParams.add(new BasicNameValuePair("court_code", highCourtBench.getCourtCode()));
                formParams.add(new BasicNameValuePair("state_code", highCourt.getStateCode()));
                formParams.add(new BasicNameValuePair("dist_code", "1"));
                formParams.add(new BasicNameValuePair("case_no", eHighCourtCaseListCrawlDto.getCaseNumber()));
                formParams.add(new BasicNameValuePair("cino", eHighCourtCaseListCrawlDto.getCino()));
                formParams.add(new BasicNameValuePair("token", token));
                formParams.add(new BasicNameValuePair("appFlag", ""));
                String encodedFormData = encodeFormData(formParams);
                HttpEntity multiPartEntity = new StringEntity(encodedFormData,
                    ContentType.create(ContentType.APPLICATION_FORM_URLENCODED.getMimeType(), StandardCharsets.UTF_8));
                HttpResponse response =
                    HttpAsyncClientUtils.putOrPostAndGetHttpResponseWithSpecificIp(TaskType.LITIGATION_E_HIGH_COURT,
                        HttpMethod.POST,
                        CASE_HISTORY_URL, multiPartEntity, headers, 120 * (int) DateUtils.SECOND, rotationIp);
                if (response == null) {
                    Thread.sleep(30 * DateUtils.SECOND);
                    continue;
                }
                Document doc = HttpUtils.getDocumentFromHttpResponse(response, CASE_HISTORY_URL);
                
                return parseResponseDetails(doc, refetchToken);
            } catch (Throwable throwable) {
                logger.error(MessageFormat.format(
                    "error while getting details for caseNumber : [{0}] and cnrNumber : [{1}]",
                    eHighCourtCaseListCrawlDto.getCaseNumber(), eHighCourtCaseListCrawlDto.getCaseNumber()), throwable);
                refetchToken.set(true);
                return null;
            }
        }
        return null;
    }

    
    private static EHighCourtCaseDetailCrawlDto parseResponseDetails(Document document, AtomicBoolean refetchToken) {
        if (document != null && document.toString().contains("INVALID REQUEST") || document.toString()
            .contains("session expired")) {
            refetchToken.set(true);
            return null;
        }
        Elements caseDetailsTable = document.getElementsByClass("case_details_table");
        if (caseDetailsTable.size() == 0) {
            return null;
        }
        String caseType = caseDetailsTable.get(0).text().split(":")[1].replaceAll("\\u00a0", "");

        String filingNumberStr = caseDetailsTable.get(1).text().split(":")[1];
        String filingNumber = filingNumberStr.substring(0, filingNumberStr.indexOf("Filing")).replaceAll("\\u00a0", "");

        String filingDate = null;
        if (caseDetailsTable.get(1).text().split(":").length > 2) {
            filingDate = caseDetailsTable.get(1).text().split(":")[2].replaceAll("\\u00a0", "");
        }

        String registrationNumberStr = caseDetailsTable.get(2).text().split(":")[1];
        String registrationNumber =
            registrationNumberStr.substring(0, registrationNumberStr.indexOf("Registration")).replaceAll("\\u00a0", "");

        String registrationDate = null;
        if (caseDetailsTable.get(2).text().split(":").length > 2) {
            registrationDate = caseDetailsTable.get(2).text().split(":")[2].replaceAll("\\u00a0", "");
        }

        String cnrNumber = caseDetailsTable.get(3).text().split(":")[1].replaceAll("\\u00a0", "");

        Elements caseStatusElement = document.getElementsContainingOwnText("Case Status").next().select("span");
        String firstHearing = "";
        String nextHearing = "";
        String stageOfCases = "";
        String caseStatus = "";
        String coram = "";
        String benchType = "";
        String state = "";
        String district = "";
        String judicial = "";
        String causelistName = "";
        for (Element status : caseStatusElement) {
            String parsedText = status.text().split(":")[1].replaceAll("\\u00a0", "");
            switch (status.text().split(":")[0].trim()) {
                case "First Hearing Date":
                    firstHearing = parsedText;
                    break;
                case "Next Hearing Date":
                    nextHearing = parsedText;
                    break;
                case "Case Status":
                    caseStatus = parsedText;
                    break;
                case "Stage of Case":
                    stageOfCases = parsedText;
                    break;
                case "Coram":
                    coram = parsedText;
                    break;
                case "Bench":
                    benchType = parsedText;
                    break;
                case "State":
                    state = parsedText;
                    break;
                case "District":
                    district = parsedText;
                    break;
                case "Judicial":
                    judicial = parsedText;
                    break;
                case "Causelist Name":
                    causelistName = parsedText;
                    break;
            }
        }

        Element petitionerAndAdvocateInfo =
            document.getElementsByClass("Petitioner_Advocate_table").first();

        Set<String> petitionerNames = new HashSet<>();
        String petitionerAdvocate = null;
        if (petitionerAndAdvocateInfo != null) {
            for (Node childNode : petitionerAndAdvocateInfo.childNodes()) {
                if (!(childNode instanceof TextNode)) {
                    continue;
                }
                String normalizeSpace = org.apache.commons.lang3.StringUtils.normalizeSpace(
                    ((TextNode) childNode).text());
                if (org.apache.commons.lang3.StringUtils.isBlank(normalizeSpace)) {
                    continue;
                }
                if (normalizeSpace.contains("Advocate")) {
                    petitionerAdvocate =
                        org.apache.commons.lang3.StringUtils.normalizeSpace(
                            normalizeSpace.replaceAll("&nbsp;", "").replaceAll("Advocate", "")
                                .replaceAll("[^a-zA-Z, ]+", ""));
                } else {
                    String partyName =
                        org.apache.commons.lang3.StringUtils.normalizeSpace(
                            normalizeSpace.replaceAll("M/S", "").replaceAll("[^a-zA-Z ]+", ""));
                    if (org.apache.commons.lang3.StringUtils.isNotBlank(partyName)) {
                        petitionerNames.add(partyName);
                    }
                }
            }
        }

        Element respondentAndAdvocateInfoSpan =
            document.getElementsByClass("Respondent_Advocate_table").first();
        Set<String> respondentNames = new HashSet<>();
        String respondentAdvocate = null;
        if (respondentAndAdvocateInfoSpan != null) {
            for (Node childNode : respondentAndAdvocateInfoSpan.childNodes()) {
                if (!(childNode instanceof TextNode)) {
                    continue;
                }
                String normalizeSpace = org.apache.commons.lang3.StringUtils.normalizeSpace(
                    ((TextNode) childNode).text());
                if (org.apache.commons.lang3.StringUtils.isBlank(normalizeSpace)) {
                    continue;
                }
                if (normalizeSpace.contains("Advocate")) {
                    respondentAdvocate =
                        org.apache.commons.lang3.StringUtils.normalizeSpace(
                            normalizeSpace.replaceAll("&nbsp;", "").replaceAll("Advocate", "")
                                .replaceAll("[^a-zA-Z, ]+", ""));
                } else {
                    String partyName =
                        org.apache.commons.lang3.StringUtils.normalizeSpace(
                            normalizeSpace.replaceAll("M/S", "").replaceAll("[^a-zA-Z ]+", ""));
                    if (org.apache.commons.lang3.StringUtils.isNotBlank(partyName)) {
                        respondentNames.add(partyName);
                    }
                }
            }
        }

        Elements orderTable =
            document.getElementsByClass("order_table");

        List<EHighCourtOrderHistory> orderHistories = new ArrayList<>();
        if (ObjectUtils.isNotBlankObject(orderTable)) {
            Elements tableElements = orderTable.select("tbody").select("tr");
            if (ObjectUtils.isNotBlankObject(tableElements)) {
                for (Element tableElement : tableElements) {
                    
                    
                    if (tableElement.text().contains("OBJECTION")) {
                        break;
                    }
                    if (tableElement.text().contains("Order Number")) {
                        continue;
                    }
                    Long orderDate =
                        getTimeSilently(tableElement.select(" td:eq(3) ").text().trim().replaceAll("\\u00a0", ""),
                            "dd-MM-yyyy");
                    if (orderDate == null) {
                        continue;
                    }
                    orderHistories.add(EHighCourtOrderHistory.Builder.eHighCourtOrderHistory()
                        .withJudge(tableElement.select(" td:eq(1) ").text().trim().replaceAll("\\u00a0", ""))
                        .withOrderDate(
                            orderDate)
                        .withOrderUrl(ORDER_DOC_BASE_URL + tableElement.select(" td:eq(3) ")
                            .select("a")
                            .attr("href")
                            .trim()
                            .replaceAll(
                                "\\u00a0", ""))
                        .build());
                }
            }
        }

        Map<Long, EHighCourtOrderHistory> orderDateToDetailMap = new HashMap<>();
        for (EHighCourtOrderHistory orderHistory : orderHistories) {
            if (orderHistory.getOrderDate() == null || orderHistory.getOrderDate() < 0) {
                continue;
            }
            Long startOfDay = DateUtils.getStartOfDay(orderHistory.getOrderDate());
            orderDateToDetailMap.put(startOfDay, orderHistory);
        }

        Elements historyTable =
            document.getElementsByClass("history_table");

        List<EHighCourtHearingHistory> hearingHistory = new ArrayList<>();
        if (ObjectUtils.isNotBlankObject(historyTable)) {
            Elements tableElements = historyTable.select("tbody").select("tr");
            if (ObjectUtils.isNotBlankObject(tableElements)) {
                for (Element tableElement : tableElements) {
                    if (tableElement.text().contains("Hearing Date")) {
                        continue;
                    }
                    Long hearingDate =
                        getTimeSilently(tableElement.select(" td:eq(2) ").text().trim().replaceAll("\\u00a0", ""),
                            "dd-MM-yyyy");
                    if (hearingDate == null) {
                        continue;
                    }
                    EHighCourtOrderHistory eHighCourtOrderHistory =
                        orderDateToDetailMap.get(DateUtils.getStartOfDay(hearingDate));
                    hearingHistory.add(EHighCourtHearingHistory.Builder.eHighCourtHearingHistory()
                        .withCauseListType(tableElement.select(" td:eq(0) ").text().trim().replaceAll("\\u00a0", ""))
                        .withJudge(tableElement.select(" td:eq(1) ").text().trim().replaceAll("\\u00a0", ""))
                        .withBusinessOnDate(
                            getTimeSilently(tableElement.select(" td:eq(2) ").text().trim().replaceAll("\\u00a0", ""),
                                "dd-MM-yyyy"))
                        .withHearingDate(hearingDate)
                        .withPurposeOfHearing(tableElement.select(" td:eq(4) ").text().trim().replaceAll("\\u00a0", ""))
                        .withDocumentUrl(eHighCourtOrderHistory != null ? eHighCourtOrderHistory.getOrderUrl() : null)
                        .build());
                }
            }
        }

        return EHighCourtCaseDetailCrawlDto.Builder.eHighCourtCaseDetailCrawlDto()
            .withFilingNumber(filingNumber)
            .withFilingDate(filingDate)
            .withRegistrationNumber(registrationNumber)
            .withRegistrationDate(registrationDate)
            .withFirstHearing(firstHearing)
            .withNextHearing(nextHearing)
            .withCaseStage(stageOfCases)
            .withCaseStatus(caseStatus)
            .withCoram(coram)
            .withBenchType(benchType)
            .withJudicialBranch(judicial)
            .withState(state)
            .withDistrict(district)
            .withPetitionerNames(petitionerNames)
            .withPetitionerAdvocates(petitionerAdvocate)
            .withRespondentNames(respondentNames)
            .withRespondentAdvocates(respondentAdvocate)
            .withLastHearingDate("")
            .withHearingHistories(hearingHistory)
            .withOrderHistories(orderHistories)
            .build();
    }

    
    private static EHighCourtParsedResult convert(EHighCourtCaseDetailCrawlDto eHighCourtCaseDetailCrawlDto,
        String partyName, String originalPartyName, EHighCourtCaseListCrawlDto eHighCourtCaseListCrawlDto,
        HighCourtBench highCourtBench,
        HighCourt highCourt) throws ParseException {
        if (eHighCourtCaseDetailCrawlDto == null) {
            return null;
        }
        Date filingDate = DateUtils.parse(DATE_FORMAT, eHighCourtCaseDetailCrawlDto.getFilingDate());
        Date registrationDate = DateUtils.parse(DATE_FORMAT, eHighCourtCaseDetailCrawlDto.getRegistrationDate());
        Date lastHearingDate = DateUtils.parse(DATE_FORMAT, eHighCourtCaseDetailCrawlDto.getLastHearingDate());
        Date nextHearingDate = DateUtils.parse(DATE_FORMAT, eHighCourtCaseDetailCrawlDto.getNextHearing());
        EHighCourtParsedResult eCourtCaseDetails =
            EHighCourtParsedResult.Builder.eHighCourtParsedResult()
                .withPartyName(partyName)
                .withHighCourt(highCourt)
                .withHighCourtBench(highCourtBench)
                .withCaseNo(eHighCourtCaseListCrawlDto.getCaseNumber())
                .withCnrNumber(eHighCourtCaseListCrawlDto.getCino())
                .withCoram(eHighCourtCaseDetailCrawlDto.getCoram())
                .withBenchType(eHighCourtCaseDetailCrawlDto.getBenchType())
                .withJudicialBranch(eHighCourtCaseDetailCrawlDto.getJudicialBranch())
                .withState(eHighCourtCaseDetailCrawlDto.getState())
                .withDistrict(eHighCourtCaseDetailCrawlDto.getDistrict())
                .withFilingDate(ObjectUtils.isNotBlankObject(filingDate) ? filingDate.getTime() : null)
                .withPetitioners(eHighCourtCaseDetailCrawlDto.getPetitionerNames())
                .withPetAdvocates(eHighCourtCaseDetailCrawlDto.getPetitionerAdvocates())
                .withRespondents(eHighCourtCaseDetailCrawlDto.getRespondentNames())
                .withResAdvocates(eHighCourtCaseDetailCrawlDto.getRespondentAdvocates())
                .withRegisteredOn(ObjectUtils.isNotBlankObject(registrationDate) ? registrationDate.getTime() : null)
                .withCaseStatus((ObjectUtils.isNotBlank(eHighCourtCaseDetailCrawlDto.getCaseStatus()) ?
                    CaseStatus.fromString(eHighCourtCaseDetailCrawlDto.getCaseStatus()) :
                    CaseStatus.fromString(eHighCourtCaseDetailCrawlDto.getCaseStage())) != CaseStatus.DISPOSED ?
                    CaseStatus.PENDING : CaseStatus.DISPOSED)
                .withLastListed(ObjectUtils.isNotBlankObject(lastHearingDate) ? lastHearingDate.getTime() : null)
                .withNextHearingDate(nextHearingDate != null ? nextHearingDate.getTime() : null)
                .withMatchedWith(null)
                .withSystemAssignedStatus(SystemAssignedStatus.PENDING)
                .withPartyInvolvement(PartyInvolvement.UNKNOWN)
                .withHearingHistories(eHighCourtCaseDetailCrawlDto.getHearingHistories())
                .withOrderHistories(eHighCourtCaseDetailCrawlDto.getOrderHistories())
                .withDetailUrl(DETAIL_URL + "?state_cd=" + highCourt.getStateCode() +
                    "&dist_cd=1&court_code=" + highCourtBench.getCourtCode())
                .build();
        InvolvementAndMatchDto
            involvementAndMatchDto =
            LitigationUtils.getPartyInvolvementAndMatchingStatus(originalPartyName, eCourtCaseDetails.getPetitioners(),
                eCourtCaseDetails.getRespondents());
        eCourtCaseDetails.setPartyInvolvement(involvementAndMatchDto.getPartyInvolvement());
        eCourtCaseDetails.setMatchedWith(involvementAndMatchDto.getMatchedWith());
        eCourtCaseDetails.setSystemAssignedStatus(involvementAndMatchDto.getSystemAssignedStatus());
        return eCourtCaseDetails;
    }

    public static void main(String[] args) throws Throwable {
        String partyName = "reliance industries";
        long startTime = System.currentTimeMillis();
        List<EHighCourtParsedResult> results =
            parseCaseByPartyName(partyName, UUID.randomUUID().toString(), 2021, new DateTime().getYear());
        long fetchtime = System.currentTimeMillis() - startTime;
        System.out.println("Fetched in: " + fetchtime + " size: " + results.size());
        
        Set<EHighCourtParsedResult> res = results.stream().filter(result -> ObjectUtils.isNotBlankObject(result))
            .collect(Collectors.toSet());
    }
}


package com.ofb.crawler.commons.types.litigation.itat.dto.parsing;

@Data
@NoArgsConstructor
public class ItatParsingDto extends BaseParsingDto {

    private String assesseeName;

    public ItatParsingDto(String assesseeName) {
        this.assesseeName = assesseeName;
    }

    public ItatParsingDto(String parsingId, String requestId, TaskType taskType, long parsingTime, String responseUrl, String assesseeName) {
        super(parsingId, requestId, taskType, parsingTime, responseUrl);
        this.assesseeName = assesseeName;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ItatParsingDto that = (ItatParsingDto) o;
        return Objects.equals(assesseeName, that.assesseeName);
    }

    @Override
    public int hashCode() {
        return Objects.hash(assesseeName);
    }

    public static interface ParsingIdStep {
        RequestIdStep withParsingId(String parsingId);
    }

    public static interface RequestIdStep {
        TaskTypeStep withRequestId(String requestId);
    }

    public static interface TaskTypeStep {
        ParsingTimeStep withTaskType(TaskType taskType);
    }

    public static interface ParsingTimeStep {
        ResponseUrlStep withParsingTime(long parsingTime);
    }

    public static interface ResponseUrlStep {
        AssesseeNameStep withResponseUrl(String responseUrl);
    }

    public static interface AssesseeNameStep {
        BuildStep withAssesseeName(String assesseeName);
    }

    public static interface BuildStep {
        ItatParsingDto build();
    }


    public static class Builder implements ParsingIdStep, RequestIdStep, TaskTypeStep, ParsingTimeStep, ResponseUrlStep, AssesseeNameStep, BuildStep {
        private String parsingId;
        private String requestId;
        private TaskType taskType;
        private long parsingTime;
        private String responseUrl;
        private String assesseeName;

        private Builder() {
        }

        public static ParsingIdStep itatParsingDto() {
            return new Builder();
        }

        @Override
        public RequestIdStep withParsingId(String parsingId) {
            this.parsingId = parsingId;
            return this;
        }

        @Override
        public TaskTypeStep withRequestId(String requestId) {
            this.requestId = requestId;
            return this;
        }

        @Override
        public ParsingTimeStep withTaskType(TaskType taskType) {
            this.taskType = taskType;
            return this;
        }

        @Override
        public ResponseUrlStep withParsingTime(long parsingTime) {
            this.parsingTime = parsingTime;
            return this;
        }

        @Override
        public AssesseeNameStep withResponseUrl(String responseUrl) {
            this.responseUrl = responseUrl;
            return this;
        }

        @Override
        public BuildStep withAssesseeName(String assesseeName) {
            this.assesseeName = assesseeName;
            return this;
        }

        @Override
        public ItatParsingDto build() {
            return new ItatParsingDto(
                    this.parsingId,
                    this.requestId,
                    this.taskType,
                    this.parsingTime,
                    this.responseUrl,
                    this.assesseeName
            );
        }
    }
}

package com.ofb.crawler.core.types.cibilDefaults.service;

@Service
public class CibilDefaultsParserCallback extends BaseParserCallback<CibilDefaultsDetailDto, CibilDefaultsTaskParamsDto> {

    private static final Logger LOGGER = LoggerFactory.getLogger(CibilDefaultsParserCallback.class);

    private static final String INFO_URL_1CR =
        "https:

    private static final String INFO_URL_25LAC =
        "https:

    private static final String GOOGLE_WEB_CACHE_URL =
        "https:

    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();

    private static final Map<String, String> QUARTER_STRING_TO_ID_MAP = new HashMap<>();

    private static final int MAX_RETRY_COUNT = 5;

    private static long quarterFetchTime = 0L;

    @Override
    public TaskType getTaskType() {
        return TaskType.CIBIL_DEFAULTS;
    }

    @Override
    public CibilDefaultsDetailDto parse(CibilDefaultsTaskParamsDto cibilDefaultsTaskParamsDto) throws Throwable {
        return parseCibilDefaults(cibilDefaultsTaskParamsDto);
    }

    private static CibilDefaultsDetailDto parseCibilDefaults(CibilDefaultsTaskParamsDto cibilDefaultsTaskParamsDto)
        throws Throwable {
        if (cibilDefaultsTaskParamsDto == null) {
            return null;
        }
        String companyName = cibilDefaultsTaskParamsDto.getCompanyName();
        Long fromTime = cibilDefaultsTaskParamsDto.getFromTime();
        return CibilDefaultsDetailDto.Builder.cibilDefaultsDetailDto()
            .withParsingId(String.valueOf(UUID.randomUUID()))
            .withTaskType(TaskType.CIBIL_DEFAULTS)
            .withParsingTime(System.currentTimeMillis())
            .withBaseTaskParamsDto(null)
            .withCibilDefaultsResult(getDataForOrganisation(companyName, fromTime, cibilDefaultsTaskParamsDto.getRequestId()))
            .withCibilDefaultsTaskParamsDto(cibilDefaultsTaskParamsDto)
            .build();
    }

    private static CibilDefaultsResult getDataForOrganisation(String companyName, Long fromTime, String requestId) throws Exception {
        if (ObjectUtils.isBlank(companyName)) {
            return null;
        }
        String sanitizedCompanyName = sanitizeName(companyName);
        fetchQuarterIds();
        long startTime = System.currentTimeMillis();
        List<String> quartersForSearch = getQuartersForSearch(fromTime);
        List<DefaultData> dataAbove1Cr =
            getDefaultData(INFO_URL_1CR, companyName, sanitizedCompanyName, quartersForSearch, requestId);
        List<DefaultData> dataAbove25lac =
            getDefaultData(INFO_URL_25LAC, companyName, sanitizedCompanyName, quartersForSearch, requestId);
        long timeTaken = System.currentTimeMillis() - startTime;
        LOGGER.info("Time taken in fetching data for: {} in CibilDefaults Took: {} seconds", companyName,
            timeTaken / 1000.0);
        return CibilDefaultsResult.Builder.cibilDefaultsResult()
            .withAbove1cr(dataAbove1Cr)
            .withAbove25lac(dataAbove25lac)
            .build();
    }

    private static List<DefaultData> getDefaultData(String infoUrl, String companyName, String sanitizedCompanyName,
        List<String> quartersForSearch, String requestId)
        throws Exception {
        if (ObjectUtils.isBlankObject(quartersForSearch)) {
            return Collections.emptyList();
        }
        List<DefaultData> defaultDataList = new ArrayList<>();
        Integer counter = 1;
        List<Callable<List<DefaultData>>> callables = new ArrayList<>();
        for (String quarter : quartersForSearch) {
            Integer finalCounter = counter;
            callables.add(() -> {
                List<DefaultData>
                    defaultDataDtoListForQuarter =
                    getDefaultDataForQuarterForUrlType(infoUrl, sanitizedCompanyName, quarter);
                LOGGER.info("Quarter number: {} Completed out of {}", finalCounter, quartersForSearch.size());
                return defaultDataDtoListForQuarter;
            });
            counter++;
        }
        ExecutorService executorService = ExecutorServicesPool.fixedThreadPool(requestId, 4);
        List<DefaultData> nameMatchFilteredList = new ArrayList<>();
        try {
            List<Future<List<DefaultData>>> futures = executorService.invokeAll(callables);
            for (Future<List<DefaultData>> future : futures) {
                try {
                    defaultDataList.addAll(future.get());
                } catch (Exception e) {
                    LOGGER.error("Failed to get response from future", e);
                    if (e.getCause() instanceof RequestParsingException) {
                        throw (RequestParsingException) e.getCause();
                    }
                }
            }
            for (DefaultData defaultData : defaultDataList) {
                String name = defaultData.getBorrowerName();
                if (ObjectUtils.isNotBlankObject(name) && isNameMatched(companyName, name)) {
                    nameMatchFilteredList.add(defaultData);
                }
            }
        } catch (Exception e) {
            LOGGER.error("Error while fetching Cibil Defaults info", e);
        } finally {
            executorService.shutdown();
        }
        return nameMatchFilteredList;
    }

    private static List<DefaultData> getDefaultDataForQuarterForUrlType(String infoUrl, String companyName,
        String quarter)
        throws UnsupportedEncodingException, RequestParsingException {
        String suitSearchBeanJsonNonEncoded = "{\"borrowerName\":\""
            + companyName
            + "\",\"costAmount\":\"\","
            + "\"stateName\":\"\","
            + "\"directorName\":\"\",\"branchBean\":null,\"dunsNumber\":\"\",\"city\":\"\",\"bankBean\":{\"bankId\":0,\"bankName\":\"\",\"categoryBean\":"
            + "{\"categoryId\":0,\"categoryName\":\"\",\"categoryAllotedId\":\"\",\"active\":0,\"enable\":false},"
            + "\"bankNoRecords\":0,\"bankTotalAmount\":\"\",\"enable\":false,\"active\":0},\"quarterBean\":"
            + "{\"quarterId\":"
            + quarter
            + ",\"quarterDate\":null,\"quarterDateStr\":\"\",\"quarterName\":\"\",\"quarterMonthStr\":\"\",\""
            + "quarterYearStr\":\"\",\"isPush\":0},\"stateBean\":{\"stateId\":0,\"stateName\":\"\",\"stateNoRecords\":0,\""
            + "stateTotalAmount\":\"\",\"category\":\"\",\"enable\":false,\"isActive\":0},\"borrowerAddress\":null,\"borrowerId\":0,"
            + "\"sort\":0,\"totalRecords\":0,\"totalAmount\":\"\",\"quarterCol\":\"\",\"categoryBean\":null,\"noOFCGs1Cr\":0,\"records1Cr"
            + "\":0,\"noOFCGs25Lac\":0,\"records25Lac\":0,\"cat\":\"\",\"catGroup\":\"\",\"fromQuarterId\":0,\"toQuarterId\":0,"
            + "\"partyTypeId\":0,\"quarterId\":0,\"srNo\":\"\",\"userComments\":\"\",\"importDataBean\":null,\"rejected\":0,\"user"
            + "\":null,\"uploadBatchBean\":null,\"rejectComment\":\"\",\"lastLimit\":0,\"firstLimit\":0,\"reject\":null,\"edit\":null,"
            + "\"modify\":null,\"editedTotalAmount\":null,\"editedDirectorNames\":null,\"rejectComments\":null,\"updateReject\":\"\",\"userId"
            + "\":0,\"directorBean\":{\"dirId\":0,\"dir\":null,\"dinDir\":\"\",\"dirp25lId\":0,\"dirp1crId\":0,\"dirPrefix\":null,\"dirSufix"
            + "\":null,\"dirStatus\":null,\"dirDeleteDate\":null,\"panDir\":\"\"},\"isReview\":\"\",\"sortBy\":null,\"sortOrder\":null,"
            + "\"summaryState\":\"\",\"summaryType\":\"\",\"directorId\":0,\"directorSuffix\":\"\",\"dinNumber\":\"\",\"editedDirectorDin"
            + "\":null,\"dirPan\":\"\",\"editedDirectorPan\":null,\"title\":\"\"}";

        String suitSearchBeanJson = URLEncoder.encode(suitSearchBeanJsonNonEncoded, StandardCharsets.UTF_8.toString());

        long now = System.currentTimeMillis();
        String timeInString = Long.toString(now);
        String urlForQuarterWithoutPageNo = infoUrl + suitSearchBeanJson + "&_search=false&nd="
            + timeInString;

        List<DefaultData> dataForQuarter = getDataForUrlWithoutPageNumber(urlForQuarterWithoutPageNo);

        for (DefaultData defaultData : dataForQuarter) {
            QuarterInfo quarterInfo = defaultData.getQuarterInfo();
            quarterInfo.setQuarterId(Integer.parseInt(quarter));
            defaultData.setQuarterInfo(quarterInfo);
        }
        return dataForQuarter;
    }

    private static List<DefaultData> getDataForUrlWithoutPageNumber(String urlWithoutPageNo)
        throws RequestParsingException {
        if (ObjectUtils.isBlank(urlWithoutPageNo)) {
            return Collections.emptyList();
        }
        String urlWithPageNumber = String.format("%s&rows=50&page=%d&sidx=&sord=asc", urlWithoutPageNo, 1);
        DefaultsDto defaultsDto = getDataFromApi(urlWithPageNumber);
        if (defaultsDto == null) {
            return Collections.emptyList();
        }
        int totalPages = defaultsDto.getTotalPages();
        if (totalPages == 1) {
            if (ObjectUtils.isBlankObject(defaultsDto.getCibilDefaultDataDtoList())) {
                return Collections.emptyList();
            }
            return convertToDefaultDataListWithDirectorList(defaultsDto.getCibilDefaultDataDtoList());
        }
        List<CibilDefaultDataDto> cibilDefaultDataDtoList = new ArrayList<>(defaultsDto.getCibilDefaultDataDtoList());

        for (int i = 2; i <= totalPages; i++) {
            String urlForPage = String.format("%s&rows=50&page=%d&sidx=&sord=asc", urlWithoutPageNo, i);
            DefaultsDto defaultsDtoForPage = getDataFromApi(urlForPage);
            if (defaultsDtoForPage == null) {
                continue;
            }
            cibilDefaultDataDtoList.addAll(defaultsDtoForPage.getCibilDefaultDataDtoList());
        }

        return convertToDefaultDataListWithDirectorList(cibilDefaultDataDtoList);
    }

    private static List<DefaultData> convertToDefaultDataListWithDirectorList(List<CibilDefaultDataDto> cibilDefaultDataDtoList) {
        if (ObjectUtils.isBlankObject(cibilDefaultDataDtoList)) {
            return Collections.emptyList();
        }
        List<DefaultData> defaultDataList = new ArrayList<>();
        for (CibilDefaultDataDto cibilDefaultDataDto : cibilDefaultDataDtoList) {
            if (cibilDefaultDataDto.getBorrowerId() == null) {
                continue;
            }
            String directorFullData = cibilDefaultDataDto.getDirectorName();
            defaultDataList.add(DefaultData.Builder.defaultData()
                .withBorrowerName(cibilDefaultDataDto.getBorrowerName())
                .withStateName(cibilDefaultDataDto.getStateName())
                .withDirectorName(cibilDefaultDataDto.getDirectorName())
                .withBorrowerId(cibilDefaultDataDto.getBorrowerId().toString())
                .withTotalAmount(cibilDefaultDataDto.getTotalAmount())
                .withQuarterInfo(cibilDefaultDataDto.getQuarterInfo())
                .withAddressInfo(cibilDefaultDataDto.getAddressInfo())
                .withBankInfo(cibilDefaultDataDto.getBankInfo())
                .withDirectorNameList(cleanStringToList(directorFullData))
                .build());
        }
        return defaultDataList;
    }

    private static List<DirectorData> cleanStringToList(String directorFullData) {
        if (ObjectUtils.isBlank(directorFullData)) {
            return Collections.emptyList();
        }
        List<DirectorData> directorDataList = new ArrayList<>();
        String[] directors = directorFullData.split(",");
        for (String director : directors) {
            String trimmedString = director.trim();
            String[] parts = trimmedString.split("--");
            if (parts.length != 2) {
                continue;
            }
            directorDataList.add(DirectorData.Builder.directorData()
                .withName(parts[0].replaceAll("\\(.*?\\)", "").trim())
                .withDin("NA".equals(parts[1]) ? null : parts[1])
                .build());
        }
        return directorDataList;
    }

    private static DefaultsDto getDataFromApi(String url) throws RequestParsingException {
        if (ObjectUtils.isBlank(url)) {
            return null;
        }
        Map<String, String> headerMap = new HashMap<>();
        headerMap.put("User-agent",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36");

        String response = null;
        for (int i = 0; i < MAX_RETRY_COUNT; i++) {
            try {
                response =
                    HttpAsyncClientUtils.get(TaskType.CIBIL_DEFAULTS, url, headerMap, (int) DateUtils.MINUTE * 5);
            } catch (Exception e) {
                LOGGER.error("Caught Exception Fetching Data From Info Api in CibilDefaultsParserCallback", e);
            }
            if (response != null) {
                break;
            }
        }
        if (response == null) {
            LOGGER.error("Error while fetching data from api : Max Retry attempts reached");
            throw new RequestParsingException("Cannot fetch Data from detail api", TaskError.SERVER_DOWN);
        }
        DefaultsDto defaultsDto = null;
        try {
            defaultsDto = OBJECT_MAPPER.readValue(response, DefaultsDto.class);
        } catch (Exception e) {
            LOGGER.error("Caught exception while mapping response", e);
        }
        return defaultsDto;
    }

    private static void fetchQuarterIds() throws RequestParsingException {
        if ((System.currentTimeMillis() - quarterFetchTime) <= DateUtils.DAY * 30 && ObjectUtils.isNotBlankObject(
            QUARTER_STRING_TO_ID_MAP)) {
            return;
        }
        Document response = null;
        try {
            response = HttpAsyncClientUtils.getDocument(TaskType.CIBIL_DEFAULTS, GOOGLE_WEB_CACHE_URL);
        } catch (Exception e) {
            LOGGER.error("Caught exception while fetchingQuarterIds", e);
        }
        if (response == null) {
            throw new RequestParsingException("Cannot get cached web page from google web cache server URL",
                TaskError.SERVER_DOWN);
        }
        Elements options = response.getElementById("quarterIdCrore").getElementsByTag("option");
        for (int i = 1; i < options.size(); i++) {
            Element option = options.get(i);
            String text = option.text();
            String value = option.attr("value");
            QUARTER_STRING_TO_ID_MAP.put(text, value);
        }
        quarterFetchTime = System.currentTimeMillis();
    }

    private static List<String> getQuartersForSearch(Long fromTime) {
        if (fromTime == null) {
            return new ArrayList<>(QUARTER_STRING_TO_ID_MAP.values());
        }
        List<String> quarterIds = new ArrayList<>();
        for (Map.Entry<String, String> entry : QUARTER_STRING_TO_ID_MAP.entrySet()) {
            String dateString = entry.getKey();
            Long longDate = HtmlParserUtils.getTimeSilently(dateString, "dd-MM-yy");
            if (longDate != null && longDate >= fromTime) {
                quarterIds.add(entry.getValue());
            }
        }
        return quarterIds;
    }

    public static void main(String[] args) throws Throwable {
        long now = System.currentTimeMillis();
        CibilDefaultsTaskParamsDto cibilDefaultsTaskParamsDto =
            CibilDefaultsTaskParamsDto.Builder.cibilDefaultsTaskParamsDto()
                .withRequestId(String.valueOf(UUID.randomUUID()))
                .withCompanyName("Reliance")
                .withCin(null)
                .withGstIn(null)
                .withFromTime(1650000000000L)
                .build();
        CibilDefaultsDetailDto getData = parseCibilDefaults(cibilDefaultsTaskParamsDto);
        System.out.println("Time taken to fetch data for one org = " + (System.currentTimeMillis() - now) / 1000);
        System.out.println(getData);
    }
}


package com.ofb.crawler.commons.types.mca.dto;

public class McaCompanyMasterDataDto {

    private CompanyDataDto companyData;

    private List<CompanyDirectorDataDto> directorDataList;

    private List<CompanyChargesDataDto> chargesDataList;

    public McaCompanyMasterDataDto() {
    }

    public McaCompanyMasterDataDto(CompanyDataDto companyData,
        List<CompanyDirectorDataDto> directorDataList,
        List<CompanyChargesDataDto> chargesDataList) {
        this.companyData = companyData;
        this.directorDataList = directorDataList;
        this.chargesDataList = chargesDataList;
    }

    public CompanyDataDto getCompanyData() {
        return companyData;
    }

    public void setCompanyData(CompanyDataDto companyData) {
        this.companyData = companyData;
    }

    public List<CompanyDirectorDataDto> getDirectorDataList() {
        return directorDataList;
    }

    public void setDirectorDataList(
        List<CompanyDirectorDataDto> directorDataList) {
        this.directorDataList = directorDataList;
    }

    public List<CompanyChargesDataDto> getChargesDataList() {
        return chargesDataList;
    }

    public void setChargesDataList(List<CompanyChargesDataDto> chargesDataList) {
        this.chargesDataList = chargesDataList;
    }

    public static interface CompanyDataStep {
        DirectorDataListStep withCompanyData(CompanyDataDto companyData);
    }

    public static interface DirectorDataListStep {
        ChargesDataListStep withDirectorDataList(List<CompanyDirectorDataDto> directorDataList);
    }

    public static interface ChargesDataListStep {
        BuildStep withChargesDataList(List<CompanyChargesDataDto> chargesDataList);
    }

    public static interface BuildStep {
        McaCompanyMasterDataDto build();
    }

    public static class Builder implements CompanyDataStep, DirectorDataListStep, ChargesDataListStep, BuildStep {
        private CompanyDataDto companyData;
        private List<CompanyDirectorDataDto> directorDataList;
        private List<CompanyChargesDataDto> chargesDataList;

        private Builder() {
        }

        public static CompanyDataStep mcaCompanyMasterDataDto() {
            return new Builder();
        }

        @Override
        public DirectorDataListStep withCompanyData(CompanyDataDto companyData) {
            this.companyData = companyData;
            return this;
        }

        @Override
        public ChargesDataListStep withDirectorDataList(List<CompanyDirectorDataDto> directorDataList) {
            this.directorDataList = directorDataList;
            return this;
        }

        @Override
        public BuildStep withChargesDataList(List<CompanyChargesDataDto> chargesDataList) {
            this.chargesDataList = chargesDataList;
            return this;
        }

        @Override
        public McaCompanyMasterDataDto build() {
            return new McaCompanyMasterDataDto(
                this.companyData,
                this.directorDataList,
                this.chargesDataList
            );
        }
    }
}


package com.ofb.crawler.commons.types.mca.dto;

public class CompanyDirectorDataCrawlDto {

    @JsonProperty("DIN")
    private String din;

    @JsonProperty("PAN")
    private String pan;

    @JsonProperty("dateOfAppointment")
    private String dateOfAppointment;

    @JsonProperty("DirectorDisqualified")
    private String directorDisqualified;

    @JsonProperty("FirstName")
    private String firstName;

    @JsonProperty("MiddleName")
    private String lastName;

    @JsonProperty("LastName")
    private String middleName;

    @JsonProperty("MCAUserRole")
    private List<DirectorMcaUserRoleDto> directorCompanies;

    public CompanyDirectorDataCrawlDto() {
    }

    public CompanyDirectorDataCrawlDto(String din, String pan, String dateOfAppointment,
        String directorDisqualified, String firstName, String lastName, String middleName,
        List<DirectorMcaUserRoleDto> directorCompanies) {
        this.din = din;
        this.pan = pan;
        this.dateOfAppointment = dateOfAppointment;
        this.directorDisqualified = directorDisqualified;
        this.firstName = firstName;
        this.lastName = lastName;
        this.middleName = middleName;
        this.directorCompanies = directorCompanies;
    }

    public String getDin() {
        return din;
    }

    public void setDin(String din) {
        this.din = din;
    }

    public String getPan() {
        return pan;
    }

    public void setPan(String pan) {
        this.pan = pan;
    }

    public String getDateOfAppointment() {
        return dateOfAppointment;
    }

    public void setDateOfAppointment(String dateOfAppointment) {
        this.dateOfAppointment = dateOfAppointment;
    }

    public String getDirectorDisqualified() {
        return directorDisqualified;
    }

    public void setDirectorDisqualified(String directorDisqualified) {
        this.directorDisqualified = directorDisqualified;
    }

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getMiddleName() {
        return middleName;
    }

    public void setMiddleName(String middleName) {
        this.middleName = middleName;
    }

    public List<DirectorMcaUserRoleDto> getDirectorCompanies() {
        return directorCompanies;
    }

    public void setDirectorCompanies(
        List<DirectorMcaUserRoleDto> directorCompanies) {
        this.directorCompanies = directorCompanies;
    }

    public static interface DinStep {
        PanStep withDin(String din);
    }

    public static interface PanStep {
        DateOfAppointmentStep withPan(String pan);
    }

    public static interface DateOfAppointmentStep {
        DirectorDisqualifiedStep withDateOfAppointment(String dateOfAppointment);
    }

    public static interface DirectorDisqualifiedStep {
        FirstNameStep withDirectorDisqualified(String directorDisqualified);
    }

    public static interface FirstNameStep {
        LastNameStep withFirstName(String firstName);
    }

    public static interface LastNameStep {
        MiddleNameStep withLastName(String lastName);
    }

    public static interface MiddleNameStep {
        DirectorCompaniesStep withMiddleName(String middleName);
    }

    public static interface DirectorCompaniesStep {
        BuildStep withDirectorCompanies(List<DirectorMcaUserRoleDto> directorCompanies);
    }

    public static interface BuildStep {
        CompanyDirectorDataCrawlDto build();
    }

    public static class Builder
        implements DinStep, PanStep, DateOfAppointmentStep, DirectorDisqualifiedStep, FirstNameStep, LastNameStep,
        MiddleNameStep, DirectorCompaniesStep, BuildStep {
        private String din;
        private String pan;
        private String dateOfAppointment;
        private String directorDisqualified;
        private String firstName;
        private String lastName;
        private String middleName;
        private List<DirectorMcaUserRoleDto> directorCompanies;

        private Builder() {
        }

        public static DinStep companyDirectorDataCrawlDto() {
            return new Builder();
        }

        @Override
        public PanStep withDin(String din) {
            this.din = din;
            return this;
        }

        @Override
        public DateOfAppointmentStep withPan(String pan) {
            this.pan = pan;
            return this;
        }

        @Override
        public DirectorDisqualifiedStep withDateOfAppointment(String dateOfAppointment) {
            this.dateOfAppointment = dateOfAppointment;
            return this;
        }

        @Override
        public FirstNameStep withDirectorDisqualified(String directorDisqualified) {
            this.directorDisqualified = directorDisqualified;
            return this;
        }

        @Override
        public LastNameStep withFirstName(String firstName) {
            this.firstName = firstName;
            return this;
        }

        @Override
        public MiddleNameStep withLastName(String lastName) {
            this.lastName = lastName;
            return this;
        }

        @Override
        public DirectorCompaniesStep withMiddleName(String middleName) {
            this.middleName = middleName;
            return this;
        }

        @Override
        public BuildStep withDirectorCompanies(List<DirectorMcaUserRoleDto> directorCompanies) {
            this.directorCompanies = directorCompanies;
            return this;
        }

        @Override
        public CompanyDirectorDataCrawlDto build() {
            return new CompanyDirectorDataCrawlDto(
                this.din,
                this.pan,
                this.dateOfAppointment,
                this.directorDisqualified,
                this.firstName,
                this.lastName,
                this.middleName,
                this.directorCompanies
            );
        }
    }
}


package com.ofb.crawler.core.util;

public class HttpUtils {

    private static final Logger logger = LoggerFactory.getLogger(HttpUtils.class);

    public static Document getDocumentFromHttpResponse(HttpResponse httpResponse, String url) throws IOException {
        if (httpResponse == null) {
            return new Document(url);
        }

        HttpEntity entity = httpResponse.getEntity();
        if (entity == null) {
            return new Document(url);
        }

        
        InputStream inputStream = entity.getContent();
        Document document = null;
        try {
            
            document = Jsoup.parse(inputStream, "UTF-8", url);
        } catch (Exception e) {
            logger.info("Unable to get document from input stream for url, {}, {}", url, e);
        } finally {
            inputStream.close();
        }

        return document;
    }

    public static String getStringResponse(HttpResponse response) throws IOException {
        BufferedReader rd = null;
        try {
            rd = new BufferedReader(
                new InputStreamReader(response.getEntity().getContent()));
            StringBuffer result = new StringBuffer();
            String line = "";
            while ((line = rd.readLine()) != null) {
                result.append(line);
            }
            return result.toString();
        } catch (Exception e) {
            logger.info("Failed to getStringResponse, Reason : {}", e.getMessage(), e);
            return null;
        } finally {
            IOUtils.closeQuietly(rd);
        }
    }
}


package com.ofb.crawler.commons.types.litigation.itat.dto.response;

@Data
@NoArgsConstructor
public class ItatResponse {

    private String appealNumber;

    private Long filingDate;

    private String caseStatus;

    private String assessmentYear;

    private String bench;

    private String respondentName;

    private String appellantName;

    private String appealType;

    private String orderDownloadLink;

    private Long dateOfOrder;

    private String orderResult;

    private Long lastHearingDate;

    private Long nextHearingDate;

    private String matchedWith;

    private SystemAssignedStatus systemAssignedStatus;

    private PartyInvolvement partyInvolvement;

    private String detailUrl;

    public ItatResponse(String appealNumber, Long filingDate, String caseStatus, String assessmentYear, String bench, String respondentName, String appellantName, String appealType, String orderDownloadLink, Long dateOfOrder, String orderResult, Long lastHearingDate, Long nextHearingDate, String matchedWith, SystemAssignedStatus systemAssignedStatus, PartyInvolvement partyInvolvement, String detailUrl) {
        this.appealNumber = appealNumber;
        this.filingDate = filingDate;
        this.caseStatus = caseStatus;
        this.assessmentYear = assessmentYear;
        this.bench = bench;
        this.respondentName = respondentName;
        this.appellantName = appellantName;
        this.appealType = appealType;
        this.orderDownloadLink = orderDownloadLink;
        this.dateOfOrder = dateOfOrder;
        this.orderResult = orderResult;
        this.lastHearingDate = lastHearingDate;
        this.nextHearingDate = nextHearingDate;
        this.matchedWith = matchedWith;
        this.systemAssignedStatus = systemAssignedStatus;
        this.partyInvolvement = partyInvolvement;
        this.detailUrl = detailUrl;
    }

    public static interface AppealNumberStep {
        FilingDateStep withAppealNumber(String appealNumber);
    }

    public static interface FilingDateStep {
        CaseStatusStep withFilingDate(Long filingDate);
    }

    public static interface CaseStatusStep {
        AssessmentYearStep withCaseStatus(String caseStatus);
    }

    public static interface AssessmentYearStep {
        BenchStep withAssessmentYear(String assessmentYear);
    }

    public static interface BenchStep {
        RespondentNameStep withBench(String bench);
    }

    public static interface RespondentNameStep {
        AppellantNameStep withRespondentName(String respondentName);
    }

    public static interface AppellantNameStep {
        AppealTypeStep withAppellantName(String appellantName);
    }

    public static interface AppealTypeStep {
        OrderDownloadLinkStep withAppealType(String appealType);
    }

    public static interface OrderDownloadLinkStep {
        DateOfOrderStep withOrderDownloadLink(String orderDownloadLink);
    }

    public static interface DateOfOrderStep {
        OrderResultStep withDateOfOrder(Long dateOfOrder);
    }

    public static interface OrderResultStep {
        LastHearingDateStep withOrderResult(String orderResult);
    }

    public static interface LastHearingDateStep {
        NextHearingDateStep withLastHearingDate(Long lastHearingDate);
    }

    public static interface NextHearingDateStep {
        MatchedWithStep withNextHearingDate(Long nextHearingDate);
    }

    public static interface MatchedWithStep {
        SystemAssignedStatusStep withMatchedWith(String matchedWith);
    }

    public static interface SystemAssignedStatusStep {
        PartyInvolvementStep withSystemAssignedStatus(SystemAssignedStatus systemAssignedStatus);
    }

    public static interface PartyInvolvementStep {
        DetailUrlStep withPartyInvolvement(PartyInvolvement partyInvolvement);
    }

    public static interface DetailUrlStep {
        BuildStep withDetailUrl(String detailUrl);
    }

    public static interface BuildStep {
        ItatResponse build();
    }


    public static class Builder implements AppealNumberStep, FilingDateStep, CaseStatusStep, AssessmentYearStep, BenchStep, RespondentNameStep, AppellantNameStep, AppealTypeStep, OrderDownloadLinkStep, DateOfOrderStep, OrderResultStep, LastHearingDateStep, NextHearingDateStep, MatchedWithStep, SystemAssignedStatusStep, PartyInvolvementStep, DetailUrlStep, BuildStep {
        private String appealNumber;
        private Long filingDate;
        private String caseStatus;
        private String assessmentYear;
        private String bench;
        private String respondentName;
        private String appellantName;
        private String appealType;
        private String orderDownloadLink;
        private Long dateOfOrder;
        private String orderResult;
        private Long lastHearingDate;
        private Long nextHearingDate;
        private String matchedWith;
        private SystemAssignedStatus systemAssignedStatus;
        private PartyInvolvement partyInvolvement;
        private String detailUrl;

        private Builder() {
        }

        public static AppealNumberStep itatResponse() {
            return new Builder();
        }

        @Override
        public FilingDateStep withAppealNumber(String appealNumber) {
            this.appealNumber = appealNumber;
            return this;
        }

        @Override
        public CaseStatusStep withFilingDate(Long filingDate) {
            this.filingDate = filingDate;
            return this;
        }

        @Override
        public AssessmentYearStep withCaseStatus(String caseStatus) {
            this.caseStatus = caseStatus;
            return this;
        }

        @Override
        public BenchStep withAssessmentYear(String assessmentYear) {
            this.assessmentYear = assessmentYear;
            return this;
        }

        @Override
        public RespondentNameStep withBench(String bench) {
            this.bench = bench;
            return this;
        }

        @Override
        public AppellantNameStep withRespondentName(String respondentName) {
            this.respondentName = respondentName;
            return this;
        }

        @Override
        public AppealTypeStep withAppellantName(String appellantName) {
            this.appellantName = appellantName;
            return this;
        }

        @Override
        public OrderDownloadLinkStep withAppealType(String appealType) {
            this.appealType = appealType;
            return this;
        }

        @Override
        public DateOfOrderStep withOrderDownloadLink(String orderDownloadLink) {
            this.orderDownloadLink = orderDownloadLink;
            return this;
        }

        @Override
        public OrderResultStep withDateOfOrder(Long dateOfOrder) {
            this.dateOfOrder = dateOfOrder;
            return this;
        }

        @Override
        public LastHearingDateStep withOrderResult(String orderResult) {
            this.orderResult = orderResult;
            return this;
        }

        @Override
        public NextHearingDateStep withLastHearingDate(Long lastHearingDate) {
            this.lastHearingDate = lastHearingDate;
            return this;
        }

        @Override
        public MatchedWithStep withNextHearingDate(Long nextHearingDate) {
            this.nextHearingDate = nextHearingDate;
            return this;
        }

        @Override
        public SystemAssignedStatusStep withMatchedWith(String matchedWith) {
            this.matchedWith = matchedWith;
            return this;
        }

        @Override
        public PartyInvolvementStep withSystemAssignedStatus(SystemAssignedStatus systemAssignedStatus) {
            this.systemAssignedStatus = systemAssignedStatus;
            return this;
        }

        @Override
        public DetailUrlStep withPartyInvolvement(PartyInvolvement partyInvolvement) {
            this.partyInvolvement = partyInvolvement;
            return this;
        }

        @Override
        public BuildStep withDetailUrl(String detailUrl) {
            this.detailUrl = detailUrl;
            return this;
        }

        @Override
        public ItatResponse build() {
            return new ItatResponse(
                    this.appealNumber,
                    this.filingDate,
                    this.caseStatus,
                    this.assessmentYear,
                    this.bench,
                    this.respondentName,
                    this.appellantName,
                    this.appealType,
                    this.orderDownloadLink,
                    this.dateOfOrder,
                    this.orderResult,
                    this.lastHearingDate,
                    this.nextHearingDate,
                    this.matchedWith,
                    this.systemAssignedStatus,
                    this.partyInvolvement,
                    this.detailUrl
            );
        }
    }
}


package com.ofb.crawler.commons.types.mca.dto;


public class CompanyAddressDto {

    private String streetAddress;

    private String streetAddress2;

    private String streetAddress3;

    private String streetAddress4;

    private String addressType;

    private String locality;

    private String district;

    private String city;

    private String state;

    private String country;

    private Long postalCode;

    private String officeType;

    private String activeStatus;

    private Long establishmentDate;

    public CompanyAddressDto() {
    }

    public CompanyAddressDto(String streetAddress, String streetAddress2, String streetAddress3,
        String streetAddress4, String addressType, String locality, String district, String city, String state,
        String country, Long postalCode, String officeType, String activeStatus, Long establishmentDate) {
        this.streetAddress = streetAddress;
        this.streetAddress2 = streetAddress2;
        this.streetAddress3 = streetAddress3;
        this.streetAddress4 = streetAddress4;
        this.addressType = addressType;
        this.locality = locality;
        this.district = district;
        this.city = city;
        this.state = state;
        this.country = country;
        this.postalCode = postalCode;
        this.officeType = officeType;
        this.activeStatus = activeStatus;
        this.establishmentDate = establishmentDate;
    }

    public String getStreetAddress() {
        return streetAddress;
    }

    public void setStreetAddress(String streetAddress) {
        this.streetAddress = streetAddress;
    }

    public String getStreetAddress2() {
        return streetAddress2;
    }

    public void setStreetAddress2(String streetAddress2) {
        this.streetAddress2 = streetAddress2;
    }

    public String getStreetAddress3() {
        return streetAddress3;
    }

    public void setStreetAddress3(String streetAddress3) {
        this.streetAddress3 = streetAddress3;
    }

    public String getStreetAddress4() {
        return streetAddress4;
    }

    public void setStreetAddress4(String streetAddress4) {
        this.streetAddress4 = streetAddress4;
    }

    public String getAddressType() {
        return addressType;
    }

    public void setAddressType(String addressType) {
        this.addressType = addressType;
    }

    public String getLocality() {
        return locality;
    }

    public void setLocality(String locality) {
        this.locality = locality;
    }

    public String getDistrict() {
        return district;
    }

    public void setDistrict(String district) {
        this.district = district;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }

    public String getCountry() {
        return country;
    }

    public void setCountry(String country) {
        this.country = country;
    }

    public Long getPostalCode() {
        return postalCode;
    }

    public void setPostalCode(Long postalCode) {
        this.postalCode = postalCode;
    }

    public String getOfficeType() {
        return officeType;
    }

    public void setOfficeType(String officeType) {
        this.officeType = officeType;
    }

    public String getActiveStatus() {
        return activeStatus;
    }

    public void setActiveStatus(String activeStatus) {
        this.activeStatus = activeStatus;
    }

    public Long getEstablishmentDate() {
        return establishmentDate;
    }

    public void setEstablishmentDate(Long establishmentDate) {
        this.establishmentDate = establishmentDate;
    }

    public static interface StreetAddressStep {
        StreetAddress2Step withStreetAddress(String streetAddress);
    }

    public static interface StreetAddress2Step {
        StreetAddress3Step withStreetAddress2(String streetAddress2);
    }

    public static interface StreetAddress3Step {
        StreetAddress4Step withStreetAddress3(String streetAddress3);
    }

    public static interface StreetAddress4Step {
        AddressTypeStep withStreetAddress4(String streetAddress4);
    }

    public static interface AddressTypeStep {
        LocalityStep withAddressType(String addressType);
    }

    public static interface LocalityStep {
        DistrictStep withLocality(String locality);
    }

    public static interface DistrictStep {
        CityStep withDistrict(String district);
    }

    public static interface CityStep {
        StateStep withCity(String city);
    }

    public static interface StateStep {
        CountryStep withState(String state);
    }

    public static interface CountryStep {
        PostalCodeStep withCountry(String country);
    }

    public static interface PostalCodeStep {
        OfficeTypeStep withPostalCode(Long postalCode);
    }

    public static interface OfficeTypeStep {
        ActiveStatusStep withOfficeType(String officeType);
    }

    public static interface ActiveStatusStep {
        EstablishmentDateStep withActiveStatus(String activeStatus);
    }

    public static interface EstablishmentDateStep {
        BuildStep withEstablishmentDate(Long establishmentDate);
    }

    public static interface BuildStep {
        CompanyAddressDto build();
    }

    public static class Builder
        implements StreetAddressStep, StreetAddress2Step, StreetAddress3Step, StreetAddress4Step, AddressTypeStep,
        LocalityStep, DistrictStep, CityStep, StateStep, CountryStep, PostalCodeStep, OfficeTypeStep, ActiveStatusStep,
        EstablishmentDateStep, BuildStep {
        private String streetAddress;
        private String streetAddress2;
        private String streetAddress3;
        private String streetAddress4;
        private String addressType;
        private String locality;
        private String district;
        private String city;
        private String state;
        private String country;
        private Long postalCode;
        private String officeType;
        private String activeStatus;
        private Long establishmentDate;

        private Builder() {
        }

        public static StreetAddressStep companyAddressDto() {
            return new Builder();
        }

        @Override
        public StreetAddress2Step withStreetAddress(String streetAddress) {
            this.streetAddress = streetAddress;
            return this;
        }

        @Override
        public StreetAddress3Step withStreetAddress2(String streetAddress2) {
            this.streetAddress2 = streetAddress2;
            return this;
        }

        @Override
        public StreetAddress4Step withStreetAddress3(String streetAddress3) {
            this.streetAddress3 = streetAddress3;
            return this;
        }

        @Override
        public AddressTypeStep withStreetAddress4(String streetAddress4) {
            this.streetAddress4 = streetAddress4;
            return this;
        }

        @Override
        public LocalityStep withAddressType(String addressType) {
            this.addressType = addressType;
            return this;
        }

        @Override
        public DistrictStep withLocality(String locality) {
            this.locality = locality;
            return this;
        }

        @Override
        public CityStep withDistrict(String district) {
            this.district = district;
            return this;
        }

        @Override
        public StateStep withCity(String city) {
            this.city = city;
            return this;
        }

        @Override
        public CountryStep withState(String state) {
            this.state = state;
            return this;
        }

        @Override
        public PostalCodeStep withCountry(String country) {
            this.country = country;
            return this;
        }

        @Override
        public OfficeTypeStep withPostalCode(Long postalCode) {
            this.postalCode = postalCode;
            return this;
        }

        @Override
        public ActiveStatusStep withOfficeType(String officeType) {
            this.officeType = officeType;
            return this;
        }

        @Override
        public EstablishmentDateStep withActiveStatus(String activeStatus) {
            this.activeStatus = activeStatus;
            return this;
        }

        @Override
        public BuildStep withEstablishmentDate(Long establishmentDate) {
            this.establishmentDate = establishmentDate;
            return this;
        }

        @Override
        public CompanyAddressDto build() {
            return new CompanyAddressDto(
                this.streetAddress,
                this.streetAddress2,
                this.streetAddress3,
                this.streetAddress4,
                this.addressType,
                this.locality,
                this.district,
                this.city,
                this.state,
                this.country,
                this.postalCode,
                this.officeType,
                this.activeStatus,
                this.establishmentDate
            );
        }
    }
}


package com.ofb.crawler.commons.types.litigation.itat.dto.task;

@Data
@NoArgsConstructor
public class ItatTaskDto extends BaseTaskDto {

    private String assesseeName;

    public ItatTaskDto(String assesseeName) {
        this.assesseeName = assesseeName;
    }

    public ItatTaskDto(String requestId, long requestTime, String requestedBy, RequestSource source, TaskType taskType, TaskPriority priority, long maxStaleTime, TaskStatus status, TaskError error, String callBackUrl, boolean isCallbackSuccess, String responseParsingId, String assesseeName) {
        super(requestId, requestTime, requestedBy, source, taskType, priority, maxStaleTime, status, error, callBackUrl, isCallbackSuccess, responseParsingId);
        this.assesseeName = assesseeName;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ItatTaskDto that = (ItatTaskDto) o;
        return Objects.equals(assesseeName, that.assesseeName);
    }

    @Override
    public int hashCode() {
        return Objects.hash(assesseeName);
    }

    public static interface RequestIdStep {
        RequestTimeStep withRequestId(String requestId);
    }

    public static interface RequestTimeStep {
        RequestedByStep withRequestTime(long requestTime);
    }

    public static interface RequestedByStep {
        SourceStep withRequestedBy(String requestedBy);
    }

    public static interface SourceStep {
        TaskTypeStep withSource(RequestSource source);
    }

    public static interface TaskTypeStep {
        PriorityStep withTaskType(TaskType taskType);
    }

    public static interface PriorityStep {
        MaxStaleTimeStep withPriority(TaskPriority priority);
    }

    public static interface MaxStaleTimeStep {
        StatusStep withMaxStaleTime(long maxStaleTime);
    }

    public static interface StatusStep {
        ErrorStep withStatus(TaskStatus status);
    }

    public static interface ErrorStep {
        CallBackUrlStep withError(TaskError error);
    }

    public static interface CallBackUrlStep {
        IsCallbackSuccessStep withCallBackUrl(String callBackUrl);
    }

    public static interface IsCallbackSuccessStep {
        ResponseParsingIdStep withIsCallbackSuccess(boolean isCallbackSuccess);
    }

    public static interface ResponseParsingIdStep {
        AssesseeNameStep withResponseParsingId(String responseParsingId);
    }

    public static interface AssesseeNameStep {
        BuildStep withAssesseeName(String assesseeName);
    }

    public static interface BuildStep {
        ItatTaskDto build();
    }


    public static class Builder implements RequestIdStep, RequestTimeStep, RequestedByStep, SourceStep, TaskTypeStep, PriorityStep, MaxStaleTimeStep, StatusStep, ErrorStep, CallBackUrlStep, IsCallbackSuccessStep, ResponseParsingIdStep, AssesseeNameStep, BuildStep {
        private String requestId;
        private long requestTime;
        private String requestedBy;
        private RequestSource source;
        private TaskType taskType;
        private TaskPriority priority;
        private long maxStaleTime;
        private TaskStatus status;
        private TaskError error;
        private String callBackUrl;
        private boolean isCallbackSuccess;
        private String responseParsingId;
        private String assesseeName;

        private Builder() {
        }

        public static RequestIdStep itatTaskDto() {
            return new Builder();
        }

        @Override
        public RequestTimeStep withRequestId(String requestId) {
            this.requestId = requestId;
            return this;
        }

        @Override
        public RequestedByStep withRequestTime(long requestTime) {
            this.requestTime = requestTime;
            return this;
        }

        @Override
        public SourceStep withRequestedBy(String requestedBy) {
            this.requestedBy = requestedBy;
            return this;
        }

        @Override
        public TaskTypeStep withSource(RequestSource source) {
            this.source = source;
            return this;
        }

        @Override
        public PriorityStep withTaskType(TaskType taskType) {
            this.taskType = taskType;
            return this;
        }

        @Override
        public MaxStaleTimeStep withPriority(TaskPriority priority) {
            this.priority = priority;
            return this;
        }

        @Override
        public StatusStep withMaxStaleTime(long maxStaleTime) {
            this.maxStaleTime = maxStaleTime;
            return this;
        }

        @Override
        public ErrorStep withStatus(TaskStatus status) {
            this.status = status;
            return this;
        }

        @Override
        public CallBackUrlStep withError(TaskError error) {
            this.error = error;
            return this;
        }

        @Override
        public IsCallbackSuccessStep withCallBackUrl(String callBackUrl) {
            this.callBackUrl = callBackUrl;
            return this;
        }

        @Override
        public ResponseParsingIdStep withIsCallbackSuccess(boolean isCallbackSuccess) {
            this.isCallbackSuccess = isCallbackSuccess;
            return this;
        }

        @Override
        public AssesseeNameStep withResponseParsingId(String responseParsingId) {
            this.responseParsingId = responseParsingId;
            return this;
        }

        @Override
        public BuildStep withAssesseeName(String assesseeName) {
            this.assesseeName = assesseeName;
            return this;
        }

        @Override
        public ItatTaskDto build() {
            return new ItatTaskDto(
                    this.requestId,
                    this.requestTime,
                    this.requestedBy,
                    this.source,
                    this.taskType,
                    this.priority,
                    this.maxStaleTime,
                    this.status,
                    this.error,
                    this.callBackUrl,
                    this.isCallbackSuccess,
                    this.responseParsingId,
                    this.assesseeName
            );
        }
    }
}


package com.ofb.crawler.core.types.findGst.service;

@Service
public class FindGstParserCallback extends BaseParserCallback<FindGstResponseDto, FindGstTaskParamsDto> {

    private static final Logger logger = LoggerFactory.getLogger(FindGstParserCallback.class);

    private final String findGstUrl = "https:

    @Override public FindGstResponseDto parse(FindGstTaskParamsDto parsingParams) throws Throwable {

        String companyName = parsingParams.getCompanyName();
        String pan = parsingParams.getPan();
        String rawHtml = null;

        List<GstInfoDto> gstDetail = new ArrayList<>();
        List<String> listGsts = new ArrayList<>();
        if(!StringUtils.isEmpty(pan)){
            rawHtml = getDetailPageByCompanyPan(pan);
            if (rawHtml != null) {
                listGsts = parserByPan(rawHtml, pan);
            }
        }else{
            rawHtml = getDetailPageByCompanyName(companyName);
            if (rawHtml != null) {
                listGsts = parser(rawHtml, companyName);
            }
        }
        if (rawHtml != null) {
            listGsts = parser(rawHtml, companyName);
        }
        if (listGsts.size() != 0) {

            for (String val : listGsts) {
                GstInfoDto gstInfo = GstInfoDto
                    .Builder
                    .gstInfoDto()
                    .withGstIn(val)
                    .withGstStatus(null)
                    .withDateOfRegistration(null)
                    .withEnrichmentSubSource(null)
                    .build();

                gstDetail.add(gstInfo);
            }
            logger.info(JacksonUtils.writeValueAsString(gstDetail));
        }
        return FindGstResponseDto.Builder.findGstResponseDto()
            .withParsingId(String.valueOf(UUID.randomUUID()))
            .withTaskType(TaskType.FIND_GST)
            .withParsingTime(System.currentTimeMillis())
            .withBaseTaskParamsDto(null)
            .withGstInfoDtos(gstDetail)
            .withFindGstTaskParamsDto(parsingParams)
            .build();
    }

    private String getDetailPageByCompanyName(String companyName) {
        HttpResponse httpResponse = null;
        Pair session = getTokenFromHomePage();
        String searchQuery = cleanSearchQuery(companyName);
        String csrfToken = session.getFirst().toString();
        String rawHtml = null;
        Map<String, String> headers = new HashMap<>();
        String cookie = session.getSecond().toString();
        headers.put("cookie", String.format(cookie, csrfToken));
        headers.put("referer", "https:
        headers.put("origin", "https:
        headers.put("accept",
            "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,**;q=0.8,application/signed-exchange;v=b3;q=0.9");
        headers.put("content-type", "application/x-www-form-urlencoded");
        String payLoad = "gstnum=" + searchQuery.replaceAll(" ", "+") + "&csrfmiddlewaretoken=" + csrfToken;
        try {
            httpResponse = HttpAsyncClientUtils.postAndGetHttpResponse(TaskType.FIND_GST, findGstUrl,payLoad,headers);
            
            if (httpResponse.getStatusLine().getStatusCode() == 200) {
                rawHtml = EntityUtils.toString(httpResponse.getEntity());
            }
        } catch (Exception e) {
            logger.error("Exception while getting gst detail page url - {}", String.format(findGstUrl, pan), e);
        } finally {
            if (httpResponse != null) {
                EntityUtils.consumeQuietly(httpResponse.getEntity());
            }
        }
        return rawHtml;
    }

    private List<String> parser(String rawHtml, String searchQuery) {
        Document doc = Jsoup.parse(rawHtml);
        searchQuery = cleanSearchQuery(searchQuery);
        List<String> gstList = new ArrayList<>();
        Elements gstEntries = doc.select("body > div").get(1).select("div.row > div.col > p");
        for (Element entry : gstEntries) {
            if (entry.hasClass("yellow lighten-5")) {
                String gstLink = entry.select("a").attr("href");
                if (gstNameMatch(gstLink, searchQuery)) {
                    gstList.add(entry.ownText().split(" ")[0]);
                }
            }
        }
        return gstList;
    }

    private List<String> parserByPan(String rawHtml, String searchQuery) {
        Document doc = Jsoup.parse(rawHtml);
        searchQuery = cleanSearchQuery(searchQuery);
        List<String> gstList = new ArrayList<>();
        Elements gstEntries = doc.select("body > div").get(1).select("div.row > div.col > p");
        for (Element entry : gstEntries) {
            if (entry.hasClass("yellow lighten-5")) {
                String gstLink = entry.select("a").attr("href");
                if (gstPanMatch(gstLink, searchQuery)) {
                    gstList.add(entry.ownText().split(" ")[0]);
                }
            }
        }
        return gstList;
    }

    private Pair<String, String> getTokenFromHomePage() {
        Pair pair = new Pair();
        String csrfToken = null;
        HttpResponse httpResponse = null;
        try {
            httpResponse = HttpAsyncClientUtils.getHttpResponse(TaskType.FIND_GST, findGstUrl);
            if (httpResponse.getStatusLine().getStatusCode() == 200) {
                String html = EntityUtils.toString(httpResponse.getEntity());
                Document doc = Jsoup.parse(html);
                csrfToken = doc.select("body > div").get(1).select("div.row > div.col > div > div > form > "
                    + "input[type=hidden]:nth-child(3)").attr("value");
                pair.setFirst(csrfToken);
                Header[] headers = httpResponse.getHeaders("Set-Cookie");
                String cookie = headers[0].getValue().split(";")[0];
                pair.setSecond(cookie);
            }
        } catch (Exception e) {
            logger.error("Unable to fetch FindGst Home page :{}", String.format(findGstUrl, ""), e);
        } finally {
            if (httpResponse != null) {
                EntityUtils.consumeQuietly(httpResponse.getEntity());
            }
        }
        return pair;
    }

    public boolean gstNameMatch(String gstLink, String searchQuery) {
        HttpResponse httpResponse = null;
        gstLink = "https:
        try {
            httpResponse = HttpAsyncClientUtils.getHttpResponse(TaskType.FIND_GST, gstLink);
            if (httpResponse.getStatusLine().getStatusCode() == 200) {
                String res = EntityUtils.toString(httpResponse.getEntity());
                Document doc = Jsoup.parse(res);
                Element resultTable = doc.select("table").first();
                String companyName = resultTable.select("tbody > tr:nth-child(2) > td:nth-child(2)").first().ownText();
                if (cleanSearchQuery(companyName).equals(searchQuery)) {
                    return true;
                }
            }
        } catch (Exception e) {
            logger.error("Error while fetching gst detail page :{}", gstLink, e);
        } finally {
            if (httpResponse != null) {
                EntityUtils.consumeQuietly(httpResponse.getEntity());
            }
        }
        return false;
    }

    public boolean gstPanMatch(String gstLink, String searchQuery) {
        HttpResponse httpResponse = null;
        gstLink = "https:
        try {
            httpResponse = HttpAsyncClientUtils.getHttpResponse(TaskType.FIND_GST, gstLink);
            if (httpResponse.getStatusLine().getStatusCode() == 200) {
                String res = EntityUtils.toString(httpResponse.getEntity());
                Document doc = Jsoup.parse(res);
                Element resultTable = doc.select("table").first();
                String companyName = resultTable.select("tbody > tr:nth-child(2) > td:nth-child(2)").first().ownText();
                String gst = resultTable.select("tbody > tr:nth-child(1) > td:nth-child(2)").first().ownText();
                if (cleanSearchQuery(gst).equals(searchQuery)) {
                    return true;
                }
            }
        } catch (Exception e) {
            logger.error("Error while fetching gst detail page :{}", gstLink, e);
        } finally {
            if (httpResponse != null) {
                EntityUtils.consumeQuietly(httpResponse.getEntity());
            }
        }
        return false;
    }

    @Override public TaskType getTaskType() {
        return TaskType.FIND_GST;
    }
}


package com.ofb.crawler.core.util;

public class GoogleChatAlertUtil {

    private static final Logger logger = LoggerFactory.getLogger(GoogleChatAlertUtil.class);

    private static GoogleChatAlertService googleChatAlertService = null;

    static {
        initiateGoogleChatAlertService();
    }

    private static void initiateGoogleChatAlertService() {
        PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();
        cm.setDefaultMaxPerRoute(5);
        cm.setMaxTotal(500);
        HttpClient client = HttpClients.createMinimal(cm);
        googleChatAlertService = new GoogleChatAlertService(client, new ObjectMapper());
    }

    public static GoogleChatAlertService getGoogleChatAlertService() {
        if (googleChatAlertService == null) {
            initiateGoogleChatAlertService();
        }
        return googleChatAlertService;
    }

    public static void sendProxyIPFailureAlert(TaskType taskType, String blockedIP, int remainingActiveIPCount) {
        String webhookUrl = "https:
            + "key=AIzaSyDdI0hCZtE6vySjMm-WEfRq3CPzqKqqsHI&token=ON2fmr3NAccOx13d7hk_NUSZPGcUkG4ktBrpTAEE_jM";

        Map<String, String> payload = new LinkedHashMap<>();
        payload.put("Task Type", taskType.name());
        payload.put("Blocked IP", blockedIP);
        payload.put("Remaining Active IP Count", String.valueOf(remainingActiveIPCount));

        String payloadStr = null;

        try {
            payloadStr = ObjectUtils.objectMapper().writerWithDefaultPrettyPrinter().writeValueAsString(payload);
        } catch (JsonProcessingException e) {
            logger.error("sendProxyIPFailureAlert: unable to convert payload to string {}", e);
            return;
        }

        getGoogleChatAlertService().sendSimpleAlertMessage(payloadStr, webhookUrl);
    }
}


package com.ofb.crawler.commons.types.gstReturn.dto.task;

@Data
@NoArgsConstructor
public class GstReturnTaskDto extends BaseTaskDto {

    private String gstIn;

    public GstReturnTaskDto(String gstIn) {
        this.gstIn = gstIn;
    }

    public GstReturnTaskDto(String requestId, long requestTime, String requestedBy, RequestSource source, TaskType taskType, TaskPriority priority, long maxStaleTime, TaskStatus status, TaskError error, String callBackUrl, boolean isCallbackSuccess, String responseParsingId, String gstIn) {
        super(requestId, requestTime, requestedBy, source, taskType, priority, maxStaleTime, status, error, callBackUrl, isCallbackSuccess, responseParsingId);
        this.gstIn = gstIn;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        GstReturnTaskDto that = (GstReturnTaskDto) o;
        return Objects.equals(gstIn, that.gstIn);
    }

    @Override
    public int hashCode() {
        return Objects.hash(gstIn);
    }

    public static interface RequestIdStep {
        RequestTimeStep withRequestId(String requestId);
    }

    public static interface RequestTimeStep {
        RequestedByStep withRequestTime(long requestTime);
    }

    public static interface RequestedByStep {
        SourceStep withRequestedBy(String requestedBy);
    }

    public static interface SourceStep {
        TaskTypeStep withSource(RequestSource source);
    }

    public static interface TaskTypeStep {
        PriorityStep withTaskType(TaskType taskType);
    }

    public static interface PriorityStep {
        MaxStaleTimeStep withPriority(TaskPriority priority);
    }

    public static interface MaxStaleTimeStep {
        StatusStep withMaxStaleTime(long maxStaleTime);
    }

    public static interface StatusStep {
        ErrorStep withStatus(TaskStatus status);
    }

    public static interface ErrorStep {
        CallBackUrlStep withError(TaskError error);
    }

    public static interface CallBackUrlStep {
        IsCallbackSuccessStep withCallBackUrl(String callBackUrl);
    }

    public static interface IsCallbackSuccessStep {
        ResponseParsingIdStep withIsCallbackSuccess(boolean isCallbackSuccess);
    }

    public static interface ResponseParsingIdStep {
        GstInStep withResponseParsingId(String responseParsingId);
    }

    public static interface GstInStep {
        BuildStep withGstIn(String gstIn);
    }

    public static interface BuildStep {
        GstReturnTaskDto build();
    }


    public static class Builder implements RequestIdStep, RequestTimeStep, RequestedByStep, SourceStep, TaskTypeStep, PriorityStep, MaxStaleTimeStep, StatusStep, ErrorStep, CallBackUrlStep, IsCallbackSuccessStep, ResponseParsingIdStep, GstInStep, BuildStep {
        private String requestId;
        private long requestTime;
        private String requestedBy;
        private RequestSource source;
        private TaskType taskType;
        private TaskPriority priority;
        private long maxStaleTime;
        private TaskStatus status;
        private TaskError error;
        private String callBackUrl;
        private boolean isCallbackSuccess;
        private String responseParsingId;
        private String gstIn;

        private Builder() {
        }

        public static RequestIdStep gstReturnTaskDto() {
            return new Builder();
        }

        @Override
        public RequestTimeStep withRequestId(String requestId) {
            this.requestId = requestId;
            return this;
        }

        @Override
        public RequestedByStep withRequestTime(long requestTime) {
            this.requestTime = requestTime;
            return this;
        }

        @Override
        public SourceStep withRequestedBy(String requestedBy) {
            this.requestedBy = requestedBy;
            return this;
        }

        @Override
        public TaskTypeStep withSource(RequestSource source) {
            this.source = source;
            return this;
        }

        @Override
        public PriorityStep withTaskType(TaskType taskType) {
            this.taskType = taskType;
            return this;
        }

        @Override
        public MaxStaleTimeStep withPriority(TaskPriority priority) {
            this.priority = priority;
            return this;
        }

        @Override
        public StatusStep withMaxStaleTime(long maxStaleTime) {
            this.maxStaleTime = maxStaleTime;
            return this;
        }

        @Override
        public ErrorStep withStatus(TaskStatus status) {
            this.status = status;
            return this;
        }

        @Override
        public CallBackUrlStep withError(TaskError error) {
            this.error = error;
            return this;
        }

        @Override
        public IsCallbackSuccessStep withCallBackUrl(String callBackUrl) {
            this.callBackUrl = callBackUrl;
            return this;
        }

        @Override
        public ResponseParsingIdStep withIsCallbackSuccess(boolean isCallbackSuccess) {
            this.isCallbackSuccess = isCallbackSuccess;
            return this;
        }

        @Override
        public GstInStep withResponseParsingId(String responseParsingId) {
            this.responseParsingId = responseParsingId;
            return this;
        }

        @Override
        public BuildStep withGstIn(String gstIn) {
            this.gstIn = gstIn;
            return this;
        }

        @Override
        public GstReturnTaskDto build() {
            return new GstReturnTaskDto(
                    this.requestId,
                    this.requestTime,
                    this.requestedBy,
                    this.source,
                    this.taskType,
                    this.priority,
                    this.maxStaleTime,
                    this.status,
                    this.error,
                    this.callBackUrl,
                    this.isCallbackSuccess,
                    this.responseParsingId,
                    this.gstIn
            );
        }
    }
}


package com.ofb.crawler.core.types.mca.service;

@Service
public class McaParserCallback extends BaseParserCallback<McaCompanyDetailDto, McaTaskParamsDto> {

    private static final Logger logger = LoggerFactory.getLogger(McaParserCallback.class);

    public final static String masterDataUrl = "https:

    public final static String masterDataReqBody = "ID={0}&requestID=cin";

    public final static String dinDataReqBody = "ID={0}&requestID=din";

    public final static String cinUrl =
        "https:

    public final static String cinRequestParams = "module=MDS&searchKeyWord={0}&searchType=autosuggest"
        + "&mdsSearchType=searchedName&mdsSearchType=company";

    private static final String INDIAN_COMPANY_DESIGNATION_REGEX =
        "^(Nominee Director|Managing Director|Additional Director|Whole-time director|Alternate Director|Director "
            + "appointed in casual vacancy|Director|CEO|CFO|Manager|Company Secretary)$";

    
    private static final String INDIAN_COMPANY_DESIGNATION_REGEX_2 =
        "^(Nominee Director|Managing Director|Additional Director|Whole Time Director|Wholetime Director|Alternate "
            + "Director|Director appointed in casual vacancy|Director|CEO|CFO|Manager|Company Secretary|Authorised "
            + "Representative|Whole-time director)$";

    private static final String LLP_DESIGNATION_REGEX = "^(Designated Partner|Nominee for Body corporate designated "
        + "partner)$";

    private static final String FOREIGN_COMPANY_DESIGNATION_REGEX = "^(Authorised Representative)$";

    private static final String password = "d6163f0659cfe4196dc03c2c29aab06f10cb0a79cdfc74a45da2d72358712e80";
    private static final String saltStr = "fc74a45dsalt";
    private static final String ivStr = "c29aab06iv";
    private static final int keySize = 128;
    private static final int iterations = 100;

    @Autowired
    private TokenGenerationService tokenGenerationService;

    @Override
    public McaCompanyDetailDto parse(McaTaskParamsDto parsingParams) throws Throwable {
        return parseMca(parsingParams);
    }

    public static McaCompanyDetailDto parseMca(McaTaskParamsDto parsingParams) throws Throwable {
        McaCompanyMasterDataCrawlDto mcaCompanyMasterDataCrawlDto = null;
        Map<String, String> headers = new HashMap<>();
        headers.put("authority", "www.mca.gov.in");
        headers.put("accept", "application/json, text/javascript, */*; q=0.01");
        headers.put("accept-language", "en-GB,en-US;q=0.9,en;q=0.8");
        headers.put("referer", "https:
        headers.put("user-agent",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36");
        headers.put("x-requested-with", "XMLHttpRequest");
        if (ObjectUtils.isNotBlank(parsingParams.getCin())) {
            mcaCompanyMasterDataCrawlDto = getMasterDataByCin(parsingParams.getCin(), headers);
        } else if (ObjectUtils.isNotBlank(parsingParams.getCompanyName())) {
            mcaCompanyMasterDataCrawlDto = getMasterDataByCompanyName(parsingParams.getCompanyName(), headers);
        }

        Map<String, DirectorDataCrawlDto> dinToDirectorData = new HashMap<>();
        if (mcaCompanyMasterDataCrawlDto != null && ObjectUtils.isNotBlankObject(
            mcaCompanyMasterDataCrawlDto.getDirectorDataList())) {
            Set<String> dins = mcaCompanyMasterDataCrawlDto.getDirectorDataList()
                .stream()
                .filter(a -> ObjectUtils.isNotBlank(a.getDin()))
                .map(CompanyDirectorDataCrawlDto::getDin)
                .collect(
                    Collectors.toSet());

            dinToDirectorData = getDirectorDataByDins(dins, headers);
        }

        return McaCompanyDetailDto.Builder.mcaCompanyDetailDto()
            .withParsingId(String.valueOf(UUID.randomUUID()))
            .withTaskType(TaskType.MCA)
            .withParsingTime(System.currentTimeMillis())
            .withBaseTaskParamsDto(parsingParams)
            .withCompanyDetailDto(convertToV1(mcaCompanyMasterDataCrawlDto, dinToDirectorData))
            .withCompanyDetailDtoV2(convertToV2(mcaCompanyMasterDataCrawlDto, dinToDirectorData))
            .build();
    }

    private static McaCompanyMasterDataCrawlDto getMasterDataByCompanyName(String companyName,
        Map<String, String> headers) throws RequestParsingException {
        String cin = getCin(companyName, headers);
        if (ObjectUtils.isBlank(cin)) {
            logger.error("cin not found for company: {}", companyName);
        }
        return getMasterDataByCin(cin, headers);
    }

    private static String getCin(String companyName, Map<String, String> headers) throws RequestParsingException {
        HttpResponse httpResponse = null;
        try {
            String url = cinUrl + encodeURIComponent(
                encrypt(MessageFormat.format(cinRequestParams, cleanSearchQuery(companyName).trim())));
            httpResponse = HttpAsyncClientUtils.getHttpResponse(TaskType.MCA, url, headers, 30 * 1000);
            if (httpResponse.getStatusLine().getStatusCode() == 200) {
                String jsonString = EntityUtils.toString(httpResponse.getEntity());
                JSONObject obj = new JSONObject(jsonString);
                if (obj.getString("message") != null && obj.getString("message").contains("Success")) {
                    JSONObject data = obj.getJSONObject("data");
                    JSONArray resultList = data.getJSONArray("result");
                    if (resultList.length() < 1) {
                        logger.info("CIN not found for company name: {}", companyName);
                        return null;
                    }

                    Map<String, String> companyToCinMap = new HashMap<>();
                    for (Object result : resultList) {
                        JSONObject resultObject = (JSONObject) result;
                        companyToCinMap.put(resultObject.getString("cmpnyNm"), resultObject.getString("cnNmbr"));
                    }

                    return getMatchedCompanyCin(companyToCinMap, companyName);
                } else {
                    return null;
                }
            } else {
                throw new RequestParsingException("Server call failure", TaskError.SERVER_DOWN);
            }
        } catch (Exception e) {
            logger.error("Error while fetching cin for company:{}", companyName, e);
            throw new RequestParsingException("Server call failure", TaskError.SERVER_DOWN);
        } finally {
            if (httpResponse != null) {
                EntityUtils.consumeQuietly(httpResponse.getEntity());
            }
        }
    }

    public static String getMatchedCompanyCin(Map<String, String> companyToCinMap, String searchKey) {
        if (ObjectUtils.isBlankObject(companyToCinMap)) {
            return null;
        }

        for (Map.Entry<String, String> entry : companyToCinMap.entrySet()) {
            if (ObjectUtils.isBlank(entry.getValue())) {
                continue;
            }
            String companyName = entry.getKey();
            if (searchKey.equalsIgnoreCase(companyName)) {
                return entry.getValue();
            }
        }

        for (Map.Entry<String, String> entry : companyToCinMap.entrySet()) {
            if (ObjectUtils.isBlank(entry.getValue())) {
                continue;
            }
            String companyName = entry.getKey();
            if (sanitizeName(searchKey).equals(sanitizeName(companyName))) {
                return entry.getValue();
            }
        }

        return null;
    }

    private static McaCompanyMasterDataCrawlDto getMasterDataByCin(String cin, Map<String, String> headers)
        throws RequestParsingException {
        if (ObjectUtils.isBlank(cin)) {
            return null;
        }

        HttpResponse httpResponse = null;
        try {
            Map<String, String> headersCopy = new HashMap<>(headers);
            headersCopy.put("content-type", "application/x-www-form-urlencoded; charset=UTF-8");
            String payLoad =
                "data=" + encodeURIComponent(encrypt(MessageFormat.format(masterDataReqBody, cin)));
            httpResponse = HttpAsyncClientUtils.postAndGetHttpResponse(TaskType.MCA,
                masterDataUrl, payLoad, headersCopy, 30 * 1000);
            if (httpResponse.getStatusLine().getStatusCode() == 200) {
                String jsonString = EntityUtils.toString(httpResponse.getEntity());
                JSONObject obj = new JSONObject(jsonString);
                if (obj.getString("message") != null && obj.getString("message").contains("Success")) {
                    JSONObject data = obj.getJSONObject("data");
                    McaCompanyMasterDataCrawlDto mcaCompanyMasterDataCrawlDto =
                        ObjectUtils.objectMapper().readValue(data.toString(), McaCompanyMasterDataCrawlDto.class);
                    if (mcaCompanyMasterDataCrawlDto == null) {
                        logger.error("master data not found for cin: {}", cin);
                    }
                    return mcaCompanyMasterDataCrawlDto;
                } else {
                    logger.error("master data not found for cin: {}", cin);
                    return null;
                }
            } else {
                throw new RequestParsingException("Server call failure", TaskError.SERVER_DOWN);
            }
        } catch (Exception e) {
            logger.error("Exception while fetching master data MCA {}", e);
            throw new RequestParsingException("Server call failure", TaskError.SERVER_DOWN);
        } finally {
            if (httpResponse != null) {
                EntityUtils.consumeQuietly(httpResponse.getEntity());
            }
        }
    }

    private static Map<String, DirectorDataCrawlDto> getDirectorDataByDins(Set<String> dins,
        Map<String, String> headers) throws RequestParsingException {
        if (ObjectUtils.isBlankObject(dins)) {
            return Collections.emptyMap();
        }

        Map<String, DirectorDataCrawlDto> response = new HashMap<>();
        for (String din : dins) {
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                logger.error("Thread sleep error in mcaParserCallback", e);
                throw new RequestParsingException("Thread Sleep Error", TaskError.PARSING_ERROR);
            }
            response.put(din, getDirectorDataByDin(din, headers));
        }

        if (ObjectUtils.isNotBlankObject(response.values())) {
            Set<String> companyCinWithoutStatus = response.values()
                .stream()
                .filter(a -> ObjectUtils.isNotBlankObject(a.getCessationCompanies()))
                .flatMap(a -> a.getCessationCompanies().stream().map(DirectorCessationCompanyDto::getCin))
                .collect(
                    Collectors.toSet());

            Map<String, String> companyCinWithStatus = new HashMap<>();
            for (DirectorDataCrawlDto directorDataCrawlDto : response.values()) {
                if (ObjectUtils.isBlankObject(directorDataCrawlDto.getAssociatedCompanies())) {
                    continue;
                }

                for (DirectorCompanyDto associatedCompany : directorDataCrawlDto.getAssociatedCompanies()) {
                    companyCinWithStatus.put(associatedCompany.getCin(), associatedCompany.getCompanyStatus());
                }
            }

            companyCinWithoutStatus = SetUtils.difference(companyCinWithoutStatus, companyCinWithStatus.keySet());

            if (ObjectUtils.isNotBlankObject(companyCinWithoutStatus)) {
                for (String cinWithoutStatus : companyCinWithoutStatus) {
                    McaCompanyMasterDataCrawlDto masterDataByCin = getMasterDataByCin(cinWithoutStatus, headers);
                    if (masterDataByCin == null
                        || masterDataByCin.getCompanyData() == null
                        || ObjectUtils.isBlank(masterDataByCin.getCompanyData().getLlpStatus())) {
                        throw new RequestParsingException("Unable to Fetch Cin Info", TaskError.SERVER_DOWN);
                    }
                    companyCinWithStatus.put(cinWithoutStatus, masterDataByCin.getCompanyData().getLlpStatus());
                }
            }

            for (DirectorDataCrawlDto directorDataCrawlDto : response.values()) {
                if (ObjectUtils.isBlankObject(directorDataCrawlDto.getCessationCompanies())) {
                    continue;
                }

                for (DirectorCessationCompanyDto cessationCompany : directorDataCrawlDto.getCessationCompanies()) {
                    cessationCompany.setCompanyStatus(companyCinWithStatus.get(cessationCompany.getCin()));
                }
            }

        }

        return response;
    }

    private static DirectorDataCrawlDto getDirectorDataByDin(String din, Map<String, String> headers)
        throws RequestParsingException {
        if (ObjectUtils.isBlank(din)) {
            return null;
        }

        HttpResponse httpResponse = null;
        try {
            Map<String, String> headersCopy = new HashMap<>(headers);
            headersCopy.put("content-type", "application/x-www-form-urlencoded; charset=UTF-8");
            String payLoad =
                "data=" + encodeURIComponent(encrypt(MessageFormat.format(dinDataReqBody, din)));
            httpResponse = HttpAsyncClientUtils.postAndGetHttpResponse(TaskType.MCA,
                masterDataUrl, payLoad, headersCopy, 30 * 1000);
            if (httpResponse.getStatusLine().getStatusCode() == 200) {
                String jsonString = EntityUtils.toString(httpResponse.getEntity());
                JSONObject obj = new JSONObject(jsonString);
                if (obj.getString("message") != null && obj.getString("message").contains("Success")) {
                    JSONObject data = obj.getJSONObject("data");
                    if (data != null) {
                        JSONArray directorData = data.getJSONArray("directorData");
                        if (directorData != null && directorData.length() >= 0) {
                            DirectorDataCrawlDto directorDataCrawlDto =
                                ObjectUtils.objectMapper().readValue(directorData.getJSONObject(0).toString(),
                                    DirectorDataCrawlDto.class);
                            if (directorDataCrawlDto == null) {
                                logger.error("director data not found for din: {}", din);
                            }
                            return directorDataCrawlDto;
                        }
                    }
                }
            } else {
                throw new RequestParsingException("Server call failure", TaskError.SERVER_DOWN);
            }
        } catch (Exception e) {
            logger.error("Exception while fetching master data MCA {}", e);
            throw new RequestParsingException("Server call failure", TaskError.SERVER_DOWN);
        } finally {
            if (httpResponse != null) {
                EntityUtils.consumeQuietly(httpResponse.getEntity());
            }
        }

        throw new RequestParsingException("Director data not found for din " + din, TaskError.NO_RESPONSE_FOUND);
    }

    private static McaCompanyMasterDataDto convertToV2(McaCompanyMasterDataCrawlDto mcaCompanyMasterDataCrawlDto,
        Map<String, DirectorDataCrawlDto> dinToDirectorData) {
        if (mcaCompanyMasterDataCrawlDto == null) {
            return null;
        }

        CompanyDataDto companyData = null;
        String companyCin = null;
        if (mcaCompanyMasterDataCrawlDto.getCompanyData() != null) {
            CompanyDataCrawlDto companyDataCrawlDto = mcaCompanyMasterDataCrawlDto.getCompanyData();

            List<CompanyAddressDto> companyAddressDtoList = new ArrayList<>();
            if (ObjectUtils.isNotBlankObject(companyDataCrawlDto.getCompanyAddress())) {
                for (CompanyAddressCrawlDto companyAddress : companyDataCrawlDto.getCompanyAddress()) {
                    companyAddressDtoList.add(CompanyAddressDto.Builder.companyAddressDto()
                        .withStreetAddress(companyAddress.getStreetAddress())
                        .withStreetAddress2(companyAddress.getStreetAddress2())
                        .withStreetAddress3(companyAddress.getStreetAddress3())
                        .withStreetAddress4(companyAddress.getStreetAddress4())
                        .withAddressType(companyAddress.getAddressType())
                        .withLocality(companyAddress.getLocality())
                        .withDistrict(companyAddress.getDistrict())
                        .withCity(companyAddress.getCity())
                        .withState(companyAddress.getState())
                        .withCountry(companyAddress.getCountry())
                        .withPostalCode(companyAddress.getPostalCode())
                        .withOfficeType(companyAddress.getOfficeType())
                        .withActiveStatus(companyAddress.getActiveStatus())
                        .withEstablishmentDate(HtmlParserUtils.getTimeSilently(
                            companyAddress.getEstablishmentDate(), "MM/dd/yyyy"))
                        .build());
                }
            }

            List<CompanyFilingEntryDto> balanceSheet3years = new ArrayList<>();
            if (ObjectUtils.isNotBlankObject(companyDataCrawlDto.getBalanceSheet3years())) {
                for (CompanyFilingEntryCrawlDto balanceSheet3year : companyDataCrawlDto.getBalanceSheet3years()) {
                    balanceSheet3years.add(CompanyFilingEntryDto.Builder.companyFilingEntryDto()
                        .withDateOfFiling(balanceSheet3year.getDateOfFiling())
                        .withFinancialYear(HtmlParserUtils.getTimeSilently(
                            balanceSheet3year.getFinancialYear(), "dd-MM-yyyy"))
                        .build());
                }
            }

            List<CompanyFilingEntryDto> annualReturns3years = new ArrayList<>();
            if (ObjectUtils.isNotBlankObject(companyDataCrawlDto.getAnnualReturns3years())) {
                for (CompanyFilingEntryCrawlDto annualReturns3year : companyDataCrawlDto.getAnnualReturns3years()) {
                    annualReturns3years.add(CompanyFilingEntryDto.Builder.companyFilingEntryDto()
                        .withDateOfFiling(annualReturns3year.getDateOfFiling())
                        .withFinancialYear(HtmlParserUtils.getTimeSilently(
                            annualReturns3year.getFinancialYear(), "dd-MM-yyyy"))
                        .build());
                }
            }

            companyCin = companyDataCrawlDto.getCin();
            companyData = CompanyDataDto.Builder.companyDataDto()
                .withCin(companyDataCrawlDto.getCin())
                .withCompanyName(companyDataCrawlDto.getCompanyName())
                .withCompanyType(companyDataCrawlDto.getCompanyType())
                .withCompanyOrigin(companyDataCrawlDto.getCompanyOrigin())
                .withRegistrationNumber(companyDataCrawlDto.getRegistrationNumber())
                .withDateOfIncorporation(HtmlParserUtils.getTimeSilently(
                    companyDataCrawlDto.getDateOfIncorporation(), "MM/dd/yyyy"))
                .withEmailAddress(companyDataCrawlDto.getEmailAddress())
                .withWhetherListedOrNot(companyDataCrawlDto.getWhetherListedOrNot())
                .withCompanyCategory(companyDataCrawlDto.getCompanyCategory())
                .withCompanySubcategory(companyDataCrawlDto.getCompanySubcategory())
                .withClassOfCompany(companyDataCrawlDto.getClassOfCompany())
                .withAuthorisedCapital(companyDataCrawlDto.getAuthorisedCapital())
                .withPaidUpCapital(companyDataCrawlDto.getPaidUpCapital())
                .withNumberOfMembers(companyDataCrawlDto.getNumberOfMembers())
                .withDateOfLastAGM(HtmlParserUtils.getTimeSilently(
                    companyDataCrawlDto.getDateOfLastAGM(), "MM/dd/yyyy"))
                .withStrikeOffAmalgamatedTransferredDate(HtmlParserUtils.getTimeSilently(
                    companyDataCrawlDto.getStrikeOffAmalgamatedTransferredDate(), "MM/dd/yyyy"))
                .withLlpStatus(companyDataCrawlDto.getLlpStatus())
                .withStatusUnderCIRP(companyDataCrawlDto.getStatusUnderCIRP())
                .withNumberOfPartners(companyDataCrawlDto.getNumberOfPartners())
                .withNumberOfDesignatedPartners(companyDataCrawlDto.getNumberOfDesignatedPartners())
                .withTotalObligationOfContribution(companyDataCrawlDto.getTotalObligationOfContribution())
                .withMainDivision(companyDataCrawlDto.getMainDivision())
                .withMainDivisionDescription(companyDataCrawlDto.getMainDivisionDescription())
                .withStatementDate(HtmlParserUtils.getTimeSilently(
                    companyDataCrawlDto.getStatementDate(), "MM/dd/yyyy"))
                .withBSDefaulter2Yrs(companyDataCrawlDto.getbSDefaulter2Yrs())
                .withBSDefaulter3Yrs(companyDataCrawlDto.getbSDefaulter3Yrs())
                .withARDefaulter2Yrs(companyDataCrawlDto.getaRDefaulter2Yrs())
                .withARDefaulter3Yrs(companyDataCrawlDto.getaRDefaulter3Yrs())
                .withSuspendedAtStockExchange(companyDataCrawlDto.getSuspendedAtStockExchange())
                .withCompanyAddress(companyAddressDtoList)
                .withBalanceSheet3years(balanceSheet3years)
                .withAnnualReturns3years(annualReturns3years)
                .withRocName(companyDataCrawlDto.getRocName())
                .withShareCapitalFlag(companyDataCrawlDto.getShareCapitalFlag())
                .withMaximumNumberOfMembers(companyDataCrawlDto.getMaximumNumberOfMembers())
                .withSubscribedCapital(companyDataCrawlDto.getSubscribedCapital())
                .withRdName(companyDataCrawlDto.getRdName())
                .withRdRegion(companyDataCrawlDto.getRdRegion())
                .withBalanceSheetDate(HtmlParserUtils.getTimeSilently(
                    companyDataCrawlDto.getBalanceSheetDate(), "MM/dd/yyyy"))
                .withInc22Aflag(companyDataCrawlDto.getInc22Aflag())
                .build();
        }

        List<CompanyDirectorDataDto> directorDataList = new ArrayList<>();
        String designationRegex = INDIAN_COMPANY_DESIGNATION_REGEX;
        if (companyData != null
            && "company".equalsIgnoreCase(companyData.getCompanyType())
            && "indian".equalsIgnoreCase(companyData.getCompanyOrigin())) {
            designationRegex = INDIAN_COMPANY_DESIGNATION_REGEX;
        } else if (companyData != null && "llp".equalsIgnoreCase(companyData.getCompanyType())) {
            designationRegex = LLP_DESIGNATION_REGEX;
        } else if (companyData != null
            && "company".equalsIgnoreCase(companyData.getCompanyType())
            && "foreign".equalsIgnoreCase(companyData.getCompanyOrigin())) {
            designationRegex = FOREIGN_COMPANY_DESIGNATION_REGEX;
        }
        Pattern pattern = Pattern.compile(designationRegex);
        Set<String> identifierProcessed = new HashSet<>();
        if (ObjectUtils.isNotBlankObject(mcaCompanyMasterDataCrawlDto.getDirectorDataList())) {
            for (CompanyDirectorDataCrawlDto companyDirectorDataCrawlDto : mcaCompanyMasterDataCrawlDto.getDirectorDataList()) {
                if (ObjectUtils.isBlank(companyDirectorDataCrawlDto.getDin())
                    && ObjectUtils.isBlank(companyDirectorDataCrawlDto.getPan())) {
                    logger.info("Skipping org director, DIN and PAN does not exist");
                    continue;
                }

                if (identifierProcessed.contains(companyDirectorDataCrawlDto.getDin())
                    || identifierProcessed.contains(companyDirectorDataCrawlDto.getPan())) {
                    continue;
                }


                String designation = null;
                
                if (ObjectUtils.isNotBlank(companyCin) && ObjectUtils.isNotBlankObject(
                    companyDirectorDataCrawlDto.getDirectorCompanies())) {
                    for (DirectorMcaUserRoleDto directorCompany : companyDirectorDataCrawlDto.getDirectorCompanies()) {
                        if (companyCin.equalsIgnoreCase(directorCompany.getCin())
                            && ObjectUtils.isNotBlank(directorCompany.getDesignation())
                            && "Signatory".equalsIgnoreCase(directorCompany.getPersonType())) {
                            Matcher matcher = pattern.matcher(directorCompany.getDesignation());
                            if (matcher.matches()) {
                                designation = directorCompany.getDesignation();
                                
                                
                                
                                break;
                            }
                        }
                    }
                }

                DirectorDataCrawlDto directorDataCrawlDto = dinToDirectorData.get(companyDirectorDataCrawlDto.getDin());
                
                if (ObjectUtils.isNotBlank(companyCin) && directorDataCrawlDto != null
                    && ObjectUtils.isNotBlankObject(directorDataCrawlDto.getCessationCompanies())) {
                    for (DirectorCessationCompanyDto cessationCompanyDto : directorDataCrawlDto.getCessationCompanies()) {
                        if (companyCin.equalsIgnoreCase(cessationCompanyDto.getCin())
                            && ObjectUtils.isNotBlank(cessationCompanyDto.getDesignation())) {
                            Matcher matcher2 = pattern.matcher(cessationCompanyDto.getDesignation());
                            if (matcher2.matches()) {
                                if (ObjectUtils.isBlank(designation)) {
                                    designation = cessationCompanyDto.getDesignation();
                                }
                                
                                
                                
                                
                                break;
                            }
                        }
                    }
                }

                if (ObjectUtils.isBlank(designation)) {
                    logger.info("Signatory does not satisfy the conditions provided by MCA website.");
                    continue;
                }

                directorDataList.add(CompanyDirectorDataDto.Builder.companyDirectorDataDto()
                    .withDin(companyDirectorDataCrawlDto.getDin())
                    .withPan(companyDirectorDataCrawlDto.getPan())
                    .withFirstName(companyDirectorDataCrawlDto.getFirstName())
                    .withLastName(companyDirectorDataCrawlDto.getLastName())
                    .withMiddleName(companyDirectorDataCrawlDto.getMiddleName())
                    .withDirectorCompanies(directorDataCrawlDto != null ?
                        getAllDirectorCompanies(directorDataCrawlDto.getAssociatedCompanies(),
                            directorDataCrawlDto.getCessationCompanies()) :
                        Collections.emptyList())
                    .build());

                if (ObjectUtils.isNotBlank(companyDirectorDataCrawlDto.getDin())) {
                    identifierProcessed.add(companyDirectorDataCrawlDto.getDin());
                }
                if (ObjectUtils.isNotBlank(companyDirectorDataCrawlDto.getPan())) {
                    identifierProcessed.add(companyDirectorDataCrawlDto.getPan());
                }
            }
        }

        List<CompanyChargesDataDto> chargesDataList = new ArrayList<>();
        if (ObjectUtils.isNotBlankObject(mcaCompanyMasterDataCrawlDto.getChargesDataList())) {
            for (CompanyChargesDataCrawlDto companyChargesDataCrawlDto : mcaCompanyMasterDataCrawlDto.getChargesDataList()) {
                chargesDataList.add(CompanyChargesDataDto.Builder.companyChargesDataDto()
                    .withChargeId(companyChargesDataCrawlDto.getChargeId())
                    .withSrn(companyChargesDataCrawlDto.getSrn())
                    .withChargeHolderName(getChargeHolderName(companyChargesDataCrawlDto))
                    .withDateOfCreation(HtmlParserUtils.getTimeSilently(
                        companyChargesDataCrawlDto.getDateOfCreation(), "MM/dd/yyyy"))
                    .withDateOfModification(HtmlParserUtils.getTimeSilently(
                        companyChargesDataCrawlDto.getDateOfModification(), "MM/dd/yyyy"))
                    .withDateOfSatisfaction(HtmlParserUtils.getTimeSilently(
                        companyChargesDataCrawlDto.getDateOfSatisfaction(), "MM/dd/yyyy"))
                    .withAmount(companyChargesDataCrawlDto.getAmount())
                    .withStreetAddress(companyChargesDataCrawlDto.getStreetAddress())
                    .withStreetAddress2(companyChargesDataCrawlDto.getStreetAddress2())
                    .withStreetAddress3(companyChargesDataCrawlDto.getStreetAddress3())
                    .withStreetAddress4(companyChargesDataCrawlDto.getStreetAddress4())
                    .withCountry(companyChargesDataCrawlDto.getCountry())
                    .withLocality(companyChargesDataCrawlDto.getLocality())
                    .withState(companyChargesDataCrawlDto.getState())
                    .withDistrict(companyChargesDataCrawlDto.getDistrict())
                    .withCity(companyChargesDataCrawlDto.getCity())
                    .withPostalCode(companyChargesDataCrawlDto.getPostalCode())
                    .withRegisteredName(companyChargesDataCrawlDto.getRegisteredName())
                    .withPropertyIntUnRegdFlag(companyChargesDataCrawlDto.getPropertyIntUnRegdFlag())
                    .withChargeName(companyChargesDataCrawlDto.getChargeName())
                    .withChargeStatus(companyChargesDataCrawlDto.getChargeStatus())
                    .build());
            }
        }

        return McaCompanyMasterDataDto.Builder.mcaCompanyMasterDataDto()
            .withCompanyData(companyData)
            .withDirectorDataList(directorDataList)
            .withChargesDataList(chargesDataList)
            .build();
    }

    private static CompanyDetailDto convertToV1(McaCompanyMasterDataCrawlDto mcaCompanyMasterDataCrawlDto,
        Map<String, DirectorDataCrawlDto> dinToDirectorData) {
        if (mcaCompanyMasterDataCrawlDto == null) {
            return null;
        }

        CompanyDataCrawlDto companyData = mcaCompanyMasterDataCrawlDto.getCompanyData();

        BasicDetail basicDetail = null;
        FinancialDetail financialDetail = null;
        ContactDetail contactDetail = null;
        ComplianceDetail complianceDetail = null;
        String companyCin = null;
        if (companyData != null) {
            companyCin = companyData.getCin();

            basicDetail = BasicDetail.Builder.basicDetail()
                .withCin(companyData.getCin())
                .withLlp(null)
                .withName(companyData.getCompanyName())
                .withCompanyStatus(companyData.getLlpStatus())
                .withRoc(companyData.getRocName())
                .withRegistrationNo(companyData.getRegistrationNumber())
                .withCompanyCategory(companyData.getCompanyCategory())
                .withCompanySubCategory(companyData.getCompanySubcategory())
                .withClassOfCompany(companyData.getClassOfCompany())
                .withDateOfIncorporation(HtmlParserUtils.getTimeSilently(
                    companyData.getDateOfIncorporation(), "MM/dd/yyyy"))
                .withAgeOfCompanyInDays(null)
                .withActivity(null)
                .withNumberOfMembers(companyData.getNumberOfMembers() != null
                    ? companyData.getNumberOfMembers().toString() : null)
                .build();

            financialDetail = FinancialDetail.Builder.financialDetail()
                .withAuthorisedCapital(companyData.getAuthorisedCapital() != null ?
                    companyData.getAuthorisedCapital().longValue() : null)
                .withPaidUpCapital(companyData.getPaidUpCapital() != null ?
                    companyData.getPaidUpCapital().longValue() : null)
                .withNumberOfEmployees(companyData.getNumberOfMembers() != null
                    ? companyData.getNumberOfMembers().toString() : null)
                .build();

            String address = null;
            if (ObjectUtils.isNotBlankObject(companyData.getCompanyAddress())) {
                for (CompanyAddressCrawlDto companyAddress : companyData.getCompanyAddress()) {
                    if ("Registered Address".equalsIgnoreCase(companyAddress.getAddressType())
                        && "Y".equalsIgnoreCase(companyAddress.getActiveStatus())) {
                        address =
                            companyAddress.getStreetAddress()
                                + (ObjectUtils.isBlank(companyAddress.getStreetAddress2()) ? ""
                                : ", " + companyAddress.getStreetAddress2())
                                + (ObjectUtils.isBlank(companyAddress.getStreetAddress3()) ? ""
                                : ", " + companyAddress.getStreetAddress3())
                                + (ObjectUtils.isBlank(companyAddress.getStreetAddress4()) ? ""
                                : ", " + companyAddress.getStreetAddress4())
                                + (ObjectUtils.isBlank(companyAddress.getDistrict()) ? ""
                                : ", " + companyAddress.getDistrict())
                                + (ObjectUtils.isBlank(companyAddress.getCity()) ? "" : ", " + companyAddress.getCity())
                                + (ObjectUtils.isBlank(companyAddress.getState()) ? ""
                                : ", " + companyAddress.getState())
                                + (ObjectUtils.isBlank(companyAddress.getCountry()) ? ""
                                : ", " + companyAddress.getCountry())
                                + (companyAddress.getPostalCode() == null ? "" : ", " + companyAddress.getPostalCode());
                    }
                }
            }

            contactDetail = ContactDetail.Builder.contactDetail()
                .withEmailId(companyData.getEmailAddress())
                .withMobile(null)
                .withAddress(address)
                .withWebsite(null)
                .build();

            complianceDetail = ComplianceDetail.Builder.complianceDetail()
                .withListingStatus("Y".equalsIgnoreCase(companyData.getWhetherListedOrNot()) ? "Listed" : "Unlisted")
                .withDateOfLastAnnualGeneralMeeting(HtmlParserUtils.getTimeSilently(
                    companyData.getDateOfLastAGM(), "MM/dd/yyyy"))
                .withDateOfLastBalanceSheet(HtmlParserUtils.getTimeSilently(
                    companyData.getDateOfLastAGM(), "MM/dd/yyyy"))
                .build();
        }

        List<DirectorDetail> directorDetails = new ArrayList<>();
        String designationRegex = INDIAN_COMPANY_DESIGNATION_REGEX;
        if (companyData != null
            && "company".equalsIgnoreCase(companyData.getCompanyType())
            && "indian".equalsIgnoreCase(companyData.getCompanyOrigin())) {
            designationRegex = INDIAN_COMPANY_DESIGNATION_REGEX;
        } else if (companyData != null && "llp".equalsIgnoreCase(companyData.getCompanyType())) {
            designationRegex = LLP_DESIGNATION_REGEX;
        } else if (companyData != null
            && "company".equalsIgnoreCase(companyData.getCompanyType())
            && "foreign".equalsIgnoreCase(companyData.getCompanyOrigin())) {
            designationRegex = FOREIGN_COMPANY_DESIGNATION_REGEX;
        }
        Pattern pattern = Pattern.compile(designationRegex);
        if (ObjectUtils.isNotBlankObject(mcaCompanyMasterDataCrawlDto.getDirectorDataList())) {
            for (CompanyDirectorDataCrawlDto directorDataCrawlDto : mcaCompanyMasterDataCrawlDto.getDirectorDataList()) {
                if (ObjectUtils.isBlank(directorDataCrawlDto.getDin())
                    && ObjectUtils.isBlank(directorDataCrawlDto.getPan())) {
                    logger.info("Skipping org director, DIN and PAN does not exist");
                    continue;
                }

                String designation = null;
                Long appointmentDate = null;
                if (ObjectUtils.isNotBlank(companyCin) && ObjectUtils.isNotBlankObject(
                    directorDataCrawlDto.getDirectorCompanies())) {
                    for (DirectorMcaUserRoleDto directorCompany : directorDataCrawlDto.getDirectorCompanies()) {
                        if (companyCin.equalsIgnoreCase(directorCompany.getCin())
                            && ObjectUtils.isNotBlank(directorCompany.getDesignation())
                            && "Signatory".equalsIgnoreCase(directorCompany.getPersonType())) {
                            Matcher matcher = pattern.matcher(directorCompany.getDesignation());
                            if (matcher.matches()) {
                                designation = directorCompany.getDesignation();
                                appointmentDate = directorCompany.getRoleEffectiveDate() != null ?
                                    directorCompany.getRoleEffectiveDate()
                                    : directorCompany.getCurrentDesignationDate();
                                break;
                            }
                        }
                    }
                }

                DirectorDataCrawlDto directorMasterDataCrawlDto = dinToDirectorData.get(directorDataCrawlDto.getDin());
                Long cessationDate = null;
                if (ObjectUtils.isNotBlank(companyCin) && directorMasterDataCrawlDto != null
                    && ObjectUtils.isNotBlankObject(directorMasterDataCrawlDto.getCessationCompanies())) {
                    for (DirectorCessationCompanyDto cessationCompanyDto : directorMasterDataCrawlDto.getCessationCompanies()) {
                        if (companyCin.equalsIgnoreCase(cessationCompanyDto.getCin())
                            && ObjectUtils.isNotBlank(cessationCompanyDto.getDesignation())) {
                            Matcher matcher2 = pattern.matcher(cessationCompanyDto.getDesignation());
                            if (matcher2.matches()) {
                                if (ObjectUtils.isBlank(designation)) {
                                    designation = cessationCompanyDto.getDesignation();
                                }
                                cessationDate = cessationCompanyDto.getCessationDate();
                                if (appointmentDate == null) {
                                    appointmentDate = cessationCompanyDto.getAppointmentDate();
                                }
                                break;
                            }
                        }
                    }
                }

                if (ObjectUtils.isBlank(designation)) {
                    logger.info("Signatory does not satisfy the conditions provided by MCA website.");
                    continue;
                }

                List<String> directorCompanies = new ArrayList<>();
                if (directorMasterDataCrawlDto != null) {
                    List<DirectorCompanyDto> allDirectorCompanies =
                        getAllDirectorCompanies(directorMasterDataCrawlDto.getAssociatedCompanies(),
                            directorMasterDataCrawlDto.getCessationCompanies());
                    for (DirectorCompanyDto dirComp : allDirectorCompanies) {
                        try {
                            directorCompanies.add(
                                ObjectUtils.objectMapper()
                                    .writeValueAsString(dirComp));
                        } catch (Exception e) {
                            logger.error("Unable to convert director companies object to string {}", e);
                        }
                    }
                }
                directorDetails.add(DirectorDetail.Builder.directorDetail()
                    .withDin(directorDataCrawlDto.getDin())
                    .withName(directorDataCrawlDto.getFirstName())
                    .withDesignation(designation)
                    .withAppointmentDate(appointmentDate)
                    .withExitDate(cessationDate)
                    .withDirectorCompanies(directorCompanies)
                    .build());
            }
        }

        List<ChargesDetail> chargesDetailList = new ArrayList<>();
        if (ObjectUtils.isNotBlankObject(mcaCompanyMasterDataCrawlDto.getChargesDataList())) {
            for (CompanyChargesDataCrawlDto chargesDataCrawlDto : mcaCompanyMasterDataCrawlDto.getChargesDataList()) {
                chargesDetailList.add(ChargesDetail.Builder.chargesDetail()
                    .withChargeId(chargesDataCrawlDto.getChargeId())
                    .withCreationDate(HtmlParserUtils.getTimeSilently(
                        chargesDataCrawlDto.getDateOfCreation(), "MM/dd/yyyy"))
                    .withModificationDate(HtmlParserUtils.getTimeSilently(
                        chargesDataCrawlDto.getDateOfModification(), "MM/dd/yyyy"))
                    .withClosureDate(HtmlParserUtils.getTimeSilently(
                        chargesDataCrawlDto.getDateOfSatisfaction(), "MM/dd/yyyy"))
                    .withAmount(chargesDataCrawlDto.getAmount().longValue())
                    .withAssetsUnderCharge(chargesDataCrawlDto.getChargeName())
                    .withChargeHolder(getChargeHolderName(chargesDataCrawlDto))
                    .withStatus(chargesDataCrawlDto.getChargeStatus())
                    .build());
            }
        }

        return CompanyDetailDto.Builder.companyDetailDto()
            .withDetailUrl(masterDataUrl)
            .withBasicDetail(basicDetail)
            .withFinancialDetail(financialDetail)
            .withDirectorDetails(directorDetails)
            .withContactDetail(contactDetail)
            .withComplianceDetail(complianceDetail)
            .withChargesDetail(chargesDetailList)
            .withEstablishmentDetail(null)
            .withSimilarCompanyDetail(Collections.emptyList())
            .build();
    }

    private static List<DirectorCompanyDto> getAllDirectorCompanies(List<DirectorCompanyDto> directorCompanyDtos,
        List<DirectorCessationCompanyDto> cessationCompanyDto) {
        List<DirectorCompanyDto> allCompanies = new ArrayList<>();
        List<DirectorCompanyDto> filteredCompanies = filterDirectorCompany(directorCompanyDtos);
        if (ObjectUtils.isNotBlankObject(filteredCompanies)) {
            allCompanies.addAll(filteredCompanies);
        }
        if (ObjectUtils.isNotBlankObject(cessationCompanyDto)) {
            allCompanies.addAll(
                cessationCompanyDto.stream().map(McaParserCallback::convertCessationToAssociatedCompany).collect(
                    Collectors.toList()));
        }

        return allCompanies;
    }

    private static List<DirectorCompanyDto> filterDirectorCompany(List<DirectorCompanyDto> directorCompanyDtos) {
        if (ObjectUtils.isBlankObject(directorCompanyDtos)) {
            return Collections.emptyList();
        }

        Pattern pattern = Pattern.compile(INDIAN_COMPANY_DESIGNATION_REGEX_2);

        return directorCompanyDtos.stream()
            .filter(
                a -> (ObjectUtils.isNotBlank(a.getDesignation()) && pattern.matcher(a.getDesignation()).matches())
                    || (ObjectUtils.isNotBlank(a.getCin()) && a.getCin().length() == 8))
            .collect(
                Collectors.toList());
    }

    private static DirectorCompanyDto convertCessationToAssociatedCompany(
        DirectorCessationCompanyDto cessationCompanyDto) {
        if (cessationCompanyDto == null) {
            return null;
        }

        String companyType = "Company";
        if (ObjectUtils.isNotBlank(cessationCompanyDto.getCin()) && cessationCompanyDto.getCin().length() == 8) {
            companyType = "LLP";
        }

        return DirectorCompanyDto.Builder.directorCompanyDto()
            .withCompanyId(null)
            .withCompanyName(cessationCompanyDto.getCompanyName())
            .withCompanyType(companyType)
            .withCin(cessationCompanyDto.getCin())
            .withDesignation(cessationCompanyDto.getDesignation())
            .withCessationDate(cessationCompanyDto.getCessationDate())
            .withCurrentDesignationDate(cessationCompanyDto.getAppointmentDate())
            .withRoleEffectiveDate(cessationCompanyDto.getCurrentDesignationDate())
            .withCompanyStatus(cessationCompanyDto.getCompanyStatus())
            .build();
    }

    private static String getChargeHolderName(CompanyChargesDataCrawlDto companyChargesDataCrawlDto) {

        String chargeHolderName = companyChargesDataCrawlDto.getChargeHolderName();
        if (ObjectUtils.isBlank(chargeHolderName) || "Others".equalsIgnoreCase(chargeHolderName)) {
            if (ObjectUtils.isNotBlank(companyChargesDataCrawlDto.getChargeName())) {
                chargeHolderName = companyChargesDataCrawlDto.getChargeName();
            } else {
                chargeHolderName = null;
            }
        }

        return chargeHolderName;
    }

    private static String cleanSearchQuery(String query) {
        query = query.toLowerCase();
        query = query.replaceAll("m/s", "");
        query = query.replaceAll("pvt.", " ");
        query = query.replaceAll("ltd.", " ");
        query = query.replaceAll("ltd", " ");
        query = query.replaceAll("pvt", " ");
        query = query.replaceAll("private", " ");
        query = query.replaceAll("llp", " ");
        query = query.replaceAll("limited", " ");
        query = query.replaceAll(" +", " ");
        return query.trim();
    }

    public static String encrypt(String plainText) throws Exception {
        byte[] saltBytes = getMD5Hash(saltStr);
        byte[] ivBytes = getMD5Hash(ivStr);

        SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA1");
        KeySpec spec = new PBEKeySpec(password.toCharArray(), saltBytes, iterations, keySize);
        SecretKey tmp = factory.generateSecret(spec);
        SecretKeySpec secretKey = new SecretKeySpec(tmp.getEncoded(), "AES");

        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        cipher.init(Cipher.ENCRYPT_MODE, secretKey, new IvParameterSpec(ivBytes));

        byte[] encryptedBytes = cipher.doFinal(plainText.getBytes(StandardCharsets.UTF_8));
        String encryptedBase64 = Base64.getEncoder().encodeToString(encryptedBytes);
        return encryptedBase64;
    }

    private static byte[] getMD5Hash(String input) throws Exception {
        MessageDigest md = MessageDigest.getInstance("MD5");
        return md.digest(input.getBytes(StandardCharsets.UTF_8));
    }

    public static String encodeURIComponent(String input) {
        if (ObjectUtils.isBlank(input)) {
            return "";
        }
        try {
            return URLEncoder.encode(input, "UTF-8")
                .replaceAll("\\+", "%20")
                .replaceAll("\\\\", "%5C")
                .replaceAll("/", "%2F")
                .replaceAll("-", "%2D")
                .replaceAll("_", "%5F");
        } catch (UnsupportedEncodingException e) {
            logger.error("Unable to encode string from urlEncoder: " + input, e);
            return input;
        }
    }

    @Override public TaskType getTaskType() {
        return TaskType.MCA;
    }

    public static void main(String[] args) throws Throwable {
        String partyName = "OFB Tech Pvt Ltd";
        long startTime = System.currentTimeMillis();
        McaTaskParamsDto mcaTaskParamsDto = McaTaskParamsDto.Builder.mcaTaskParamsDto()
            .withRequestId(null)
            .withCompanyName(partyName)
            .withCin("U74120MH2011PTC224675")
            .withGstIn(null)
            .build();
        McaCompanyDetailDto mcaCompanyDetailDto = parseMca(mcaTaskParamsDto);
        Long fetchtime = System.currentTimeMillis() - startTime;
        System.out.println("Fetched in: " + fetchtime);
        
        System.out.println(mcaCompanyDetailDto.getCompanyDetailDto());
    }
}


package com.ofb.crawler.commons.types.gstToPan.dto.task;

@Data
@NoArgsConstructor
public class PanToGstTaskDto extends BaseTaskDto {

    private String pan ;

    public PanToGstTaskDto(String pan) {
        this.pan = pan;
    }
    public PanToGstTaskDto(String requestId, long requestTime, String requestedBy, RequestSource source, TaskType taskType, TaskPriority priority, long maxStaleTime, TaskStatus status, TaskError error, String callBackUrl, boolean isCallbackSuccess, String responseParsingId, String pan) {
        super(requestId, requestTime, requestedBy, source, taskType, priority, maxStaleTime, status, error, callBackUrl, isCallbackSuccess, responseParsingId);
        this.pan = pan;
    }

    public String getPan() {
        return pan;
    }

    public void setPan(String pan) {
        this.pan = pan;
    }

    public static interface RequestIdStep {
        RequestTimeStep withRequestId(String requestId);
    }

    public static interface RequestTimeStep {
        RequestedByStep withRequestTime(long requestTime);
    }

    public static interface RequestedByStep {
        SourceStep withRequestedBy(String requestedBy);
    }

    public static interface SourceStep {
        TaskTypeStep withSource(RequestSource source);
    }

    public static interface TaskTypeStep {
        PriorityStep withTaskType(TaskType taskType);
    }

    public static interface PriorityStep {
        MaxStaleTimeStep withPriority(TaskPriority priority);
    }

    public static interface MaxStaleTimeStep {
        StatusStep withMaxStaleTime(long maxStaleTime);
    }

    public static interface StatusStep {
        ErrorStep withStatus(TaskStatus status);
    }

    public static interface ErrorStep {
        CallBackUrlStep withError(TaskError error);
    }

    public static interface CallBackUrlStep {
        IsCallbackSuccessStep withCallBackUrl(String callBackUrl);
    }

    public static interface IsCallbackSuccessStep {
        ResponseParsingIdStep withIsCallbackSuccess(boolean isCallbackSuccess);
    }

    public static interface ResponseParsingIdStep {
        PanStep withResponseParsingId(String responseParsingId);
    }

    public static interface PanStep {
        BuildStep withPan(String pan);
    }

    public static interface BuildStep {
        PanToGstTaskDto build();
    }


    public static class Builder implements RequestIdStep, RequestTimeStep, RequestedByStep, SourceStep, TaskTypeStep, PriorityStep, MaxStaleTimeStep, StatusStep, ErrorStep, CallBackUrlStep, IsCallbackSuccessStep, ResponseParsingIdStep, PanStep, BuildStep {
        private String requestId;
        private long requestTime;
        private String requestedBy;
        private RequestSource source;
        private TaskType taskType;
        private TaskPriority priority;
        private long maxStaleTime;
        private TaskStatus status;
        private TaskError error;
        private String callBackUrl;
        private boolean isCallbackSuccess;
        private String responseParsingId;
        private String pan;

        private Builder() {
        }

        public static RequestIdStep panToGstTaskDto() {
            return new Builder();
        }

        @Override
        public RequestTimeStep withRequestId(String requestId) {
            this.requestId = requestId;
            return this;
        }

        @Override
        public RequestedByStep withRequestTime(long requestTime) {
            this.requestTime = requestTime;
            return this;
        }

        @Override
        public SourceStep withRequestedBy(String requestedBy) {
            this.requestedBy = requestedBy;
            return this;
        }

        @Override
        public TaskTypeStep withSource(RequestSource source) {
            this.source = source;
            return this;
        }

        @Override
        public PriorityStep withTaskType(TaskType taskType) {
            this.taskType = taskType;
            return this;
        }

        @Override
        public MaxStaleTimeStep withPriority(TaskPriority priority) {
            this.priority = priority;
            return this;
        }

        @Override
        public StatusStep withMaxStaleTime(long maxStaleTime) {
            this.maxStaleTime = maxStaleTime;
            return this;
        }

        @Override
        public ErrorStep withStatus(TaskStatus status) {
            this.status = status;
            return this;
        }

        @Override
        public CallBackUrlStep withError(TaskError error) {
            this.error = error;
            return this;
        }

        @Override
        public IsCallbackSuccessStep withCallBackUrl(String callBackUrl) {
            this.callBackUrl = callBackUrl;
            return this;
        }

        @Override
        public ResponseParsingIdStep withIsCallbackSuccess(boolean isCallbackSuccess) {
            this.isCallbackSuccess = isCallbackSuccess;
            return this;
        }

        @Override
        public PanStep withResponseParsingId(String responseParsingId) {
            this.responseParsingId = responseParsingId;
            return this;
        }

        @Override
        public BuildStep withPan(String pan) {
            this.pan = pan;
            return this;
        }

        @Override
        public PanToGstTaskDto build() {
            return new PanToGstTaskDto(
                    this.requestId,
                    this.requestTime,
                    this.requestedBy,
                    this.source,
                    this.taskType,
                    this.priority,
                    this.maxStaleTime,
                    this.status,
                    this.error,
                    this.callBackUrl,
                    this.isCallbackSuccess,
                    this.responseParsingId,
                    this.pan
            );
        }
    }
}


package com.ofb.crawler.commons.types.litigation.itat.dto.task;

@Data
@NoArgsConstructor
public class ItatTaskResponseDto extends BaseTaskResponseDto {

    private ItatResponseDto itatResponseDto;

    public ItatTaskResponseDto(ItatResponseDto itatResponseDto) {
        this.itatResponseDto = itatResponseDto;
    }

    public ItatTaskResponseDto(String requestId, TaskType taskType, TaskStatus status, TaskError error, ItatResponseDto itatResponseDto) {
        super(requestId, taskType, status, error);
        this.itatResponseDto = itatResponseDto;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ItatTaskResponseDto that = (ItatTaskResponseDto) o;
        return Objects.equals(itatResponseDto, that.itatResponseDto);
    }

    @Override
    public int hashCode() {
        return Objects.hash(itatResponseDto);
    }

    public static interface RequestIdStep {
        TaskTypeStep withRequestId(String requestId);
    }

    public static interface TaskTypeStep {
        StatusStep withTaskType(TaskType taskType);
    }

    public static interface StatusStep {
        ErrorStep withStatus(TaskStatus status);
    }

    public static interface ErrorStep {
        ItatResponseDtoStep withError(TaskError error);
    }

    public static interface ItatResponseDtoStep {
        BuildStep withItatResponseDto(ItatResponseDto itatResponseDto);
    }

    public static interface BuildStep {
        ItatTaskResponseDto build();
    }


    public static class Builder implements RequestIdStep, TaskTypeStep, StatusStep, ErrorStep, ItatResponseDtoStep, BuildStep {
        private String requestId;
        private TaskType taskType;
        private TaskStatus status;
        private TaskError error;
        private ItatResponseDto itatResponseDto;

        private Builder() {
        }

        public static RequestIdStep itatTaskResponseDto() {
            return new Builder();
        }

        @Override
        public TaskTypeStep withRequestId(String requestId) {
            this.requestId = requestId;
            return this;
        }

        @Override
        public StatusStep withTaskType(TaskType taskType) {
            this.taskType = taskType;
            return this;
        }

        @Override
        public ErrorStep withStatus(TaskStatus status) {
            this.status = status;
            return this;
        }

        @Override
        public ItatResponseDtoStep withError(TaskError error) {
            this.error = error;
            return this;
        }

        @Override
        public BuildStep withItatResponseDto(ItatResponseDto itatResponseDto) {
            this.itatResponseDto = itatResponseDto;
            return this;
        }

        @Override
        public ItatTaskResponseDto build() {
            return new ItatTaskResponseDto(
                    this.requestId,
                    this.taskType,
                    this.status,
                    this.error,
                    this.itatResponseDto
            );
        }
    }
}


package com.ofb.crawler.commons.types.knowYourGst.dto;

@Data
public class GstInfoDto {

    private String gstIn;

    private String gstStatus;

    private Long dateOfRegistration;

    private EnrichmentSubSource enrichmentSubSource;

    public GstInfoDto() {
    }

    public GstInfoDto(String gstIn, String gstStatus, Long dateOfRegistration,
        EnrichmentSubSource enrichmentSubSource) {
        this.gstIn = gstIn;
        this.gstStatus = gstStatus;
        this.dateOfRegistration = dateOfRegistration;
        this.enrichmentSubSource = enrichmentSubSource;
    }

    @Override public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        GstInfoDto that = (GstInfoDto) o;
        return Objects.equals(gstIn, that.gstIn)
            && Objects.equals(gstStatus, that.gstStatus)
            && Objects.equals(dateOfRegistration, that.dateOfRegistration)
            && enrichmentSubSource == that.enrichmentSubSource;
    }

    @Override public int hashCode() {
        return Objects.hash(gstIn, gstStatus, dateOfRegistration, enrichmentSubSource);
    }

    public static interface GstInStep {
        GstStatusStep withGstIn(String gstIn);
    }

    public static interface GstStatusStep {
        DateOfRegistrationStep withGstStatus(String gstStatus);
    }

    public static interface DateOfRegistrationStep {
        EnrichmentSubSourceStep withDateOfRegistration(Long dateOfRegistration);
    }

    public static interface EnrichmentSubSourceStep {
        BuildStep withEnrichmentSubSource(EnrichmentSubSource enrichmentSubSource);
    }

    public static interface BuildStep {
        GstInfoDto build();
    }

    public static class Builder
        implements GstInStep, GstStatusStep, DateOfRegistrationStep, EnrichmentSubSourceStep, BuildStep {
        private String gstIn;
        private String gstStatus;
        private Long dateOfRegistration;
        private EnrichmentSubSource enrichmentSubSource;

        private Builder() {
        }

        public static GstInStep gstInfoDto() {
            return new Builder();
        }

        @Override
        public GstStatusStep withGstIn(String gstIn) {
            this.gstIn = gstIn;
            return this;
        }

        @Override
        public DateOfRegistrationStep withGstStatus(String gstStatus) {
            this.gstStatus = gstStatus;
            return this;
        }

        @Override
        public EnrichmentSubSourceStep withDateOfRegistration(Long dateOfRegistration) {
            this.dateOfRegistration = dateOfRegistration;
            return this;
        }

        @Override
        public BuildStep withEnrichmentSubSource(EnrichmentSubSource enrichmentSubSource) {
            this.enrichmentSubSource = enrichmentSubSource;
            return this;
        }

        @Override
        public GstInfoDto build() {
            return new GstInfoDto(
                this.gstIn,
                this.gstStatus,
                this.dateOfRegistration,
                this.enrichmentSubSource
            );
        }
    }
}


package com.ofb.crawler.commons.types.mca.dto;

public class CompanyDataCrawlDto {

    @JsonProperty("CIN")
    private String cin;

    @JsonProperty("company")
    private String companyName;

    @JsonProperty("companyType")
    private String companyType;

    @JsonProperty("companyOrigin")
    private String companyOrigin;

    @JsonProperty("registrationNumber")
    private String registrationNumber;

    @JsonProperty("dateOfIncorporation")
    private String dateOfIncorporation;

    @JsonProperty("emailAddress")
    private String emailAddress;

    @JsonProperty("whetherListedOrNot")
    private String whetherListedOrNot;

    @JsonProperty("companyCategory")
    private String companyCategory;

    @JsonProperty("companySubcategory")
    private String companySubcategory;

    @JsonProperty("classOfCompany")
    private String classOfCompany;

    @JsonProperty("authorisedCapital")
    private BigDecimal authorisedCapital;

    @JsonProperty("paidUpCapital")
    private BigDecimal paidUpCapital;

    @JsonProperty("numberOfMembers")
    private Long numberOfMembers;

    @JsonProperty("dateOfLastAGM")
    private String dateOfLastAGM;

    @JsonProperty("strikeOff_amalgamated_transferredDate")
    private String strikeOffAmalgamatedTransferredDate;

    @JsonProperty("llpStatus")
    private String llpStatus;

    @JsonProperty("statusUnderCIRP")
    private String statusUnderCIRP;

    @JsonProperty("numberOfPartners")
    private Long numberOfPartners;

    @JsonProperty("numberOfDesignatedPartners")
    private Long numberOfDesignatedPartners;

    @JsonProperty("totalObligationOfContribution")
    private Long totalObligationOfContribution;

    @JsonProperty("mainDivision")
    private String mainDivision;

    @JsonProperty("mainDivisionDescription")
    private String mainDivisionDescription;

    @JsonProperty("statementDate")
    private String statementDate;

    @JsonProperty("BSDefaulter2Yrs")
    private String bSDefaulter2Yrs;

    @JsonProperty("BSDefaulter3Yrs")
    private String bSDefaulter3Yrs;

    @JsonProperty("ARDefaulter2Yrs")
    private String aRDefaulter2Yrs;

    @JsonProperty("ARDefaulter3Yrs")
    private String aRDefaulter3Yrs;

    @JsonProperty("suspendedAtStockExchange")
    private String suspendedAtStockExchange;

    @JsonProperty("MCAMDSCompanyAddress")
    private List<CompanyAddressCrawlDto> companyAddress;

    @JsonProperty("balanceSheet3years")
    private List<CompanyFilingEntryCrawlDto> balanceSheet3years;

    @JsonProperty("annualReturns3years")
    private List<CompanyFilingEntryCrawlDto> annualReturns3years;

    @JsonProperty("rocName")
    private String rocName;

    @JsonProperty("shareCapitalFlag")
    private String shareCapitalFlag;

    @JsonProperty("maximumNumberOfMembers")
    private String maximumNumberOfMembers;

    @JsonProperty("subscribedCapital")
    private String subscribedCapital;

    @JsonProperty("rdName")
    private String rdName;

    @JsonProperty("rdRegion")
    private String rdRegion;

    @JsonProperty("balanceSheetDate")
    private String balanceSheetDate;

    @JsonProperty("inc22Aflag")
    private String inc22Aflag;

    public CompanyDataCrawlDto() {
    }

    public CompanyDataCrawlDto(String cin, String companyName, String companyType, String companyOrigin,
        String registrationNumber, String dateOfIncorporation, String emailAddress, String whetherListedOrNot,
        String companyCategory, String companySubcategory, String classOfCompany, BigDecimal authorisedCapital,
        BigDecimal paidUpCapital, Long numberOfMembers, String dateOfLastAGM,
        String strikeOffAmalgamatedTransferredDate, String llpStatus, String statusUnderCIRP,
        Long numberOfPartners, Long numberOfDesignatedPartners, Long totalObligationOfContribution,
        String mainDivision, String mainDivisionDescription, String statementDate, String bSDefaulter2Yrs,
        String bSDefaulter3Yrs, String aRDefaulter2Yrs, String aRDefaulter3Yrs, String suspendedAtStockExchange,
        List<CompanyAddressCrawlDto> companyAddress,
        List<CompanyFilingEntryCrawlDto> balanceSheet3years,
        List<CompanyFilingEntryCrawlDto> annualReturns3years, String rocName, String shareCapitalFlag,
        String maximumNumberOfMembers, String subscribedCapital, String rdName, String rdRegion,
        String balanceSheetDate, String inc22Aflag) {
        this.cin = cin;
        this.companyName = companyName;
        this.companyType = companyType;
        this.companyOrigin = companyOrigin;
        this.registrationNumber = registrationNumber;
        this.dateOfIncorporation = dateOfIncorporation;
        this.emailAddress = emailAddress;
        this.whetherListedOrNot = whetherListedOrNot;
        this.companyCategory = companyCategory;
        this.companySubcategory = companySubcategory;
        this.classOfCompany = classOfCompany;
        this.authorisedCapital = authorisedCapital;
        this.paidUpCapital = paidUpCapital;
        this.numberOfMembers = numberOfMembers;
        this.dateOfLastAGM = dateOfLastAGM;
        this.strikeOffAmalgamatedTransferredDate = strikeOffAmalgamatedTransferredDate;
        this.llpStatus = llpStatus;
        this.statusUnderCIRP = statusUnderCIRP;
        this.numberOfPartners = numberOfPartners;
        this.numberOfDesignatedPartners = numberOfDesignatedPartners;
        this.totalObligationOfContribution = totalObligationOfContribution;
        this.mainDivision = mainDivision;
        this.mainDivisionDescription = mainDivisionDescription;
        this.statementDate = statementDate;
        this.bSDefaulter2Yrs = bSDefaulter2Yrs;
        this.bSDefaulter3Yrs = bSDefaulter3Yrs;
        this.aRDefaulter2Yrs = aRDefaulter2Yrs;
        this.aRDefaulter3Yrs = aRDefaulter3Yrs;
        this.suspendedAtStockExchange = suspendedAtStockExchange;
        this.companyAddress = companyAddress;
        this.balanceSheet3years = balanceSheet3years;
        this.annualReturns3years = annualReturns3years;
        this.rocName = rocName;
        this.shareCapitalFlag = shareCapitalFlag;
        this.maximumNumberOfMembers = maximumNumberOfMembers;
        this.subscribedCapital = subscribedCapital;
        this.rdName = rdName;
        this.rdRegion = rdRegion;
        this.balanceSheetDate = balanceSheetDate;
        this.inc22Aflag = inc22Aflag;
    }

    public String getCin() {
        return cin;
    }

    public void setCin(String cin) {
        this.cin = cin;
    }

    public String getCompanyName() {
        return companyName;
    }

    public void setCompanyName(String companyName) {
        this.companyName = companyName;
    }

    public String getCompanyType() {
        return companyType;
    }

    public void setCompanyType(String companyType) {
        this.companyType = companyType;
    }

    public String getCompanyOrigin() {
        return companyOrigin;
    }

    public void setCompanyOrigin(String companyOrigin) {
        this.companyOrigin = companyOrigin;
    }

    public String getRegistrationNumber() {
        return registrationNumber;
    }

    public void setRegistrationNumber(String registrationNumber) {
        this.registrationNumber = registrationNumber;
    }

    public String getDateOfIncorporation() {
        return dateOfIncorporation;
    }

    public void setDateOfIncorporation(String dateOfIncorporation) {
        this.dateOfIncorporation = dateOfIncorporation;
    }

    public String getEmailAddress() {
        return emailAddress;
    }

    public void setEmailAddress(String emailAddress) {
        this.emailAddress = emailAddress;
    }

    public String getWhetherListedOrNot() {
        return whetherListedOrNot;
    }

    public void setWhetherListedOrNot(String whetherListedOrNot) {
        this.whetherListedOrNot = whetherListedOrNot;
    }

    public String getCompanyCategory() {
        return companyCategory;
    }

    public void setCompanyCategory(String companyCategory) {
        this.companyCategory = companyCategory;
    }

    public String getCompanySubcategory() {
        return companySubcategory;
    }

    public void setCompanySubcategory(String companySubcategory) {
        this.companySubcategory = companySubcategory;
    }

    public String getClassOfCompany() {
        return classOfCompany;
    }

    public void setClassOfCompany(String classOfCompany) {
        this.classOfCompany = classOfCompany;
    }

    public BigDecimal getAuthorisedCapital() {
        return authorisedCapital;
    }

    public void setAuthorisedCapital(BigDecimal authorisedCapital) {
        this.authorisedCapital = authorisedCapital;
    }

    public BigDecimal getPaidUpCapital() {
        return paidUpCapital;
    }

    public void setPaidUpCapital(BigDecimal paidUpCapital) {
        this.paidUpCapital = paidUpCapital;
    }

    public Long getNumberOfMembers() {
        return numberOfMembers;
    }

    public void setNumberOfMembers(Long numberOfMembers) {
        this.numberOfMembers = numberOfMembers;
    }

    public String getDateOfLastAGM() {
        return dateOfLastAGM;
    }

    public void setDateOfLastAGM(String dateOfLastAGM) {
        this.dateOfLastAGM = dateOfLastAGM;
    }

    public String getStrikeOffAmalgamatedTransferredDate() {
        return strikeOffAmalgamatedTransferredDate;
    }

    public void setStrikeOffAmalgamatedTransferredDate(String strikeOffAmalgamatedTransferredDate) {
        this.strikeOffAmalgamatedTransferredDate = strikeOffAmalgamatedTransferredDate;
    }

    public String getLlpStatus() {
        return llpStatus;
    }

    public void setLlpStatus(String llpStatus) {
        this.llpStatus = llpStatus;
    }

    public String getStatusUnderCIRP() {
        return statusUnderCIRP;
    }

    public void setStatusUnderCIRP(String statusUnderCIRP) {
        this.statusUnderCIRP = statusUnderCIRP;
    }

    public Long getNumberOfPartners() {
        return numberOfPartners;
    }

    public void setNumberOfPartners(Long numberOfPartners) {
        this.numberOfPartners = numberOfPartners;
    }

    public Long getNumberOfDesignatedPartners() {
        return numberOfDesignatedPartners;
    }

    public void setNumberOfDesignatedPartners(Long numberOfDesignatedPartners) {
        this.numberOfDesignatedPartners = numberOfDesignatedPartners;
    }

    public Long getTotalObligationOfContribution() {
        return totalObligationOfContribution;
    }

    public void setTotalObligationOfContribution(Long totalObligationOfContribution) {
        this.totalObligationOfContribution = totalObligationOfContribution;
    }

    public String getMainDivision() {
        return mainDivision;
    }

    public void setMainDivision(String mainDivision) {
        this.mainDivision = mainDivision;
    }

    public String getMainDivisionDescription() {
        return mainDivisionDescription;
    }

    public void setMainDivisionDescription(String mainDivisionDescription) {
        this.mainDivisionDescription = mainDivisionDescription;
    }

    public String getStatementDate() {
        return statementDate;
    }

    public void setStatementDate(String statementDate) {
        this.statementDate = statementDate;
    }

    public String getbSDefaulter2Yrs() {
        return bSDefaulter2Yrs;
    }

    public void setbSDefaulter2Yrs(String bSDefaulter2Yrs) {
        this.bSDefaulter2Yrs = bSDefaulter2Yrs;
    }

    public String getbSDefaulter3Yrs() {
        return bSDefaulter3Yrs;
    }

    public void setbSDefaulter3Yrs(String bSDefaulter3Yrs) {
        this.bSDefaulter3Yrs = bSDefaulter3Yrs;
    }

    public String getaRDefaulter2Yrs() {
        return aRDefaulter2Yrs;
    }

    public void setaRDefaulter2Yrs(String aRDefaulter2Yrs) {
        this.aRDefaulter2Yrs = aRDefaulter2Yrs;
    }

    public String getaRDefaulter3Yrs() {
        return aRDefaulter3Yrs;
    }

    public void setaRDefaulter3Yrs(String aRDefaulter3Yrs) {
        this.aRDefaulter3Yrs = aRDefaulter3Yrs;
    }

    public String getSuspendedAtStockExchange() {
        return suspendedAtStockExchange;
    }

    public void setSuspendedAtStockExchange(String suspendedAtStockExchange) {
        this.suspendedAtStockExchange = suspendedAtStockExchange;
    }

    public List<CompanyAddressCrawlDto> getCompanyAddress() {
        return companyAddress;
    }

    public void setCompanyAddress(List<CompanyAddressCrawlDto> companyAddress) {
        this.companyAddress = companyAddress;
    }

    public List<CompanyFilingEntryCrawlDto> getBalanceSheet3years() {
        return balanceSheet3years;
    }

    public void setBalanceSheet3years(
        List<CompanyFilingEntryCrawlDto> balanceSheet3years) {
        this.balanceSheet3years = balanceSheet3years;
    }

    public List<CompanyFilingEntryCrawlDto> getAnnualReturns3years() {
        return annualReturns3years;
    }

    public void setAnnualReturns3years(
        List<CompanyFilingEntryCrawlDto> annualReturns3years) {
        this.annualReturns3years = annualReturns3years;
    }

    public String getRocName() {
        return rocName;
    }

    public void setRocName(String rocName) {
        this.rocName = rocName;
    }

    public String getShareCapitalFlag() {
        return shareCapitalFlag;
    }

    public void setShareCapitalFlag(String shareCapitalFlag) {
        this.shareCapitalFlag = shareCapitalFlag;
    }

    public String getMaximumNumberOfMembers() {
        return maximumNumberOfMembers;
    }

    public void setMaximumNumberOfMembers(String maximumNumberOfMembers) {
        this.maximumNumberOfMembers = maximumNumberOfMembers;
    }

    public String getSubscribedCapital() {
        return subscribedCapital;
    }

    public void setSubscribedCapital(String subscribedCapital) {
        this.subscribedCapital = subscribedCapital;
    }

    public String getRdName() {
        return rdName;
    }

    public void setRdName(String rdName) {
        this.rdName = rdName;
    }

    public String getRdRegion() {
        return rdRegion;
    }

    public void setRdRegion(String rdRegion) {
        this.rdRegion = rdRegion;
    }

    public String getBalanceSheetDate() {
        return balanceSheetDate;
    }

    public void setBalanceSheetDate(String balanceSheetDate) {
        this.balanceSheetDate = balanceSheetDate;
    }

    public String getInc22Aflag() {
        return inc22Aflag;
    }

    public void setInc22Aflag(String inc22Aflag) {
        this.inc22Aflag = inc22Aflag;
    }
}


package com.ofb.crawler.commons.util;

public class StringUtils {

    public static final Pattern PATTERN_UUID =
        Pattern.compile("/[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}/");
    public static final String COLON = ":";
    public static String EMPTY="";

    public static String NEWLINE="\r";

    public static String nullIfBlank(String str) {
        return isBlank(str) ? null : str;
    }

    public static boolean isEmpty(String str) {
        return isBlank(str);
    }

    public static boolean isBlank(String str) {
        int strLen;
        if (str == null || (strLen = str.length()) == 0) {
            return true;
        }
        for (int i = 0; i < strLen; i++) {
            if (!Character.isWhitespace(str.charAt(i))) {
                return false;
            }
        }
        return true;
    }

    public static String trim(String str) {
        if (str == null) {
            return null;
        }
        return str.trim().replaceAll(String.valueOf((char) 160), "");
    }

    public static boolean isNotBlank(String str) {
        return !isBlank(str);
    }

    public static boolean isAnyExists(String... arr){
        for (int i = 0; i < arr.length; i++) {
            if (!isBlank(arr[i])) {
                return true;
            }
        }

        return false;
    }

    public static boolean isAllExists(String... arr){
        for (int i = 0; i < arr.length; i++) {
            if (isBlank(arr[i])) {
                return false;
            }
        }

        return true;
    }

    public static String arrayValAtIndex(String[]arr, int index){
        String val = arr.length > index ? nullIfBlank(arr[index]) : null;
        return val;
    }

    public static String removeAllNonBreakableSpaces(String text){
        return text.replaceAll("\u00A0"," ").trim();
    }

    public static String removeAllReturns(String text){
        return text.replaceAll("\\r"," ").trim();
    }

    public static String removeAllSpaces(String text){
        return text.replaceAll(" ","");
    }

    static int indexOfClosestMatchingString(String[] arr, String y) {
        int minInd=-1;
        int minDis=Integer.MAX_VALUE;
        for(int i=0;i<arr.length;i++) {
            int dis=LevenshteinDistance
                .getDefaultInstance()
                .apply(arr[0], y);
            if(dis<minDis){
                minInd=i;
            }
        }
        return minInd;
    }

    public static String removeLeadingZero(String str)
    {
        
        int i = 0;
        while (i < str.length() && str.charAt(i) == '0')
            i++;

        
        
        StringBuffer sb = new StringBuffer(str);

        
        
        sb.replace(0, i, "");

        return sb.toString();  
    }

    public static String[] splitAndRemoveEmptyVals(String str,String separator){
        String[] vals = str.split("\\|");
        List<String> newVals = new LinkedList<>();
        for(int i=0;i<vals.length;i++){
            if(!StringUtils.isBlank(vals[i])){
                newVals.add(vals[i]);
            }
        }
        return Arrays.copyOf(newVals.toArray(),newVals.size(),String[].class);

    }

    public static String replaceAllAmp(String text){
        return text.replaceAll("%amp;","&").trim();
    }

    public static String removeNpsp(String text) {
        return text.replaceAll("&npsp;","");
    }

    public static boolean isNumericVal(String awardedPrice) {
        try{
            Double.parseDouble(awardedPrice);
            return true;
        }catch (Exception e){
            return false;
        }
    }

    public static boolean nullSafeEquals(String s1, String s2) {
        if(s1==null && s2==null){
            return true;
        }
        if(s1==null || s2==null){
            return false;
        }
        return s1.equals(s2);
    }

    public Boolean parseObjToBool(Object val,Boolean defaultVal){
        if(val==null){
            return defaultVal;
        }
        try{
            return Boolean.parseBoolean(val.toString());
        }catch (Exception ex){
            return defaultVal;
        }
    }

    public static String removeSpecialChars(String str){
        return str.replaceAll("[^a-zA-Z0-9]", " ");
    }

    public static String removeSpecialCharsExceptPipe(String str){
        return str.replaceAll("[^a-zA-Z0-9|]", " ");
    }

    public static int levenshtein(String str1,String str2){
        LevenshteinDistance ld = new LevenshteinDistance();
        return ld.apply(str1,str2);
    }

    public static boolean patternMatch(String str, Pattern p){
        Matcher m = p.matcher(str);
        while (m.find()){
            return true;
        }
        return m.find();
    }

    public static Optional<String> extractPattern(String str, Pattern p){
        Matcher m = p.matcher(str);
        while (m.find()){
            return Optional.of(m.group());
        }
        return Optional.empty();
    }

    public static String extractFirstMatch(String str, Pattern p){
        Matcher m = p.matcher(str);
        while (m.find()){
            return m.group(0);
        }
        return null;
    }


    public static String extractFirstMatch(String str, Pattern p,int matchNo){
        Matcher m = p.matcher(str);
        while (m.find()){
            return m.group(matchNo);
        }
        return null;
    }

    public static SystemAssignedStatus getNameMatchStatus(String label, String searchKey) {
        if (LitigationUtils.isNameMatched(label, searchKey)) {
            return SystemAssignedStatus.MATCHED;
        }
        String sanitizeLabel = LitigationUtils.sanitizeNameForMatch(label);
        Pattern pattern = Pattern.compile("\\b" + sanitizeLabel + "\\b");
        String sanitizedSearchKey = LitigationUtils.sanitizeNameForMatch(searchKey);
        if (pattern.matcher(sanitizedSearchKey).find()) {
            return SystemAssignedStatus.PARTIAL_MATCH;
        }
        pattern = Pattern.compile("\\b" + sanitizedSearchKey + "\\b");
        if (pattern.matcher(sanitizeLabel).find()) {
            return SystemAssignedStatus.PARTIAL_MATCH;
        }
        Set<String> allSanitizedNames = Arrays.stream(sanitizeLabel.split(" ")).filter(s -> s.length() > 1)
            .collect(Collectors.toSet());
        Set<String> sanitizedSearchKeySet = Arrays.stream(sanitizedSearchKey.split(" ")).filter(s -> s.length() > 1)
            .collect(Collectors.toSet());
        if (!allSanitizedNames.retainAll(sanitizedSearchKeySet) && allSanitizedNames.size() > 1) {
            return SystemAssignedStatus.PARTIAL_MATCH;
        }
        return SystemAssignedStatus.UNMATCHED;
    }
}


package com.ofb.crawler.commons.types.mca.dto;

public class BasicDetail {

    private String cin;

    private String llp;

    @Override public String toString() {
        return "BasicDetail{" +
            "cin='" + cin + '\'' +
            ", llp='" + llp + '\'' +
            ", name='" + name + '\'' +
            ", companyStatus='" + companyStatus + '\'' +
            ", roc='" + roc + '\'' +
            ", registrationNo='" + registrationNo + '\'' +
            ", companyCategory='" + companyCategory + '\'' +
            ", companySubCategory='" + companySubCategory + '\'' +
            ", classOfCompany='" + classOfCompany + '\'' +
            ", dateOfIncorporation=" + dateOfIncorporation +
            ", ageOfCompanyInDays=" + ageOfCompanyInDays +
            ", activity='" + activity + '\'' +
            ", numberOfMembers='" + numberOfMembers + '\'' +
            '}';
    }

    public String getCin() {
        return cin;
    }

    public void setCin(String cin) {
        this.cin = cin;
    }

    public String getLlp() {
        return llp;
    }

    public void setLlp(String llp) {
        this.llp = llp;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getCompanyStatus() {
        return companyStatus;
    }

    public void setCompanyStatus(String companyStatus) {
        this.companyStatus = companyStatus;
    }

    public String getRoc() {
        return roc;
    }

    public void setRoc(String roc) {
        this.roc = roc;
    }

    public String getRegistrationNo() {
        return registrationNo;
    }

    public void setRegistrationNo(String registrationNo) {
        this.registrationNo = registrationNo;
    }

    public String getCompanyCategory() {
        return companyCategory;
    }

    public void setCompanyCategory(String companyCategory) {
        this.companyCategory = companyCategory;
    }

    public String getCompanySubCategory() {
        return companySubCategory;
    }

    public void setCompanySubCategory(String companySubCategory) {
        this.companySubCategory = companySubCategory;
    }

    public String getClassOfCompany() {
        return classOfCompany;
    }

    public void setClassOfCompany(String classOfCompany) {
        this.classOfCompany = classOfCompany;
    }

    public Long getDateOfIncorporation() {
        return dateOfIncorporation;
    }

    public void setDateOfIncorporation(Long dateOfIncorporation) {
        this.dateOfIncorporation = dateOfIncorporation;
    }

    public Long getAgeOfCompanyInDays() {
        return ageOfCompanyInDays;
    }

    public void setAgeOfCompanyInDays(Long ageOfCompanyInDays) {
        this.ageOfCompanyInDays = ageOfCompanyInDays;
    }

    public String getActivity() {
        return activity;
    }

    public void setActivity(String activity) {
        this.activity = activity;
    }

    public String getNumberOfMembers() {
        return numberOfMembers;
    }

    public void setNumberOfMembers(String numberOfMembers) {
        this.numberOfMembers = numberOfMembers;
    }

    public BasicDetail() {
    }

    public BasicDetail(String cin, String llp, String name, String companyStatus, String roc, String registrationNo, String companyCategory, String companySubCategory, String classOfCompany, Long dateOfIncorporation, Long ageOfCompanyInDays, String activity, String numberOfMembers) {
        this.cin = cin;
        this.llp = llp;
        this.name = name;
        this.companyStatus = companyStatus;
        this.roc = roc;
        this.registrationNo = registrationNo;
        this.companyCategory = companyCategory;
        this.companySubCategory = companySubCategory;
        this.classOfCompany = classOfCompany;
        this.dateOfIncorporation = dateOfIncorporation;
        this.ageOfCompanyInDays = ageOfCompanyInDays;
        this.activity = activity;
        this.numberOfMembers = numberOfMembers;
    }

    private String name;

    private String companyStatus; 

    private String roc; 

    private String registrationNo; 

    private String companyCategory;

    private String companySubCategory;

    private String classOfCompany;

    private Long dateOfIncorporation;

    private Long ageOfCompanyInDays;

    private String activity;

    private String numberOfMembers;

    public static interface CinStep {
        LlpStep withCin(String cin);
    }

    public static interface LlpStep {
        NameStep withLlp(String llp);
    }

    public static interface NameStep {
        CompanyStatusStep withName(String name);
    }

    public static interface CompanyStatusStep {
        RocStep withCompanyStatus(String companyStatus);
    }

    public static interface RocStep {
        RegistrationNoStep withRoc(String roc);
    }

    public static interface RegistrationNoStep {
        CompanyCategoryStep withRegistrationNo(String registrationNo);
    }

    public static interface CompanyCategoryStep {
        CompanySubCategoryStep withCompanyCategory(String companyCategory);
    }

    public static interface CompanySubCategoryStep {
        ClassOfCompanyStep withCompanySubCategory(String companySubCategory);
    }

    public static interface ClassOfCompanyStep {
        DateOfIncorporationStep withClassOfCompany(String classOfCompany);
    }

    public static interface DateOfIncorporationStep {
        AgeOfCompanyInDaysStep withDateOfIncorporation(Long dateOfIncorporation);
    }

    public static interface AgeOfCompanyInDaysStep {
        ActivityStep withAgeOfCompanyInDays(Long ageOfCompanyInDays);
    }

    public static interface ActivityStep {
        NumberOfMembersStep withActivity(String activity);
    }

    public static interface NumberOfMembersStep {
        BuildStep withNumberOfMembers(String numberOfMembers);
    }

    public static interface BuildStep {
        BasicDetail build();
    }

    public static class Builder implements CinStep, LlpStep, NameStep, CompanyStatusStep, RocStep, RegistrationNoStep, CompanyCategoryStep, CompanySubCategoryStep, ClassOfCompanyStep, DateOfIncorporationStep, AgeOfCompanyInDaysStep, ActivityStep, NumberOfMembersStep, BuildStep {
        private String cin;
        private String llp;
        private String name;
        private String companyStatus;
        private String roc;
        private String registrationNo;
        private String companyCategory;
        private String companySubCategory;
        private String classOfCompany;
        private Long dateOfIncorporation;
        private Long ageOfCompanyInDays;
        private String activity;
        private String numberOfMembers;

        private Builder() {
        }

        public static CinStep basicDetail() {
            return new Builder();
        }

        @Override
        public LlpStep withCin(String cin) {
            this.cin = cin;
            return this;
        }

        @Override
        public NameStep withLlp(String llp) {
            this.llp = llp;
            return this;
        }

        @Override
        public CompanyStatusStep withName(String name) {
            this.name = name;
            return this;
        }

        @Override
        public RocStep withCompanyStatus(String companyStatus) {
            this.companyStatus = companyStatus;
            return this;
        }

        @Override
        public RegistrationNoStep withRoc(String roc) {
            this.roc = roc;
            return this;
        }

        @Override
        public CompanyCategoryStep withRegistrationNo(String registrationNo) {
            this.registrationNo = registrationNo;
            return this;
        }

        @Override
        public CompanySubCategoryStep withCompanyCategory(String companyCategory) {
            this.companyCategory = companyCategory;
            return this;
        }

        @Override
        public ClassOfCompanyStep withCompanySubCategory(String companySubCategory) {
            this.companySubCategory = companySubCategory;
            return this;
        }

        @Override
        public DateOfIncorporationStep withClassOfCompany(String classOfCompany) {
            this.classOfCompany = classOfCompany;
            return this;
        }

        @Override
        public AgeOfCompanyInDaysStep withDateOfIncorporation(Long dateOfIncorporation) {
            this.dateOfIncorporation = dateOfIncorporation;
            return this;
        }

        @Override
        public ActivityStep withAgeOfCompanyInDays(Long ageOfCompanyInDays) {
            this.ageOfCompanyInDays = ageOfCompanyInDays;
            return this;
        }

        @Override
        public NumberOfMembersStep withActivity(String activity) {
            this.activity = activity;
            return this;
        }

        @Override
        public BuildStep withNumberOfMembers(String numberOfMembers) {
            this.numberOfMembers = numberOfMembers;
            return this;
        }

        @Override
        public BasicDetail build() {
            return new BasicDetail(
                    this.cin,
                    this.llp,
                    this.name,
                    this.companyStatus,
                    this.roc,
                    this.registrationNo,
                    this.companyCategory,
                    this.companySubCategory,
                    this.classOfCompany,
                    this.dateOfIncorporation,
                    this.ageOfCompanyInDays,
                    this.activity,
                    this.numberOfMembers
            );
        }
    }
}


package com.ofb.crawler.commons.types.mca.dto;

public class CompanyAddressCrawlDto {

    @JsonProperty("streetAddress")
    private String streetAddress;

    @JsonProperty("streetAddress2")
    private String streetAddress2;

    @JsonProperty("streetAddress3")
    private String streetAddress3;

    @JsonProperty("streetAddress4")
    private String streetAddress4;

    @JsonProperty("addressType")
    private String addressType;

    @JsonProperty("locality")
    private String locality;

    @JsonProperty("district")
    private String district;

    @JsonProperty("city")
    private String city;

    @JsonProperty("state")
    private String state;

    @JsonProperty("country")
    private String country;

    @JsonProperty("postalCode")
    private Long postalCode;

    @JsonProperty("officeType")
    private String officeType;

    @JsonProperty("activeStatus")
    private String activeStatus;

    @JsonProperty("establishmentDate")
    private String establishmentDate;

    public CompanyAddressCrawlDto() {
    }

    public CompanyAddressCrawlDto(String streetAddress, String streetAddress2, String streetAddress3,
        String streetAddress4, String addressType, String locality, String district, String city, String state,
        String country, Long postalCode, String officeType, String activeStatus, String establishmentDate) {
        this.streetAddress = streetAddress;
        this.streetAddress2 = streetAddress2;
        this.streetAddress3 = streetAddress3;
        this.streetAddress4 = streetAddress4;
        this.addressType = addressType;
        this.locality = locality;
        this.district = district;
        this.city = city;
        this.state = state;
        this.country = country;
        this.postalCode = postalCode;
        this.officeType = officeType;
        this.activeStatus = activeStatus;
        this.establishmentDate = establishmentDate;
    }

    public String getStreetAddress() {
        return streetAddress;
    }

    public void setStreetAddress(String streetAddress) {
        this.streetAddress = streetAddress;
    }

    public String getStreetAddress2() {
        return streetAddress2;
    }

    public void setStreetAddress2(String streetAddress2) {
        this.streetAddress2 = streetAddress2;
    }

    public String getStreetAddress3() {
        return streetAddress3;
    }

    public void setStreetAddress3(String streetAddress3) {
        this.streetAddress3 = streetAddress3;
    }

    public String getStreetAddress4() {
        return streetAddress4;
    }

    public void setStreetAddress4(String streetAddress4) {
        this.streetAddress4 = streetAddress4;
    }

    public String getAddressType() {
        return addressType;
    }

    public void setAddressType(String addressType) {
        this.addressType = addressType;
    }

    public String getLocality() {
        return locality;
    }

    public void setLocality(String locality) {
        this.locality = locality;
    }

    public String getDistrict() {
        return district;
    }

    public void setDistrict(String district) {
        this.district = district;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }

    public String getCountry() {
        return country;
    }

    public void setCountry(String country) {
        this.country = country;
    }

    public Long getPostalCode() {
        return postalCode;
    }

    public void setPostalCode(Long postalCode) {
        this.postalCode = postalCode;
    }

    public String getOfficeType() {
        return officeType;
    }

    public void setOfficeType(String officeType) {
        this.officeType = officeType;
    }

    public String getActiveStatus() {
        return activeStatus;
    }

    public void setActiveStatus(String activeStatus) {
        this.activeStatus = activeStatus;
    }

    public String getEstablishmentDate() {
        return establishmentDate;
    }

    public void setEstablishmentDate(String establishmentDate) {
        this.establishmentDate = establishmentDate;
    }

    public static interface StreetAddressStep {
        StreetAddress2Step withStreetAddress(String streetAddress);
    }

    public static interface StreetAddress2Step {
        StreetAddress3Step withStreetAddress2(String streetAddress2);
    }

    public static interface StreetAddress3Step {
        StreetAddress4Step withStreetAddress3(String streetAddress3);
    }

    public static interface StreetAddress4Step {
        AddressTypeStep withStreetAddress4(String streetAddress4);
    }

    public static interface AddressTypeStep {
        LocalityStep withAddressType(String addressType);
    }

    public static interface LocalityStep {
        DistrictStep withLocality(String locality);
    }

    public static interface DistrictStep {
        CityStep withDistrict(String district);
    }

    public static interface CityStep {
        StateStep withCity(String city);
    }

    public static interface StateStep {
        CountryStep withState(String state);
    }

    public static interface CountryStep {
        PostalCodeStep withCountry(String country);
    }

    public static interface PostalCodeStep {
        OfficeTypeStep withPostalCode(Long postalCode);
    }

    public static interface OfficeTypeStep {
        ActiveStatusStep withOfficeType(String officeType);
    }

    public static interface ActiveStatusStep {
        EstablishmentDateStep withActiveStatus(String activeStatus);
    }

    public static interface EstablishmentDateStep {
        BuildStep withEstablishmentDate(String establishmentDate);
    }

    public static interface BuildStep {
        CompanyAddressCrawlDto build();
    }

    public static class Builder
        implements StreetAddressStep, StreetAddress2Step, StreetAddress3Step, StreetAddress4Step, AddressTypeStep,
        LocalityStep, DistrictStep, CityStep, StateStep, CountryStep, PostalCodeStep, OfficeTypeStep, ActiveStatusStep,
        EstablishmentDateStep, BuildStep {
        private String streetAddress;
        private String streetAddress2;
        private String streetAddress3;
        private String streetAddress4;
        private String addressType;
        private String locality;
        private String district;
        private String city;
        private String state;
        private String country;
        private Long postalCode;
        private String officeType;
        private String activeStatus;
        private String establishmentDate;

        private Builder() {
        }

        public static StreetAddressStep companyAddressCrawlDto() {
            return new Builder();
        }

        @Override
        public StreetAddress2Step withStreetAddress(String streetAddress) {
            this.streetAddress = streetAddress;
            return this;
        }

        @Override
        public StreetAddress3Step withStreetAddress2(String streetAddress2) {
            this.streetAddress2 = streetAddress2;
            return this;
        }

        @Override
        public StreetAddress4Step withStreetAddress3(String streetAddress3) {
            this.streetAddress3 = streetAddress3;
            return this;
        }

        @Override
        public AddressTypeStep withStreetAddress4(String streetAddress4) {
            this.streetAddress4 = streetAddress4;
            return this;
        }

        @Override
        public LocalityStep withAddressType(String addressType) {
            this.addressType = addressType;
            return this;
        }

        @Override
        public DistrictStep withLocality(String locality) {
            this.locality = locality;
            return this;
        }

        @Override
        public CityStep withDistrict(String district) {
            this.district = district;
            return this;
        }

        @Override
        public StateStep withCity(String city) {
            this.city = city;
            return this;
        }

        @Override
        public CountryStep withState(String state) {
            this.state = state;
            return this;
        }

        @Override
        public PostalCodeStep withCountry(String country) {
            this.country = country;
            return this;
        }

        @Override
        public OfficeTypeStep withPostalCode(Long postalCode) {
            this.postalCode = postalCode;
            return this;
        }

        @Override
        public ActiveStatusStep withOfficeType(String officeType) {
            this.officeType = officeType;
            return this;
        }

        @Override
        public EstablishmentDateStep withActiveStatus(String activeStatus) {
            this.activeStatus = activeStatus;
            return this;
        }

        @Override
        public BuildStep withEstablishmentDate(String establishmentDate) {
            this.establishmentDate = establishmentDate;
            return this;
        }

        @Override
        public CompanyAddressCrawlDto build() {
            return new CompanyAddressCrawlDto(
                this.streetAddress,
                this.streetAddress2,
                this.streetAddress3,
                this.streetAddress4,
                this.addressType,
                this.locality,
                this.district,
                this.city,
                this.state,
                this.country,
                this.postalCode,
                this.officeType,
                this.activeStatus,
                this.establishmentDate
            );
        }
    }
}


package com.ofb.crawler.commons.types.mca.dto.task;

@Data
public class McaTaskParamsDto extends BaseTaskParamsDto {

    public McaTaskParamsDto() {
    }

    public McaTaskParamsDto(String requestId, String companyName, String cin, String gstIn) {
        super(requestId, companyName, cin, gstIn);
    }

    public static interface RequestIdStep {
        CompanyNameStep withRequestId(String requestId);
    }

    public static interface CompanyNameStep {
        CinStep withCompanyName(String companyName);
    }

    public static interface CinStep {
        GstInStep withCin(String cin);
    }

    public static interface GstInStep {
        BuildStep withGstIn(String gstIn);
    }

    public static interface BuildStep {
        McaTaskParamsDto build();
    }


    public static class Builder implements RequestIdStep, CompanyNameStep, CinStep, GstInStep, BuildStep {
        private String requestId;
        private String companyName;
        private String cin;
        private String gstIn;

        private Builder() {
        }

        public static RequestIdStep mcaTaskParamsDto() {
            return new Builder();
        }

        @Override
        public CompanyNameStep withRequestId(String requestId) {
            this.requestId = requestId;
            return this;
        }

        @Override
        public CinStep withCompanyName(String companyName) {
            this.companyName = companyName;
            return this;
        }

        @Override
        public GstInStep withCin(String cin) {
            this.cin = cin;
            return this;
        }

        @Override
        public BuildStep withGstIn(String gstIn) {
            this.gstIn = gstIn;
            return this;
        }

        @Override
        public McaTaskParamsDto build() {
            return new McaTaskParamsDto(
                    this.requestId,
                    this.companyName,
                    this.cin,
                    this.gstIn
            );
        }
    }
}


package com.ofb.crawler.core.util;

public class HttpAsyncClientUtils {

    private static final Logger logger = LoggerFactory.getLogger(HttpAsyncClientUtils.class);

    public static final int TIMEOUT_MILLIS = 30 * 1000;

    
    @Nullable
    public static String quietGet(TaskType taskType, String url) {
        return quietGet(taskType, url, TIMEOUT_MILLIS);
    }

    @Nullable
    public static String quietGet(TaskType taskType, String url, int timeout) {
        try {
            return get(taskType, url, timeout);
        } catch (IOException e) {
            logger.error("Unable to get Response from server", e);
        }
        return null;
    }

    public static String get(TaskType taskType, String url) throws IOException {
        return get(taskType, url, TIMEOUT_MILLIS);
    }

    public static String get(TaskType taskType, String url, int timeout) throws IOException {
        return get(taskType, url, new HashMap<>(), timeout);
    }

    public static String get(TaskType taskType, String url, Map<String, String> headers) throws IOException {
        return get(taskType, url, headers, TIMEOUT_MILLIS);
    }

    public static String get(TaskType taskType, String url, Map<String, String> headers, int timeout)
        throws IOException {
        CloseableHttpAsyncClient client = getClosableAsyncHttpClient(taskType);
        BufferedReader rd = null;
        try {
            
            HttpGet request = new HttpGet(url);
            if (MapUtils.isNotEmpty(headers)) {
                for (String key : headers.keySet()) {
                    request.setHeader(key, headers.get(key));
                }
            }

            RequestConfig requestConfig = RequestConfig.custom()
                .setSocketTimeout(timeout)
                .setConnectTimeout(timeout)
                .setConnectionRequestTimeout(timeout)
                .build();

            request.setConfig(requestConfig);

            
            Future<HttpResponse> responseFuture = null;
            responseFuture = client.execute(request, null);

            HttpResponse response = null;
            try {
                response = responseFuture.get();
            } catch (Exception e) {
                logger.info("Failed to get http response from future, Reason : {}", e.getMessage(), e);
                return null;
            }

            logger.debug("Response Code : [{}]", response.getStatusLine().getStatusCode());

            rd = new BufferedReader(
                new InputStreamReader(response.getEntity().getContent()));

            StringBuffer result = new StringBuffer();
            String line = "";
            while ((line = rd.readLine()) != null) {
                result.append(line);
            }
            try {
                rd.close();
            } catch (IOException e) {
                logger.info("Failed to close http input stream, Reason : {}", e.getMessage(), e);
            }
            return result.toString();
        } catch (Throwable tr) {
            logger.error("Exception occurred in HttpAsyncClientUtils for taskType {} and url {} , {}", taskType.name()
                , url, tr);
        } finally {
            
            IOUtils.closeQuietly(rd);
        }
        return null;
    }

    public static HttpResponse getHttpResponse(TaskType taskType, String url) throws IOException {
        return getHttpResponse(taskType, url, new HashMap<>());
    }

    public static HttpResponse getHttpResponse(TaskType taskType, String url, Map<String, String> headers) throws IOException {
        return getHttpResponse(taskType, url, headers,TIMEOUT_MILLIS);
    }

    public static HttpResponse getHttpResponse(TaskType taskType, String url, Map<String, String> headers,
        boolean useNewIp) throws IOException {
        return getHttpResponse(taskType, url, headers,TIMEOUT_MILLIS, useNewIp);
    }

    public static HttpResponse getHttpResponse(TaskType taskType, String url, Map<String, String> headers, int timeout)
        throws IOException {
        return getHttpResponse(taskType, url, headers, timeout, true);
    }

    public static HttpResponse getHttpResponse(TaskType taskType, String url, Map<String, String> headers, int timeout,
        boolean useNewIp)
        throws IOException {

        CloseableHttpAsyncClient client = getClosableAsyncHttpClient(taskType, useNewIp);
        return getHttpResponse(taskType, client, url, headers, timeout);
    }

    private static HttpResponse getHttpResponse(TaskType taskType, CloseableHttpAsyncClient client, String url, Map<String, String> headers, int timeout)
        throws IOException {
        try {
            
            HttpGet request = new HttpGet(url);
            if (MapUtils.isNotEmpty(headers)) {
                for (String key : headers.keySet()) {
                    request.setHeader(key, headers.get(key));
                }
            }

            RequestConfig requestConfig = RequestConfig.custom()
                .setSocketTimeout(timeout)
                .setConnectTimeout(timeout)
                .setConnectionRequestTimeout(timeout)
                .build();

            request.setConfig(requestConfig);

            Future<HttpResponse> responseFuture = null;
            responseFuture = client.execute(request, null);

            try {
                return responseFuture.get();
            } catch (Exception e) {
                logger.info("Failed to get http response from future, Reason : {}", e.getMessage(), e);
            }
        } catch (Throwable tr) {
            logger.error("Exception occurred in HttpAsyncClientUtils for taskType {} and url {} , {}", taskType.name()
                , url, tr);
        } finally {
            
        }
        return null;
    }

    public static HttpResponse getHttpResponseWithSpecifIp(TaskType taskType, String url, Map<String, String> headers, int timeout,
        RotationIp rotationIp)
        throws IOException {

        CloseableHttpAsyncClient client = getClosableAsyncHttpClientWithSpecificIp(taskType, rotationIp);
        if (client == null) {
            return null;
        }
        try {
            client.start();
            return getHttpResponse(taskType, client, url, headers, timeout);
        } catch (Exception e) {
            logger.error("Error in getHttpResponseWithSpecifIp", e);
            return null;
        } finally {
            client.close();
        }

    }

    public static Document getDocument(TaskType taskType, String url) throws IOException {
        return getDocument(taskType, url, new HashMap<>());
    }

    public static Document getDocument(TaskType taskType, String url, Map<String, String> headers) throws IOException {
        return getDocument(taskType, url, headers,TIMEOUT_MILLIS);
    }

    public static Document getDocument(TaskType taskType, String url, Map<String, String> headers, int timeout)
        throws IOException {
        HttpResponse httpResponse = getHttpResponse(taskType, url, headers, timeout);
        return getDocumentFromHttpResponse(httpResponse, url);
    }

    public static String quietPost(TaskType taskType, String url, Map<String, List<String>> formEntries,
        Map<String, String> headers) {
        return quietPost(taskType, url, formEntries, headers, TIMEOUT_MILLIS);
    }

    public static String quietPost(TaskType taskType, String url, Map<String, List<String>> formEntries,
        Map<String, String> headers, int timeout) {
        try {
            return post(taskType, url, formEntries, headers, timeout);
        } catch (IOException e) {
            logger.error("Unable to get Response from server", e);
        }
        return null;
    }

    public static String post(TaskType taskType, String url, Map<String, List<String>> formEntries,
        Map<String, String> headers) throws IOException {
        return post(taskType, url, formEntries, headers, TIMEOUT_MILLIS);
    }

    public static String post(TaskType taskType, String url, Map<String, List<String>> formEntries,
        Map<String, String> headers, int timeout) throws IOException {
        List<NameValuePair> urlParams = new ArrayList<>();
        for (String key : formEntries.keySet()) {
            StringBuilder valueSb = new StringBuilder();
            for (String value : formEntries.get(key)) {
                if (valueSb.length() != 0) {
                    valueSb.append("|");        
                }
                valueSb.append(value);
            }
            urlParams.add(new BasicNameValuePair(key, valueSb.toString()));
        }
        return post(taskType, url, urlParams, headers, timeout);
    }

    public static String post(TaskType taskType, String url, List<NameValuePair> nameValuePairs,
        Map<String, String> headers) throws IOException {
        return post(taskType, url, nameValuePairs, headers, TIMEOUT_MILLIS);
    }

    public static String post(TaskType taskType, String url, List<NameValuePair> nameValuePairs,
        Map<String, String> headers, int timeout) throws IOException {
        CloseableHttpAsyncClient client = getClosableAsyncHttpClient(taskType);
        BufferedReader rd = null;
        try {
            
            HttpPost post = new HttpPost(url);

            for (String key : headers.keySet()) {
                post.setHeader(key, headers.get(key));
            }

            RequestConfig requestConfig = RequestConfig.custom()
                .setSocketTimeout(timeout)
                .setConnectTimeout(timeout)
                .setConnectionRequestTimeout(timeout)
                .build();

            post.setConfig(requestConfig);

            post.setEntity(new UrlEncodedFormEntity(nameValuePairs));

            Future<HttpResponse> responseFuture = null;
            responseFuture = client.execute(post, null);

            HttpResponse response = null;
            try {
                response = responseFuture.get();
            } catch (Exception e) {
                logger.info("Failed to get http response from future, Reason : {}", e.getMessage(), e);
                return null;
            }

            rd = new BufferedReader(
                new InputStreamReader(response.getEntity().getContent()));

            StringBuffer result = new StringBuffer();
            String line = "";
            while ((line = rd.readLine()) != null) {
                result.append(line);
            }
            try {
                rd.close();
            } catch (IOException e) {
                logger.info("Failed to close http input stream, Reason : {}", e.getMessage(), e);
            }
            return result.toString();
        } catch (Throwable tr) {
            logger.error("Exception occurred in HttpAsyncClientUtils for taskType {} and url {} , {}", taskType.name()
                , url, tr);
        } finally {
            
            IOUtils.closeQuietly(rd);
        }
        return null;
    }

    public static Document postWithFormValuesAndGetDocument(TaskType taskType, String url,
        Map<String, String> formEntries,
        Map<String, String> headers) throws IOException {
        return postWithFormValuesAndGetDocument(taskType, url, formEntries, headers, true);
    }

    public static Document postWithFormValuesAndGetDocument(TaskType taskType, String url,
        Map<String, String> formEntries,
        Map<String, String> headers, boolean useNewIp) throws IOException {
        return postWithFormValuesAndGetDocument(taskType, url, formEntries, headers, TIMEOUT_MILLIS, useNewIp);
    }

    public static Document postWithFormValuesAndGetDocument(TaskType taskType, String url, Map<String, String> formEntries,
        Map<String, String> headers, int timeout, boolean useNewIp) throws IOException {
        List<NameValuePair> urlParams = new ArrayList<>();
        for (Map.Entry<String, String> entry : formEntries.entrySet()) {
            urlParams.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));
        }
        return postWithFormValuesAndGetDocument(taskType, url, urlParams, headers, useNewIp, timeout);
    }

    public static Document postWithFormValuesAndGetDocument(TaskType taskType, String url, List<NameValuePair> nameValuePairs,
        Map<String, String> headers, boolean useNewIp) throws IOException {
        return postWithFormValuesAndGetDocument(taskType, url, nameValuePairs, headers, useNewIp, TIMEOUT_MILLIS);
    }

    public static Document postWithFormValuesAndGetDocument(TaskType taskType, String url, List<NameValuePair> nameValuePairs,
        Map<String, String> headers, boolean useNewIp, int timeout) throws IOException {
        HttpResponse httpResponse =
            postWithFormValuesAndGetHttpResponse(taskType, url, nameValuePairs, headers, useNewIp, timeout);
        return getDocumentFromHttpResponse(httpResponse, url);
    }

    public static HttpResponse postWithFormValuesAndGetHttpResponse(TaskType taskType, String url,
        Map<String, String> formEntries,
        Map<String, String> headers) throws IOException {
        return postWithFormValuesAndGetHttpResponse(taskType, url, formEntries, headers, TIMEOUT_MILLIS);
    }

    public static HttpResponse postWithFormValuesAndGetHttpResponse(TaskType taskType, String url, Map<String, String> formEntries,
        Map<String, String> headers, int timeout) throws IOException {
        List<NameValuePair> urlParams = new ArrayList<>();
        for (Map.Entry<String, String> entry : formEntries.entrySet()) {
            urlParams.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));
        }
        return postWithFormValuesAndGetHttpResponse(taskType, url, urlParams, headers, timeout);
    }

    public static HttpResponse postWithFormValuesAndGetHttpResponse(TaskType taskType, String url, List<NameValuePair> nameValuePairs,
        Map<String, String> headers) throws IOException {
        return postWithFormValuesAndGetHttpResponse(taskType, url, nameValuePairs, headers, TIMEOUT_MILLIS);
    }

    public static HttpResponse postWithFormValuesAndGetHttpResponse(TaskType taskType, String url, List<NameValuePair> nameValuePairs,
        Map<String, String> headers, int timeout) throws IOException {
        return postWithFormValuesAndGetHttpResponse(taskType, url, nameValuePairs, headers, true, timeout);
    }

    public static HttpResponse postWithFormValuesAndGetHttpResponse(TaskType taskType, String url, List<NameValuePair> nameValuePairs,
        Map<String, String> headers, boolean useNewIp, int timeout) throws IOException {
        CloseableHttpAsyncClient client = getClosableAsyncHttpClient(taskType, useNewIp);
        try {
            
            HttpPost post = new HttpPost(url);

            for (String key : headers.keySet()) {
                post.setHeader(key, headers.get(key));
            }

            RequestConfig requestConfig = RequestConfig.custom()
                .setSocketTimeout(timeout)
                .setConnectTimeout(timeout)
                .setConnectionRequestTimeout(timeout)
                .build();

            post.setConfig(requestConfig);

            post.setEntity(new UrlEncodedFormEntity(nameValuePairs));

            Future<HttpResponse> responseFuture = null;
            responseFuture = client.execute(post, null);

            HttpResponse response = null;
            try {
                response = responseFuture.get();
            } catch (Exception e) {
                logger.info("Failed to get http response from future, Reason : {}", e.getMessage(), e);
            }

            return response;
        } catch (Throwable tr) {
            logger.error("Exception occurred in HttpAsyncClientUtils for taskType {} and url {} , {}", taskType.name()
                , url, tr);
        } finally {
            
        }
        return null;
    }

    public static String quietPost(String url, String json, Map<String, String> headers) {
        return quietPost(null, url, json, headers);
    }

    public static String quietPost(TaskType taskType, String url, String json, Map<String, String> headers) {
        return quietPost(taskType, url, json, headers, TIMEOUT_MILLIS);
    }

    public static String quietPost(TaskType taskType, String url, String json, Map<String, String> headers,
        int timeout) {
        try {
            return post(taskType, url, json, headers, timeout);
        } catch (IOException e) {
            logger.error("Unable to get Response from server", e);
        }
        return null;
    }

    public static String post(TaskType taskType, String url, String json, Map<String, String> headers)
        throws IOException {
        return post(taskType, url, json, headers, TIMEOUT_MILLIS);
    }

    public static String post(TaskType taskType, String url, String json, Map<String, String> headers, int timeout)
        throws IOException {
        return putOrPost(taskType, HttpMethod.POST, url, json, headers, timeout);
    }

    public static String post(TaskType taskType, String url, HttpEntity multiPartEntity,
        Map<String, String> headers, int timeout)
        throws IOException {
        return putOrPost(taskType, HttpMethod.POST, url, multiPartEntity, headers, timeout);
    }

    public static String post(TaskType taskType, String url, HttpEntity multiPartEntity,
        Map<String, String> headers, int timeout, boolean useNewIp)
        throws IOException {
        return putOrPost(taskType, HttpMethod.POST, url, multiPartEntity, headers, timeout, useNewIp);
    }

    public static HttpResponse postAndGetHttpResponse(TaskType taskType, String url, String json, Map<String, String> headers)
        throws IOException {
        return postAndGetHttpResponse(taskType, url, json, headers, TIMEOUT_MILLIS);
    }

    public static HttpResponse postAndGetHttpResponse(TaskType taskType, String url, String json,
        Map<String, String> headers,
        int timeout)
        throws IOException {
        return putOrPostAndGetHttpResponse(taskType, HttpMethod.POST, url, json, headers, timeout);
    }

    public static HttpResponse postAndGetHttpResponse(TaskType taskType, String url, HttpEntity multiPartEntity,
        Map<String, String> headers, int timeout)
        throws IOException {
        return postAndGetHttpResponse(taskType, url, multiPartEntity, headers, timeout, true);
    }

    public static HttpResponse postAndGetHttpResponse(TaskType taskType, String url, HttpEntity multiPartEntity,
        Map<String, String> headers, int timeout, boolean useNewIp)
        throws IOException {
        return putOrPostAndGetHttpResponse(taskType, HttpMethod.POST, url, multiPartEntity, headers, timeout, useNewIp);
    }

    public static Document postAndGetDocument(TaskType taskType, String url, String json,
        Map<String, String> headers)
        throws IOException {
        return postAndGetDocument(taskType, url, json, headers, TIMEOUT_MILLIS);
    }

    public static Document postAndGetDocument(TaskType taskType, String url, String json,
        Map<String, String> headers,
        int timeout)
        throws IOException {
        return putOrPostAndGetDocument(taskType, HttpMethod.POST, url, json, headers, timeout);
    }

    public static Document postAndGetDocument(TaskType taskType, String url, HttpEntity multiPartEntity,
        Map<String, String> headers, int timeout)
        throws IOException {
        return putOrPostAndGetDocument(taskType, HttpMethod.POST, url, multiPartEntity, headers, timeout);
    }

    public static String put(TaskType taskType, String url, String json, Map<String, String> headers, int timeout)
        throws IOException {
        return putOrPost(taskType, HttpMethod.PUT, url, json, headers, timeout);
    }

    private static String putOrPost(TaskType taskType, HttpMethod method, String url, String json, Map<String, String> headers, int timeout)
        throws IOException {

        HttpEntity httpEntity = new StringEntity(json, "UTF-8");
        return putOrPost(taskType, method, url, httpEntity, headers, timeout);
    }

    public static String patch(TaskType taskType, String url, String json, Map<String, String> headers)
        throws IOException {
        CloseableHttpAsyncClient client = getClosableAsyncHttpClient(taskType);
        BufferedReader rd = null;
        try {
            
            HttpPatch patch = new HttpPatch(url);

            if (!CollectionUtils.isEmpty(headers)) {
                for (String key : headers.keySet()) {
                    patch.setHeader(key, headers.get(key));
                }
            }

            patch.setEntity(new StringEntity(json, "UTF-8"));

            Future<HttpResponse> responseFuture = null;
            responseFuture = client.execute(patch, null);

            HttpResponse response = null;
            try {
                response = responseFuture.get();
            } catch (Exception e) {
                logger.info("Failed to get http response from future, Reason : {}", e.getMessage(), e);
                return null;
            }

            rd = new BufferedReader(
                new InputStreamReader(response.getEntity().getContent()));

            StringBuffer result = new StringBuffer();
            String line = "";
            while ((line = rd.readLine()) != null) {
                result.append(line);
            }
            try {
                rd.close();
            } catch (IOException e) {
                logger.info("Failed to close http input stream, Reason : {}", e.getMessage(), e);
            }
            return result.toString();
        } catch (Throwable tr) {
            logger.error("Exception occurred in HttpAsyncClientUtils for taskType {} and url {} , {}", taskType.name()
                , url, tr);
        } finally {
            
            IOUtils.closeQuietly(rd);
        }
        return null;
    }

    public static String postBytes(TaskType taskType, String url, byte[] body, Map<String, String> headers)
        throws IOException {
        return postBytes(taskType, url, body, headers, TIMEOUT_MILLIS);
    }

    public static String postBytes(TaskType taskType, String url, byte[] body, Map<String, String> headers,
        int timeout)
        throws IOException {
        CloseableHttpAsyncClient client = getClosableAsyncHttpClient(taskType);
        BufferedReader rd = null;
        try {
            
            HttpPost post = new HttpPost(url);

            for (String key : headers.keySet()) {
                post.setHeader(key, headers.get(key));
            }

            RequestConfig requestConfig = RequestConfig.custom()
                .setSocketTimeout(timeout)
                .setConnectTimeout(timeout)
                .setConnectionRequestTimeout(timeout)
                .build();

            post.setConfig(requestConfig);

            post.setEntity(new ByteArrayEntity(body));

            Future<HttpResponse> responseFuture = null;
            responseFuture = client.execute(post, null);

            HttpResponse response = null;
            try {
                response = responseFuture.get();
            } catch (Exception e) {
                logger.info("Failed to get http response from future, Reason : {}", e.getMessage(), e);
                return null;
            }

            rd = new BufferedReader(
                new InputStreamReader(response.getEntity().getContent()));

            StringBuffer result = new StringBuffer();
            String line = "";
            while ((line = rd.readLine()) != null) {
                result.append(line);
            }
            try {
                rd.close();
            } catch (IOException e) {
                logger.info("Failed to close http input stream, Reason : {}", e.getMessage(), e);
            }
            return result.toString();
        } catch (Throwable tr) {
            logger.error("Exception occurred in HttpAsyncClientUtils for taskType {} and url {} , {}", taskType.name()
                , url, tr);
        } finally {
            
            IOUtils.closeQuietly(rd);
        }
        return null;
    }

    public static String delete(TaskType taskType, String url, Map<String, String> headers) throws IOException {
        return delete(taskType, url, headers, TIMEOUT_MILLIS);
    }

    public static String delete(TaskType taskType, String url, Map<String, String> headers, int timeout)
        throws IOException {
        CloseableHttpAsyncClient client = getClosableAsyncHttpClient(taskType);
        BufferedReader rd = null;
        try {
            
            HttpDelete delete = new HttpDelete(url);

            for (String key : headers.keySet()) {
                delete.setHeader(key, headers.get(key));
            }

            RequestConfig requestConfig = RequestConfig.custom()
                .setSocketTimeout(timeout)
                .setConnectTimeout(timeout)
                .setConnectionRequestTimeout(timeout)
                .build();

            delete.setConfig(requestConfig);

            Future<HttpResponse> responseFuture = null;
            responseFuture = client.execute(delete, null);

            HttpResponse response = null;
            try {
                response = responseFuture.get();
            } catch (Exception e) {
                logger.info("Failed to get http response from future, Reason : {}", e.getMessage(), e);
                return null;
            }

            rd = new BufferedReader(
                new InputStreamReader(response.getEntity().getContent()));

            StringBuffer result = new StringBuffer();
            String line = "";
            while ((line = rd.readLine()) != null) {
                result.append(line);
            }
            try {
                rd.close();
            } catch (IOException e) {
                logger.info("Failed to close http input stream, Reason : {}", e.getMessage(), e);
            }
            return result.toString();
        } catch (Throwable tr) {
            logger.error("Exception occurred in HttpAsyncClientUtils for taskType {} and url {} , {}", taskType.name()
                , url, tr);
        } finally {
            
            IOUtils.closeQuietly(rd);
        }
        return null;
    }

    private static String putOrPost(TaskType taskType, HttpMethod method, String url, HttpEntity multiPartEntity,
        Map<String, String> headers, int timeout) throws IOException {
        return putOrPost(taskType, method, url, multiPartEntity, headers, timeout, true);

    }

    private static String putOrPost(TaskType taskType, HttpMethod method, String url, HttpEntity multiPartEntity,
        Map<String, String> headers, int timeout, boolean useNewIp) throws IOException {

        CloseableHttpAsyncClient client = getClosableAsyncHttpClient(taskType, useNewIp);
        return putOrPost(taskType, client, method, url, multiPartEntity, headers, timeout);
    }

    private static String putOrPost(TaskType taskType, CloseableHttpAsyncClient client, HttpMethod method, String url, HttpEntity multiPartEntity,
        Map<String, String> headers, int timeout) throws IOException {
        HttpEntityEnclosingRequestBase requestBase;

        if (method == HttpMethod.POST) {
            requestBase =  new HttpPost(url);
        } else if (method == HttpMethod.PUT) {
            requestBase = new HttpPut(url);
        } else {
            throw new IllegalArgumentException("Only put or post method are supported");
        }

        BufferedReader rd = null;
        try {
            

            if (!CollectionUtils.isEmpty(headers)) {
                for (String key : headers.keySet()) {
                    requestBase.setHeader(key, headers.get(key));
                }
            }

            RequestConfig requestConfig = RequestConfig.custom()
                .setSocketTimeout(timeout)
                .setConnectTimeout(timeout)
                .setConnectionRequestTimeout(timeout)
                .build();

            requestBase.setConfig(requestConfig);

            requestBase.setEntity(multiPartEntity);

            Future<HttpResponse> responseFuture = null;
            responseFuture = client.execute(requestBase, null);

            HttpResponse response = null;
            try {
                response = responseFuture.get();
            } catch (Exception e) {
                logger.info("Failed to get http response from future, Reason : {}", e.getMessage(), e);
                return null;
            }

            rd = new BufferedReader(
                new InputStreamReader(response.getEntity().getContent()));

            StringBuffer result = new StringBuffer();
            String line = "";
            while ((line = rd.readLine()) != null) {
                result.append(line);
            }
            try {
                rd.close();
            } catch (IOException e) {
                logger.info("Failed to close http input stream, Reason : {}", e.getMessage(), e);
            }
            return result.toString();
        } catch (Throwable tr) {
            logger.error("Exception occurred in HttpAsyncClientUtils for taskType {} and url {} , {}", taskType.name()
                , url, tr);
        } finally {
            
            IOUtils.closeQuietly(rd);
        }
        return null;
    }


    public static String putOrPostWithSpecificIp(TaskType taskType, HttpMethod method, String url, HttpEntity multiPartEntity,
        Map<String, String> headers, int timeout, RotationIp rotationIp) throws IOException {

        CloseableHttpAsyncClient client = getClosableAsyncHttpClientWithSpecificIp(taskType, rotationIp);
        if (client == null) {
            return null;
        }
        try {
            client.start();
            return putOrPost(taskType, client, method, url, multiPartEntity, headers, timeout);
        } catch (Exception e) {
            logger.error("Error in putOrPostWithSpecificIp", e);
            return null;
        } finally {
            client.close();
        }
    }

    public static HttpResponse putOrPostAndGetHttpResponse(TaskType taskType, HttpMethod method, String url, String json, Map<String, String> headers, int timeout)
        throws IOException {

        HttpEntity httpEntity = new StringEntity(json, "UTF-8");
        return putOrPostAndGetHttpResponse(taskType, method, url, httpEntity, headers, timeout);
    }

    private static HttpResponse putOrPostAndGetHttpResponse(TaskType taskType, HttpMethod method, String url, HttpEntity multiPartEntity,
        Map<String, String> headers, int timeout) throws IOException {
        return putOrPostAndGetHttpResponse(taskType, method, url, multiPartEntity, headers, timeout, true);
    }

    private static HttpResponse putOrPostAndGetHttpResponse(TaskType taskType, HttpMethod method, String url, HttpEntity multiPartEntity,
        Map<String, String> headers, int timeout, boolean useNewIp) throws IOException {
        CloseableHttpAsyncClient client = getClosableAsyncHttpClient(taskType, useNewIp);
        return putOrPostAndGetHttpResponse(taskType, client, method, url, multiPartEntity, headers, timeout);
    }

    private static HttpResponse putOrPostAndGetHttpResponse(TaskType taskType, CloseableHttpAsyncClient client, HttpMethod method, String url, HttpEntity multiPartEntity,
        Map<String, String> headers, int timeout) throws IOException {
        HttpEntityEnclosingRequestBase requestBase;

        if (method == HttpMethod.POST) {
            requestBase = new HttpPost(url);
        } else if (method == HttpMethod.PUT) {
            requestBase = new HttpPut(url);
        } else {
            throw new IllegalArgumentException("Only put or post method are supported");
        }

        try {
            

            if (!CollectionUtils.isEmpty(headers)) {
                for (String key : headers.keySet()) {
                    requestBase.setHeader(key, headers.get(key));
                }
            }

            RequestConfig requestConfig = RequestConfig.custom()
                .setSocketTimeout(timeout)
                .setConnectTimeout(timeout)
                .setConnectionRequestTimeout(timeout)
                .build();

            requestBase.setConfig(requestConfig);

            requestBase.setEntity(multiPartEntity);

            Future<HttpResponse> responseFuture = null;
            responseFuture = client.execute(requestBase, null);

            try {
                return responseFuture.get();
            } catch (Exception e) {
                logger.info("Failed to get http response from future, Reason : {}", e.getMessage(), e);
            }
        } catch (Throwable tr) {
            logger.error("Exception occurred in HttpAsyncClientUtils for taskType {} and url {} , {}", taskType.name()
                , url, tr);
        } finally {
            
        }
        return null;
    }


    public static HttpResponse putOrPostAndGetHttpResponseWithSpecificIp(TaskType taskType, HttpMethod method, String url, HttpEntity multiPartEntity,
        Map<String, String> headers, int timeout, RotationIp rotationIp) throws IOException {

        CloseableHttpAsyncClient client = getClosableAsyncHttpClientWithSpecificIp(taskType, rotationIp);
        if (client == null) {
            return null;
        }
        try {
            client.start();
            return putOrPostAndGetHttpResponse(taskType, client, method, url, multiPartEntity, headers, timeout);
        } catch (Exception e) {
            logger.error("Error in putOrPostAndGetHttpResponseWithSpecificIp", e);
            return null;
        } finally {
            client.close();
        }
    }

    public static Document putOrPostAndGetDocument(TaskType taskType, HttpMethod method, String url, String json, Map<String, String> headers, int timeout)
        throws IOException {

        HttpEntity httpEntity = new StringEntity(json, "UTF-8");
        return putOrPostAndGetDocument(taskType, method, url, httpEntity, headers, timeout);
    }

    private static Document putOrPostAndGetDocument(TaskType taskType, HttpMethod method, String url,
        HttpEntity multiPartEntity,
        Map<String, String> headers, int timeout) throws IOException {

        HttpResponse httpResponse =
            putOrPostAndGetHttpResponse(taskType, method, url, multiPartEntity, headers, timeout);

        return getDocumentFromHttpResponse(httpResponse, url);
    }

    
    public static String unsafeGet(TaskType taskType, String url, Map<String, String> headers, int timeout)
        throws IOException, NoSuchAlgorithmException, KeyStoreException, KeyManagementException {
        CloseableHttpAsyncClient client = IpRotationUtil.getUnsafeClosableAsyncClient(taskType);
        try {
            HttpGet request = new HttpGet(url);
            if (MapUtils.isNotEmpty(headers)) {
                for (String key : headers.keySet()) {
                    request.setHeader(key, headers.get(key));
                }
            }

            RequestConfig requestConfig = RequestConfig.custom()
                .setSocketTimeout(timeout)
                .setConnectTimeout(timeout)
                .setConnectionRequestTimeout(timeout)
                .build();

            request.setConfig(requestConfig);

            Future<HttpResponse> responseFuture = null;
            responseFuture = client.execute(request, null);

            HttpResponse response = responseFuture.get();
            return getStringResponse(response);
        } catch (Exception e) {
            logger.info("Failed to get http response, Reason : {}", e.getMessage(), e);
            return null;
        }
    }
    
    public static String postUnsafeRequest(TaskType taskType, String url, Map<String, String> headers, int timeout)
        throws NoSuchAlgorithmException, KeyStoreException, KeyManagementException, IOException {
        return postUnsafeRequestWithForm(taskType, url, headers, null, timeout);
    }

    
    public static String postUnsafeRequestWithForm(TaskType taskType, String url, Map<String, String> headers, List<NameValuePair> formParams, int timeout)
        throws NoSuchAlgorithmException, KeyStoreException, KeyManagementException, IOException {
        CloseableHttpAsyncClient client = IpRotationUtil.getUnsafeClosableAsyncClient(taskType);
        BufferedReader rd = null;
        try {
            
            HttpPost httpPost = new HttpPost(url);
            
            if (formParams != null) {
                httpPost.setEntity(new UrlEncodedFormEntity(formParams));
            }
            Future<HttpResponse> responseFuture = null;
            responseFuture = client.execute(httpPost, null);

            HttpResponse response = null;
            try {
                response = responseFuture.get();
                logger.debug("Response Code : [{}]", response.getStatusLine().getStatusCode());
            } catch (Exception e) {
                logger.info("Failed to get http response from future, Reason : {}", e.getMessage(), e);
                return null;
            }

            rd = new BufferedReader(
                new InputStreamReader(response.getEntity().getContent()));

            StringBuffer result = new StringBuffer();
            String line = "";
            while ((line = rd.readLine()) != null) {
                result.append(line);
            }
            try {
                rd.close();
            } catch (IOException e) {
                logger.info("Failed to close http input stream, Reason : {}", e.getMessage(), e);
            }
            return result.toString();
        } catch (Exception e) {
            logger.debug(MessageFormat.format("Exception occurred in HttpAsyncClientUtil for tasktype {0}", taskType.name()), e);
            return null;
        } finally {
            
            IOUtils.closeQuietly(rd);
        }
    }
}

package com.ofb.crawler.commons.types.gstToPan.dto.task;


@Data
@NoArgsConstructor
public class PanToGstTaskResponseDto extends BaseTaskResponseDto {

    private PanToGstElementDto panToGstElementDto;


}


package com.ofb.crawler.core.types.litigation.eDistrictCourt.service;

@Service
public class EDistrictCourtParserCallback extends BaseParserCallback<EDistrictCourtDetailDto, EDistrictCourtTaskParamsDto> {

    private static final Logger logger = LoggerFactory.getLogger(
        EDistrictCourtParserCallback.class);

    private static final String CSRF_MAGIC_TOKEN_URL = "https:

    private static final String CAPTCHA_URL = "https:

    
    private static final String DIST_BASE_URL = "https:
    private static final String COMPLEX_BASE_URL = "https:
    private static final String ESTABLISHMENT_BASE_URL = "https:

    private static final String SEARCH_URL = "https:

    private static final String DETAIL_URL = "https:

    private static final String UI_SEARCH_URL= "https:

    private static final String DATE_FORMAT = "dd-MM-yyyy";

    private static final String DATE_FORMAT_ddMMMMyyyy = "dd MMMM yyyy";

    private static final String CAPTCHA_SERVER_END_POINT = "/e-dist-court/captcha";

    private static Map<String, List<DistrictOption>> stateCodeToDistrictOptionListMap =
        new LinkedHashMap<>();

    private static Map<String, List<CourtOption>> stateDistrictCodeToCourtOptionListMap =
        new LinkedHashMap<>();

    private static Map<String, List<EstablishmentOption>> stateDistrictComplexCodeToEstablishmentOptionListMap =
        new LinkedHashMap<>();

    private static long TIME_BETWEEN_SESSION_REFRESH = 0L;

    private static long lastSessionRefreshAt = 0L;

    public void resetVariables() {
        synchronized (this) {
            stateCodeToDistrictOptionListMap = new LinkedHashMap<>();
            stateDistrictCodeToCourtOptionListMap = new LinkedHashMap<>();
            stateDistrictComplexCodeToEstablishmentOptionListMap = new LinkedHashMap<>();
        }
    }

    @Override public TaskType getTaskType() {
        return TaskType.LITIGATION_E_DISTRICT_COURT;
    }

    @Override public EDistrictCourtDetailDto parse(EDistrictCourtTaskParamsDto parsingParams) throws Throwable {
        return parseEDistrictCourt(parsingParams);
    }

    private static EDistrictCourtDetailDto parseEDistrictCourt(EDistrictCourtTaskParamsDto parsingParams) throws Throwable {
        String organisationName = parsingParams.getCompanyName();
        int year = 2023;
        if (parsingParams.getFromTime() != null && parsingParams.getFromTime() > 0) {
            int yearProvided = new DateTime(parsingParams.getFromTime()).getYear();
            if (yearProvided > year) {
                year = yearProvided;
            }
        }

        List<EDistrictCourtParsedResult> eDistrictCourtParsedResults = parseByPartyName(organisationName, year);

        return EDistrictCourtDetailDto.Builder.eDistrictCourtDetailDto()
            .withParsingId(String.valueOf(UUID.randomUUID()))
            .withTaskType(TaskType.LITIGATION_E_DISTRICT_COURT)
            .withParsingTime(System.currentTimeMillis())
            .withBaseTaskParamsDto(null)
            .withEDistrictCourtCases(eDistrictCourtParsedResults)
            .withBaseTaskParamsDtoWithDateRange(parsingParams)
            .build();
    }

    public static List<EDistrictCourtParsedResult> parseByPartyName(String partyName, int startYear) throws Exception {
        logger.info("Parsing case status for {}", partyName);
        String sanitizePartyName = LitigationUtils.sanitizeSearchName(partyName);
        if (startYear < 2018) {
            startYear = 2018;
        }
        int endYear = new DateTime().getYear();
        List<EDistrictCourtParsedResult> allCases = new ArrayList<>();
        Map<String, String> variableMap = getVariables();
        for (int year = startYear; year <= endYear; year++) {
            for (StateLegalEntity stateLegalEntity : StateLegalEntity.getAllStateSet()) {
                List<EDistrictCourtParsedResult> callableList = searchForState(variableMap,
                    stateLegalEntity,
                    sanitizePartyName, partyName, year);
                if (ObjectUtils.isNotBlankObject(callableList)) {
                    allCases.addAll(callableList);
                }
            }
        }
        return allCases;
    }

    private static List<EDistrictCourtParsedResult> searchForState(Map<String, String> variableMap,
        StateLegalEntity stateLegalEntity,
        String partyName,
        String originalPartyName,
        int year) {
        List<EDistrictCourtParsedResult> finalCallableListListForState = new ArrayList<>();
        if (StringUtils.isBlank(partyName)) {
            return finalCallableListListForState;
        }
        
        if (ObjectUtils.isBlankObject(variableMap)) {
            logger.info("Unable to get Variables while parsing E District Court, skipping the parsing");
            return finalCallableListListForState;
        }

        List<DistrictOption> districtOptions = getDistrictOption(variableMap, stateLegalEntity.getStateCode());
        if (ObjectUtils.isNotBlankObject(districtOptions)) {
            for (DistrictOption districtOption : districtOptions) {
                
                
                
                List<EDistrictCourtParsedResult> callableListForDistrict =
                    searchForDistrict(variableMap, stateLegalEntity,
                    districtOption, partyName, originalPartyName, year);
                if (ObjectUtils.isNotBlankObject(callableListForDistrict)) {
                    finalCallableListListForState.addAll(callableListForDistrict);
                }
            }
        }
        return finalCallableListListForState;
    }

    private static List<EDistrictCourtParsedResult> searchForDistrict(Map<String, String> variableMap,
        StateLegalEntity stateLegalEntity,
        DistrictOption districtOption,
        String partyName,
        String originalPartyName,
        int year) {
        List<EDistrictCourtParsedResult> callableListForCourt = new ArrayList<>();

        
        if (ObjectUtils.isBlankObject(variableMap)) {
            logger.info("Unable to get Variables while parsing E District Court, skipping the parsing");
            return callableListForCourt;
        }
        List<CourtOption> courtOptions = getCourtOption(variableMap, stateLegalEntity.getStateCode(),
            districtOption.getDistrictCode());
        if (ObjectUtils.isNotBlankObject(courtOptions)) {
            for (CourtOption courtOption : courtOptions) {
                List<EDistrictCourtParsedResult> callableList =
                    searchForEstablishment(variableMap, stateLegalEntity, districtOption, courtOption,
                        partyName, originalPartyName, year);
                if (ObjectUtils.isNotBlankObject(callableList)) {
                    callableListForCourt.addAll(callableList);
                }
            }
        }
        return callableListForCourt;
    }

    private static List<EDistrictCourtParsedResult> searchForEstablishment(Map<String, String> variableMap,
        StateLegalEntity stateLegalEntity,
        DistrictOption districtOption,
        CourtOption courtOption,
        String partyName,
        String originalPartyName,
        int year) {
        List<EDistrictCourtParsedResult> callableListForCourt = new ArrayList<>();

        
        if (ObjectUtils.isBlankObject(variableMap)) {
            logger.info("Unable to get Variables while parsing E District Court, skipping the parsing");
            return callableListForCourt;
        }
        if (courtOption.getEstablishmentRequired()) {
            List<EstablishmentOption> establishmentOptions = getEstablishmentOption(variableMap, stateLegalEntity.getStateCode(),
                districtOption.getDistrictCode(), courtOption.getCourtComplexCode());
            if (ObjectUtils.isNotBlankObject(establishmentOptions)) {
                for (EstablishmentOption establishmentOption : establishmentOptions) {
                    List<EDistrictCourtParsedResult> eDistrictCourtParsedResults =
                        searchForCourt(variableMap, stateLegalEntity, districtOption,
                            courtOption,
                            establishmentOption, partyName, originalPartyName, year);
                    if (ObjectUtils.isNotBlankObject(eDistrictCourtParsedResults)) {
                        callableListForCourt.addAll(eDistrictCourtParsedResults);
                    }
                }
            }
        } else {
            List<EDistrictCourtParsedResult> eDistrictCourtParsedResults =
                searchForCourt(variableMap, stateLegalEntity, districtOption, courtOption,
                    null, partyName, originalPartyName, year);
            if (ObjectUtils.isNotBlankObject(eDistrictCourtParsedResults)) {
                callableListForCourt.addAll(eDistrictCourtParsedResults);
            }
        }

        return callableListForCourt;
    }

    private static List<EDistrictCourtParsedResult> searchForCourt(Map<String, String> variableMap,
        StateLegalEntity stateLegalEntity,
        DistrictOption districtOption,
        CourtOption courtOption,
        EstablishmentOption establishmentOption,
        String partyName,
        String originalPartyName,
        int year) {
        List<EDistrictCourtParsedResult> eDistrictCourtParsedResultList = new ArrayList<>();
        
        if (ObjectUtils.isBlankObject(variableMap)) {
            logger.info("Unable to get Variables while parsing E District Court, skipping the parsing");
            return eDistrictCourtParsedResultList;
        }
        try {
            logger.info("Searching for partyName : [{}],  stateLegalEntity : [{}], district : [{}]," +
                    " court : [{}]", partyName, stateLegalEntity.name(), districtOption.getDistrictName(),
                courtOption.getCourtComplexName());
            eDistrictCourtParsedResultList = search(stateLegalEntity, partyName, originalPartyName, year, districtOption, courtOption,
                establishmentOption, variableMap);
        } catch (Exception e) {
            logger.error("search failed for district court for partyName : [{}],  state : [{}], district : [{}]," +
                    " court : [{}], {}", partyName, stateLegalEntity.name(), districtOption.getDistrictName(),
                courtOption.getCourtComplexName(), e);
        }
        logger.info("Found [{}] cases for partyName : [{}],  stateLegalEntity : [{}], district : [{}]," +
                " court : [{}]", eDistrictCourtParsedResultList.size(), partyName,
            stateLegalEntity.name(), districtOption.getDistrictName(), courtOption.getCourtComplexName());
        return eDistrictCourtParsedResultList;
    }

    private static List<EDistrictCourtParsedResult> search(StateLegalEntity stateLegalEntity,
        String partyName,
        String originalPartyName,
        int year,
        DistrictOption districtOption,
        CourtOption courtOption,
        EstablishmentOption establishmentOption, Map<String, String> variableMap) throws Exception {
        List<EDistrictCourtParsedResult> eDistrictCourtCaseDetailsList = new ArrayList<>();

        variableMap.putAll(getVariables());
        Map<String, String> formParams = new HashMap<>();
        HashMap<String, String> headers = new HashMap<>();
        for (int searchRetryCount = 0; searchRetryCount < 10; searchRetryCount++) {
            String captcha = getCaptcha(variableMap);
            if (StringUtils.isBlank(captcha) || captcha.length() != 6) {
                continue;
            }
            try {
                formParams.clear();
                formParams.put("app_token", variableMap.get("csrfMagicToken"));
                formParams.put("state_code", stateLegalEntity.getStateCode());
                formParams.put("dist_code", districtOption.getDistrictCode());
                formParams.put("court_complex_code", courtOption.getCourtComplexCode());
                if (establishmentOption != null) {
                    formParams.put("est_code", establishmentOption.getEstablishmentCode());
                } else {
                    formParams.put("est_code", "");
                }
                formParams.put("case_status", "Both");
                formParams.put("petres_name", partyName);
                formParams.put("rgyearP", year + "");
                formParams.put("fcaptcha_code", captcha.toLowerCase());
                formParams.put("ajax_req", "true");
                headers = getSessionIdHeaders(variableMap);
                headers.put("Content-Type", "application/x-www-form-urlencoded");
                Document response = postResponseDocument(SEARCH_URL, headers, formParams, variableMap, false);
                headers = null;
                boolean shouldRefreshVariableMap = false;
                long now = System.currentTimeMillis();
                if ((now - lastSessionRefreshAt) > TIME_BETWEEN_SESSION_REFRESH) {
                    shouldRefreshVariableMap = true;
                }
                if (shouldRefreshVariableMap) {
                    variableMap.putAll(getVariables());
                }
                if (ObjectUtils.isBlankObject(response)) {
                    continue;
                }
                String responseString = response.select("body").html();
                if (StringUtils.isBlank(responseString)) {
                    continue;
                }
                if (responseString.contains("Invalid Captcha") ||
                    responseString.contains("captcha tampering")) {
                    continue;
                }
                if ((responseString.contains("Record not found"))) {
                    break;
                }
                if (responseString.contains("Connection to server failed try after some time")) {
                    
                    break;
                }
                Element tableElement = response.getElementById("titlehid");
                if (tableElement == null) {
                    break;
                }

                Elements tableRecords = tableElement.select("tbody > tr");
                if (ObjectUtils.isBlankObject(tableRecords)) {
                    break;
                }

                List<EDistrictCourtCaseListCrawlDto> eDistCourtCaseListCrawlDtos = new ArrayList<>();
                for (Element tableRecord : tableRecords) {
                    String petResFlag = tableRecord.select("td:eq(2)").text();
                    if (ObjectUtils.isBlank(petResFlag) || !petResFlag.contains("Vs")) {
                        continue;
                    }

                    String[] vs = petResFlag.split("Vs");
                    String pet = sanitizeString(vs[0]);
                    String resp = sanitizeString(vs[1]);

                    String caseInfoString = tableRecord.select("td:eq(3)").select("a").attr("onclick");
                    String caseNum = "";
                    String cnrNum = "";
                    String courtCode = "";
                    if (ObjectUtils.isNotBlank(caseInfoString)) {
                        String extractedString = null;
                        String pattern = "viewHistory\\((.*?)\\)";
                        
                        Pattern regex = Pattern.compile(pattern);
                        
                        Matcher matcher = regex.matcher(caseInfoString);
                        
                        
                        if (matcher.find()) {
                            
                            extractedString = matcher.group(1);
                        }

                        if (ObjectUtils.isNotBlank(extractedString)) {
                            String[] split = extractedString.split(",");
                            if (split.length >= 3) {
                                caseNum = split[0];
                                cnrNum = sanitizeString(split[1]);
                                courtCode = sanitizeString(split[2]);
                            }
                        }
                    }

                    eDistCourtCaseListCrawlDtos.add(EDistrictCourtCaseListCrawlDto.Builder.eDistrictCourtCaseListCrawlDto()
                        .withCnrNumber(cnrNum)
                        .withCaseNumber(caseNum)
                        .withCourtCode(courtCode)
                        .withPetitionerName(pet)
                        .withRespondentName(resp)
                        .build());
                }

                if (ObjectUtils.isNotBlankObject(eDistCourtCaseListCrawlDtos)) {
                    List<EDistrictCourtParsedResult> eDistrictCourtParsedResultList = new ArrayList<>();
                    for (EDistrictCourtCaseListCrawlDto eDistrictCourtCaseListCrawlDto : eDistCourtCaseListCrawlDtos) {
                        if (LitigationUtils.isPartyExists(partyName,
                            eDistrictCourtCaseListCrawlDto.getPetitionerName(),
                            eDistrictCourtCaseListCrawlDto.getRespondentName())) {
                            EDistrictCourtCaseDetailCrawlDto eDistrictCourtCaseDetailCrawlDto = getDetail(variableMap,
                                eDistrictCourtCaseListCrawlDto.getCaseNumber(),
                                eDistrictCourtCaseListCrawlDto.getCnrNumber(),
                                stateLegalEntity, districtOption,
                                courtOption, eDistrictCourtCaseListCrawlDto.getCourtCode());
                            if (eDistrictCourtCaseDetailCrawlDto != null) {
                                EDistrictCourtParsedResult eDistrictCourtCaseDetails = convert(eDistrictCourtCaseDetailCrawlDto,
                                    partyName,
                                    originalPartyName,
                                    eDistrictCourtCaseListCrawlDto.getCaseNumber(),
                                    eDistrictCourtCaseListCrawlDto.getCnrNumber(),
                                    stateLegalEntity, districtOption, courtOption, establishmentOption);
                                eDistrictCourtParsedResultList.add(eDistrictCourtCaseDetails);
                            }
                        }
                    }
                    return eDistrictCourtParsedResultList;
                }
            } catch (Throwable throwable) {
                logger.error(
                    "error while searching for partyName : [{}] and stateCode : [{}] and districtCode : [{}], "
                        + "courtComplexCode : [{}], {}",
                    partyName, stateLegalEntity.getStateCode(),
                    districtOption.getDistrictCode(), courtOption.getCourtComplexCode(),
                    throwable);
            }
            break;
        }
        return eDistrictCourtCaseDetailsList;
    }

    private static String getCaptcha(Map<String, String> variableMap) throws Exception {
        
        
        long now = System.currentTimeMillis();
        if ((now - lastSessionRefreshAt) < TIME_BETWEEN_SESSION_REFRESH) {
            Thread.sleep(TIME_BETWEEN_SESSION_REFRESH - (now - lastSessionRefreshAt));
        }
        String captcha = CaptchaServer.solveCaptcha(TaskType.LITIGATION_E_DISTRICT_COURT, CAPTCHA_URL, getSessionIdHeaders(variableMap),
            CAPTCHA_SERVER_END_POINT, false);

        
        return captcha;
    }

    private static EDistrictCourtCaseDetailCrawlDto getDetail(Map<String, String> variableMap,
        String caseNumber,
        String cnrNumber,
        StateLegalEntity stateLegalEntity, DistrictOption districtOption, CourtOption courtOption,
        String courtCodeOption) {

        HashMap<String, String> headers = new HashMap<>();
        Map<String, String> formParams = new HashMap<>();
        for (int tryCount = 0; tryCount < 5; tryCount++) {
            try {
                formParams.clear();
                formParams.put("app_token", variableMap.get("csrfMagicToken"));
                formParams.put("court_code", courtCodeOption);
                formParams.put("state_code", stateLegalEntity.getStateCode());
                formParams.put("dist_code", districtOption.getDistrictCode());
                formParams.put("court_complex_code", courtOption.getCourtComplexCode());
                formParams.put("case_no", caseNumber);
                formParams.put("cino", cnrNumber);
                formParams.put("ajax_req", "true");
                formParams.put("search_flag", "CScaseNumber");
                formParams.put("search_by", "CSpartyName");
                headers = getSessionIdHeaders(variableMap);
                headers.put("Content-Type", "application/x-www-form-urlencoded");
                Document response = postResponseDocument(DETAIL_URL, headers, formParams, variableMap);
                headers = null;
                if (response == null) {
                    continue;
                }
                if (response.text().contains("Invalid") || response.text().contains("Oops")) {
                    String app_token = ObjectUtils.objectMapper()
                        .readValue(response.text(), new TypeReference<HashMap<String, String>>() {
                        }).get("app_token");
                    if (ObjectUtils.isNotBlank(app_token)) {
                        variableMap.put("csrfMagicToken", app_token);
                    }
                    continue;
                }
                return parseResponseDetails(response);
            } catch (Throwable throwable) {
                logger.error("error while getting details for caseNumber : [{}] and cnrNumber : [{}], {}",
                    caseNumber, cnrNumber, throwable);
            }
        }
        return null;
    }

    private static EDistrictCourtCaseDetailCrawlDto parseResponseDetails(Document document) {
        Elements caseDetailsTable = document.getElementsContainingOwnText("Case Details");
        if (caseDetailsTable == null) {
            return null;
        }
        String title = sanitizeString(document.getElementById("chHeading").text());
        
        
        String caseType = sanitizeString(
            caseDetailsTable.select("tbody > tr:nth-child(1) > td:nth-child(2)").first());
        String filingNumber = sanitizeString(
            caseDetailsTable.select("tbody > tr:nth-child(2) > td:nth-child(2)").first());
        String filingDate = sanitizeString(
            caseDetailsTable.select("tbody > tr:nth-child(2) > td:nth-child(4)").first());
        String registrationNumber = sanitizeString(
            caseDetailsTable.select("tbody > tr:nth-child(3) > td:nth-child(2)").first());
        String registrationDate = sanitizeString(
            caseDetailsTable.select("tbody > tr:nth-child(3) > td:nth-child(4)").first());


        String firstHearingDate =
            removeOrdinals(sanitizeString(caseDetailsTable.select("table").first().select("tbody > tr > td").get(14)));
        String nextHearingDate =
            removeOrdinals(sanitizeString(caseDetailsTable.select("table").first().select("tbody > tr > td").get(16)));

        String caseStage = null;
        if (caseDetailsTable.select("table").first().select("tbody > tr > td").size() > 28) {
            caseStage =
                removeOrdinals(sanitizeString(caseDetailsTable.select("table").first().select("tbody > tr > td").get(28)));
        }

        String decisionDate = null;
        CaseStatus caseStatus = CaseStatus.PENDING;
        if (ObjectUtils.isNotBlank(caseStage) && caseStage.contains("disposed")) {
            decisionDate = nextHearingDate;
            nextHearingDate = null;
            caseStatus = CaseStatus.DISPOSED;
        }
        
        

        Set<String> petitionerNames = new HashSet<>();
        String petitionerAdvocate = null;
        Element petitionerAndAdvocateInfoTable =
            document.getElementsByClass("Petitioner_Advocate_table").first();
        if (petitionerAndAdvocateInfoTable != null) {
            Element petitionerAndAdvocateInfo =
                petitionerAndAdvocateInfoTable.select("tbody > tr > td").first();
            for (Node childNode : petitionerAndAdvocateInfo.childNodes()) {
                if (!(childNode instanceof TextNode)) {
                    continue;
                }
                String normalizeSpace = StringUtils.normalizeSpace(
                    ((TextNode) childNode).text());
                if (StringUtils.isBlank(normalizeSpace)) {
                    continue;
                }
                normalizeSpace = sanitizeString(normalizeSpace);
                if (normalizeSpace.contains("Advocate")) {
                    petitionerAdvocate =
                        StringUtils.normalizeSpace(
                            normalizeSpace.replaceAll("Advocate", "")
                                .replaceAll("[^a-zA-Z ]+", ""));
                    petitionerAdvocate = sanitizeString(petitionerAdvocate);
                } else {
                    String partyName =
                        StringUtils.normalizeSpace(
                            normalizeSpace.replaceAll("M/S", "").replaceAll("[^a-zA-Z ]+", ""));
                    if (StringUtils.isNotBlank(partyName)) {
                        partyName = sanitizeString(partyName);
                        if (partyName.contains("tbodyn")) {
                            continue;
                        }
                        petitionerNames.add(partyName);
                    }
                }
            }
        }

        Set<String> respondentNames = new HashSet<>();
        String respondentAdvocate = null;
        Element respondentAndAdvocateInfoTable =
            document.getElementsByClass("Respondent_Advocate_table").first();
        if (respondentAndAdvocateInfoTable != null) {
            Element respondentAndAdvocateInfo =
                respondentAndAdvocateInfoTable.select("tbody > tr > td").first();
            for (Node childNode : respondentAndAdvocateInfo.childNodes()) {
                if (!(childNode instanceof TextNode)) {
                    continue;
                }
                String normalizeSpace = StringUtils.normalizeSpace(
                    ((TextNode) childNode).text());
                normalizeSpace = sanitizeString(normalizeSpace);
                if (StringUtils.isBlank(normalizeSpace)) {
                    continue;
                }
                if (normalizeSpace.contains("Advocate")) {
                    respondentAdvocate =
                        StringUtils.normalizeSpace(
                            normalizeSpace.replaceAll("Advocate", "")
                                .replaceAll("[^a-zA-Z ]+", ""));
                    respondentAdvocate = sanitizeString(respondentAdvocate);
                } else {
                    String partyName =
                        StringUtils.normalizeSpace(
                            normalizeSpace.replaceAll("M/S", "").replaceAll("[^a-zA-Z ]+", ""));
                    if (StringUtils.isNotBlank(partyName)) {
                        partyName = sanitizeString(partyName);
                        respondentNames.add(partyName);
                    }
                }
            }
        }

        Elements historyAndOrderTable =
            document.getElementsContainingOwnText("Case History").select("table > tbody");

        List<EDistrictCourtOrderHistory> orderHistories = new ArrayList<>();
        if (historyAndOrderTable != null && historyAndOrderTable.size() >= 2) {
            Elements orderTable = historyAndOrderTable.get(1).select("tr");
            for (Element element : orderTable.select("tr")) {
                String text = sanitizeString(element.select("td:eq(0)").text());
                if ("Order Number".equalsIgnoreCase(text)) {
                    continue;
                }

                String documentUrlStr = element.select("td:eq(2)").select("a").attr("onclick");
                String url = "";
                if (ObjectUtils.isNotBlank(documentUrlStr)) {
                    String extractedString = null;
                    String pattern = "displayPdf\\((.*?)\\)";
                    
                    Pattern regex = Pattern.compile(pattern);
                    
                    Matcher matcher = regex.matcher(documentUrlStr);
                    
                    
                    if (matcher.find()) {
                        
                        extractedString = matcher.group(1);
                    }

                    if (ObjectUtils.isNotBlank(extractedString)) {
                        extractedString = sanitizeString(extractedString);
                        url = CSRF_MAGIC_TOKEN_URL + "?p=" + extractedString;
                    }
                }

                Long orderDate = getTimeSilently(sanitizeString(element.select(" td:eq(1) ").text()),
                    "dd-MM-yyyy");
                if (orderDate == null) {
                    continue;
                }

                orderHistories.add(EDistrictCourtOrderHistory.Builder.eHighCourtOrderHistory()
                    .withJudge(null)
                    .withOrderDate(orderDate)
                    .withOrderUrl(url)
                    .build());
            }
        }

        Map<Long, Set<String>> orderDateToUrlMap = new HashMap<>();
        if (ObjectUtils.isNotBlankObject(orderHistories)) {
            for (EDistrictCourtOrderHistory orderHistory : orderHistories) {
                Long orderDate = orderHistory.getOrderDate();
                if (orderDate == null && ObjectUtils.isNotBlank(orderHistory.getOrderUrl())) {
                    continue;
                }
                Set<String> orderUrls = orderDateToUrlMap.getOrDefault(orderDate, new HashSet<>());
                orderUrls.add(orderHistory.getOrderUrl());
                orderDateToUrlMap.put(orderDate, orderUrls);
            }
        }

        List<EDistrictCourtHearingHistory> hearingHistories = new ArrayList<>();
        if (historyAndOrderTable != null && historyAndOrderTable.size() >= 1) {
            Elements historyTable = historyAndOrderTable.get(0).select("tr");
            for (Element element : historyTable.select("tr")) {
                String text = sanitizeString(element.select("td:eq(0)").text());
                if ("Judge".equalsIgnoreCase(text)) {
                    continue;
                }
                if ("Order Number".equalsIgnoreCase(text)) {
                    break;
                }
                Long hearingDate = getTimeSilently(sanitizeString(element.select(" td:eq(2) ").text()),
                    "dd-MM-yyyy");
                Long businessOnDate = getTimeSilently(sanitizeString(element.select(" td:eq(1) ").text()),
                    "dd-MM-yyyy");
                Set<String> orderUrls = new HashSet<>();
                if (businessOnDate != null) {
                    orderUrls = orderDateToUrlMap.getOrDefault(businessOnDate, Collections.emptySet());
                }
                if (orderUrls.size() > 1) {
                    for (String orderUrl : orderUrls) {
                        hearingHistories.add(EDistrictCourtHearingHistory.Builder.eDistrictCourtHearingHistory()
                            .withCauseListType(null)
                            .withJudge(sanitizeString(element.select("td:eq(1)").text()))
                            .withBusinessOnDate(businessOnDate)
                            .withHearingDate(hearingDate)
                            .withPurposeOfHearing(sanitizeString(element.select("td:eq(3)").text()))
                            .withOrderUrl(orderUrl)
                            .build());
                    }
                    continue;
                }

                String orderUrl = null;
                if (orderUrls.size() == 1) {
                    orderUrl = orderUrls.iterator().next();
                }
                hearingHistories.add(EDistrictCourtHearingHistory.Builder.eDistrictCourtHearingHistory()
                    .withCauseListType(null)
                    .withJudge(sanitizeString(element.select("td:eq(1)").text()))
                    .withBusinessOnDate(businessOnDate)
                    .withHearingDate(hearingDate)
                    .withPurposeOfHearing(sanitizeString(element.select("td:eq(3)").text()))
                    .withOrderUrl(orderUrl)
                    .build());
            }
        }


        EDistrictCourtCaseDetailCrawlDto eDistrictCourtCaseDetailCrawlDto =
            EDistrictCourtCaseDetailCrawlDto.Builder.eDistrictCourtCaseDetailCrawlDto()
                .withTitle(title)
                .withFilingNumber(filingNumber)
                .withFilingDate(filingDate)
                .withRegistrationNumber(registrationNumber)
                .withRegistrationDate(registrationDate)
                .withLastListed(getTimeSilently(decisionDate, DATE_FORMAT_ddMMMMyyyy))
                .withNextListingDate(getTimeSilently(nextHearingDate, DATE_FORMAT_ddMMMMyyyy))
                .withFirstHearingDate(getTimeSilently(firstHearingDate, DATE_FORMAT_ddMMMMyyyy))
                .withCaseStage(caseStage)
                .withPetitionerNames(petitionerNames)
                .withPetitionerAdvocates(petitionerAdvocate)
                .withRespondentNames(respondentNames)
                .withRespondentAdvocates(respondentAdvocate)
                .withHearingHistories(hearingHistories)
                .withOrderHistories(orderHistories)
                .build();
        return eDistrictCourtCaseDetailCrawlDto;
    }

    public static String removeOrdinals(String date) {
        if (ObjectUtils.isBlank(date)) {
            return "";
        }
        
        String modifiedDate = date.replaceAll("(st|nd|rd|th)", "");
        return modifiedDate;
    }

    private static String sanitizeString(Element element) {
        if (element == null) {
            return "";
        }
        return sanitizeString(element.text());
    }

    private static String sanitizeString(String text) {
        if (ObjectUtils.isBlank(text)) {
            return "";
        }

        text = text.replaceAll("<\\\\\\/br>", "")
            .replaceAll("<\\\\\\/td>", "")
            .replaceAll("<\\\\\\/tr>", "")
            .replaceAll("<\\\\\\/tbody>", "")
            .replaceAll("<\\\\\\/table>", "")
            .replaceAll("\\\\n", "")
            .replaceAll("\\\\t", "")
            .replaceAll("<\\\\\\/strong>", "")
            .replaceAll("<\\\\\\/label>", "")
            .replaceAll("<\\\\\\/font>", "")
            .replaceAll("<\\\\\\/h2>", "")
            .replaceAll("\\\\", "")
            .replaceAll("'", "").trim();

        if (ObjectUtils.isBlank(text)) {
            return "";
        }

        int index = 0;
        for (int i = 0; i < text.length(); i++) {
            char c = text.charAt(i);
            if (!Character.isSpaceChar(c)) {
                index = i;
                break;
            }
        }
        return text.substring(index);
    }

    private static Map<String, String> getVariables() {
        return getVariables(1);
    }

    private static Map<String, String> getVariables(int tryCount) {
        Map<String, String> variableMap = new HashMap<>();
        if (tryCount > 3) {
            return variableMap;
        }
        try {
            
            
            
            
            HttpResponse response =
                HttpAsyncClientUtils.getHttpResponse(TaskType.LITIGATION_E_DISTRICT_COURT, CSRF_MAGIC_TOKEN_URL);

            lastSessionRefreshAt = System.currentTimeMillis();

            Header[] headers = response.getHeaders("Set-Cookie");
            String sessionId = null;
            for (int i = 0; i < headers.length; i++) {
                String[] cookies = headers[i].getValue().split(";");
                if (ObjectUtils.isBlankObject(cookies)) {
                    continue;
                }
                for (String cookie : cookies) {
                    if (cookie.contains("PHPSESSID")) {
                        sessionId = cookie.split("=")[1].trim();
                    }
                }
            }

            if (ObjectUtils.isBlank(sessionId)) {
                return getVariables(tryCount + 1);
            }

            variableMap.put("sessionId", sessionId);

            String rawHome = HttpUtils.getStringResponse(response);
            String csrfMagicTokenKey = "app_token=";
            if (rawHome.contains(csrfMagicTokenKey)) {
                int convIdStartIndex = rawHome.indexOf(csrfMagicTokenKey) + csrfMagicTokenKey.length();
                int convIdEndIndex = rawHome.indexOf(">", convIdStartIndex);
                String csrfMagicToken = rawHome.substring(convIdStartIndex, convIdEndIndex);
                csrfMagicToken = csrfMagicToken.replace("\"", "");
                variableMap.put("csrfMagicToken", csrfMagicToken);
            }
        } catch (Exception e) {
            logger.error("Error while parsing E Dist Court in getting variables {}", e);
            
            
            
            
            
            return getVariables(tryCount + 1);
        }
        return variableMap;
    }

    private static List<DistrictOption> getDistrictOption(Map<String, String> variableMap,
        String stateCode) {
        List<DistrictOption> districtOptions = new ArrayList<>();
        districtOptions = stateCodeToDistrictOptionListMap.get(stateCode);
        if (ObjectUtils.isNotBlankObject(districtOptions)) {
            return districtOptions;
        }
        try {
            Map<String, String> formParams = new HashMap<>();
            formParams.put("app_token", variableMap.get("csrfMagicToken"));
            
            formParams.put("state_code", stateCode);
            
            
            formParams.put("ajax_req", "true");
            HashMap<String, String> headers = getSessionIdHeaders(variableMap);
            headers.put("Content-Type", "application/x-www-form-urlencoded");
            Document response = postResponseDocument(DIST_BASE_URL , headers, formParams, variableMap);
            Elements elements = response.select("body > option");
            formParams = null;
            headers = null;

            districtOptions = new ArrayList<>();
            if (ObjectUtils.isBlankObject(elements)) {
                return districtOptions;
            }
            for (Element districtValue : elements) {
                if (districtValue.text().toLowerCase().contains("select district")) {
                    continue;
                }
                districtOptions.add(
                    DistrictOption.Builder.districtOption()
                        .withDistrictCode(districtValue.val())
                        .withDistrictName(districtValue.text().substring(0, districtValue.text().indexOf("<")))
                        .build()
                );
            }
            stateCodeToDistrictOptionListMap.put(stateCode, districtOptions);
        } catch (Throwable throwable) {
            logger.error(
                "error while getting district options for stateCode : [{}], {}", stateCode, throwable);
        }
        return districtOptions;
    }

    private static List<CourtOption> getCourtOption(Map<String, String> variableMap, String stateCode,
        String districtCode) {
        List<CourtOption> courtOptions = new ArrayList<>();
        courtOptions = stateDistrictCodeToCourtOptionListMap.get(stateCode + "-" + districtCode);
        if (CollectionUtils.isNotEmpty(courtOptions)) {
            return courtOptions;
        }
        try {
            HashMap<String, String> formParams = new HashMap<>();
            formParams.put("app_token", variableMap.get("csrfMagicToken"));
            formParams.put("state_code", stateCode);
            formParams.put("dist_code", districtCode);
            HashMap<String, String> headers = getSessionIdHeaders(variableMap);
            headers.put("Content-Type", "application/x-www-form-urlencoded");
            Document response = postResponseDocument(COMPLEX_BASE_URL, headers, formParams, variableMap);
            formParams = null;
            headers = null;
            if (response == null) {
                return courtOptions;
            }
            Elements responseElements = response.select("body > option");
            courtOptions = new ArrayList<>();
            if (responseElements == null) {
                return courtOptions;
            }
            for (Element element : responseElements) {
                if (element.text().toLowerCase().contains("select court complex")) {
                    continue;
                }
                try {
                    String[] courtValueSplit = element.val().split("@");
                    String estReqStr = courtValueSplit[2];
                    boolean estRequired = ObjectUtils.isNotBlank(estReqStr) && ("Y" .equalsIgnoreCase(estReqStr)
                        || "YES" .equalsIgnoreCase(estReqStr));
                    courtOptions.add(
                        CourtOption.Builder.courtOption()
                            .withCourtCode(null)
                            .withCourtComplexCode(courtValueSplit[0])
                            .withCourtComplexName(element.text().substring(0, element.text().indexOf("<")))
                            .withEstablishmentRequired(estRequired)
                            .build()
                    );
                } catch (Exception e) {
                    logger.error("Cannot get court Options for stateCode:[{}], districtCode:[{}], {}", stateCode,
                        districtCode, e);
                }
            }
            stateDistrictCodeToCourtOptionListMap.put(stateCode + "-" + districtCode, courtOptions);
        } catch (Throwable throwable) {
            logger.error(
                "error while getting court options for stateCode : [{}], districtCode : [{}], {}",
                stateCode, districtCode, throwable);
        }
        return courtOptions;
    }

    private static List<EstablishmentOption> getEstablishmentOption(Map<String, String> variableMap, String stateCode,
        String districtCode, String complexCode) {
        List<EstablishmentOption> establishmentOptions = new ArrayList<>();
        establishmentOptions = stateDistrictComplexCodeToEstablishmentOptionListMap.get(stateCode + "-" + districtCode + "-" + complexCode);
        if (CollectionUtils.isNotEmpty(establishmentOptions)) {
            return establishmentOptions;
        }
        try {
            HashMap<String, String> formParams = new HashMap<>();
            formParams.put("app_token", variableMap.get("csrfMagicToken"));
            formParams.put("state_code", stateCode);
            formParams.put("dist_code", districtCode);
            formParams.put("court_complex_code", complexCode);
            HashMap<String, String> headers = getSessionIdHeaders(variableMap);
            headers.put("Content-Type", "application/x-www-form-urlencoded");
            Document response = postResponseDocument(ESTABLISHMENT_BASE_URL, headers,
                formParams, variableMap);
            formParams = null;
            headers = null;
            if (response == null) {
                return establishmentOptions;
            }
            Elements responseElements = response.select("body > option");
            establishmentOptions = new ArrayList<>();
            if (responseElements == null) {
                return establishmentOptions;
            }
            for (Element element : responseElements) {
                if (element.text().toLowerCase().contains("select court establishment")) {
                    continue;
                }
                try {
                    String[] courtValueSplit = element.val().split("@");
                    establishmentOptions.add(
                        EstablishmentOption.Builder.establishmentOption()
                            .withEstablishmentCode(courtValueSplit[0])
                            .withEstablishmentName(element.text().substring(0, element.text().indexOf("<")))
                            .build()
                    );
                } catch (Exception e) {
                    logger.error("Cannot get court Options for stateCode:[{}], districtCode:[{}], {}", stateCode,
                        districtCode, e);
                }
            }
            stateDistrictComplexCodeToEstablishmentOptionListMap.put(stateCode + "-" + districtCode + "-" + complexCode, establishmentOptions);
        } catch (Throwable throwable) {
            logger.error(
                "error while getting court options for stateCode : [{}], districtCode : [{}], {}",
                stateCode, districtCode, throwable);
        }
        return establishmentOptions;
    }

    private static Map<String, String> getCookies(Map<String, String> variableMap) {
        String sessionId = variableMap.get("sessionId");
        Map<String, String> cookies = new HashMap<>();
        if (org.apache.commons.lang3.StringUtils.isNotBlank(sessionId)) {
            cookies.put("PHPSESSID", sessionId);
        }
        return cookies;
    }

    private static HashMap<String, String> getSessionIdHeaders(Map<String, String> variableMap) {
        String sessionId = variableMap.get("sessionId");
        HashMap<String, String> headers = new HashMap<>();
        headers.put("Referer", "https:
        if (StringUtils.isNotBlank(sessionId)) {
            String cookieValue = "PHPSESSID=" + sessionId;
            headers.put(HttpHeaders.COOKIE, cookieValue);
        }
        return headers;
    }

    private static EDistrictCourtParsedResult convert(EDistrictCourtCaseDetailCrawlDto eDistrictCourtCaseDetailCrawlDto,
        String partyName, String originalPartyName, String caseNumber, String cnrNumber, StateLegalEntity stateLegalEntity,
        DistrictOption districtOption, CourtOption courtOption, EstablishmentOption establishmentOption) throws ParseException {
        if (eDistrictCourtCaseDetailCrawlDto == null) {
            return null;
        }
        Date filingDate = DateUtils.parse(DATE_FORMAT, eDistrictCourtCaseDetailCrawlDto.getFilingDate());
        Date registrationDate = DateUtils.parse(DATE_FORMAT, eDistrictCourtCaseDetailCrawlDto.getRegistrationDate());
        EDistrictCourtParsedResult eCourtCaseDetails =
            EDistrictCourtParsedResult.Builder.eDistrictCourtParsedResult()
                .withPartyName(partyName)
                .withCourtId(stateLegalEntity.getStateCode() + "-" + districtOption.getDistrictCode())
                .withCaseNo(caseNumber)
                .withCnrNumber(cnrNumber)
                .withFilingDate(ObjectUtils.isNotBlankObject(filingDate) ? filingDate.getTime() : null)
                .withStatus(eDistrictCourtCaseDetailCrawlDto.getCaseStage())
                .withLastListed(eDistrictCourtCaseDetailCrawlDto.getLastListed())
                .withNextListingDate(eDistrictCourtCaseDetailCrawlDto.getNextListingDate())
                .withPetitioners(eDistrictCourtCaseDetailCrawlDto.getPetitionerNames())
                .withPetAdvocates(eDistrictCourtCaseDetailCrawlDto.getPetitionerAdvocates())
                .withRespondents(eDistrictCourtCaseDetailCrawlDto.getRespondentNames())
                .withResAdvocates(eDistrictCourtCaseDetailCrawlDto.getRespondentAdvocates())
                .withRegisteredOn(ObjectUtils.isNotBlankObject(registrationDate) ? registrationDate.getTime() : null)
                .withCaseStatus(CaseStatus.fromString(eDistrictCourtCaseDetailCrawlDto.getCaseStage()))
                .withCaseStatusString(eDistrictCourtCaseDetailCrawlDto.getCaseStage())
                .withStateCourtName(ObjectUtils.isNotBlankObject(stateLegalEntity) ? stateLegalEntity.name() : null)
                .withDistrictBenchName(
                    ObjectUtils.isNotBlankObject(districtOption) ? districtOption.getDistrictName() : null)
                .withCourtComplexName(
                    ObjectUtils.isNotBlankObject(courtOption) ? courtOption.getCourtComplexName() : null)
                .withEstablishmentName(ObjectUtils.isNotBlankObject(establishmentOption) ? establishmentOption.getEstablishmentName() :
                    null)
                .withTitle(eDistrictCourtCaseDetailCrawlDto.getTitle())
                .withMatchedWith(null)
                .withSystemAssignedStatus(SystemAssignedStatus.PENDING)
                .withPartyInvolvement(PartyInvolvement.UNKNOWN)
                .withHearingHistories(eDistrictCourtCaseDetailCrawlDto.getHearingHistories())
                .withOrderHistories(eDistrictCourtCaseDetailCrawlDto.getOrderHistories())
                .withSearchUrl(UI_SEARCH_URL)
                .build();
        InvolvementAndMatchDto
            involvementAndMatchDto = LitigationUtils.getPartyInvolvementAndMatchingStatus(originalPartyName, eCourtCaseDetails.getPetitioners(), eCourtCaseDetails.getRespondents());
        eCourtCaseDetails.setPartyInvolvement(involvementAndMatchDto.getPartyInvolvement());
        eCourtCaseDetails.setMatchedWith(involvementAndMatchDto.getMatchedWith());
        eCourtCaseDetails.setSystemAssignedStatus(involvementAndMatchDto.getSystemAssignedStatus());
        return eCourtCaseDetails;
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    private static Document postResponseDocument(String url, HashMap<String, String> headers, Map<String, String>
        formParams, Map<String, String> variableMap) {
        return postResponseDocument(url, headers, formParams, variableMap, true);
    }

    private static Document postResponseDocument(String url, HashMap<String, String> headers, Map<String, String>
        formParams, Map<String, String> variableMap, boolean useNewIp) {
        return postResponseDocument(url, headers, formParams, variableMap, useNewIp, 1);
    }

    private static Document postResponseDocument(String url, HashMap<String, String> headers, Map<String, String>
        formParams, Map<String, String> variableMap, boolean useNewIp, int tryCount) {
        if (tryCount > 3) {
            return null;
        }
        Document response = null;
        try {
            boolean shouldRefreshVariableMap = false;
            long now = System.currentTimeMillis();
            if (useNewIp && ((now - lastSessionRefreshAt) > TIME_BETWEEN_SESSION_REFRESH)) {
                shouldRefreshVariableMap = true;
            }
            if (shouldRefreshVariableMap) {
                variableMap.putAll(getVariables());
                headers.putAll(getSessionIdHeaders(variableMap));
                formParams.put("app_token", variableMap.get("csrfMagicToken"));
            }
            response =
                HttpAsyncClientUtils.postWithFormValuesAndGetDocument(TaskType.LITIGATION_E_DISTRICT_COURT, url,
                    formParams, headers, false);
            if (useNewIp) {
                lastSessionRefreshAt = System.currentTimeMillis();
            }
        } catch (Exception e) { 
            logger.error("Error while parsing E Dist Court in getting post response {}", e);
            
            
            
            
            
            variableMap.putAll(getVariables());
            return postResponseDocument(url, headers, formParams, variableMap, useNewIp, tryCount+1);
        }
        return response;
    }

    public static void main(String[] args) throws Exception {
        Long startTime = System.currentTimeMillis();
        String partyName = "Reliance";
        List<EDistrictCourtParsedResult> eDistrictCourtParsedResultList = parseByPartyName(partyName, new DateTime().getYear());
        Long fetchTime = System.currentTimeMillis() - startTime;
        System.out.println("Finished in: " + fetchTime);
        Set<EDistrictCourtParsedResult> eDistrictCourtParsedResultListFiltered = eDistrictCourtParsedResultList.stream()
            .filter(ObjectUtils::isNotBlankObject).collect(Collectors.toSet());
    }
}


package com.ofb.crawler.commons.types.gstInfo.dto.response;

public class GstAddress {

    private GstAddressFields additionalPlaceOfBusinessAddress;

    private String natureOfAdditionalPlaceOfBusiness;

    public GstAddress() {
    }

    public GstAddress(GstAddressFields additionalPlaceOfBusinessAddress,
                      String natureOfAdditionalPlaceOfBusiness) {
        this.additionalPlaceOfBusinessAddress = additionalPlaceOfBusinessAddress;
        this.natureOfAdditionalPlaceOfBusiness = natureOfAdditionalPlaceOfBusiness;
    }

    public GstAddressFields getAdditionalPlaceOfBusinessAddress() {
        return additionalPlaceOfBusinessAddress;
    }

    public void setAdditionalPlaceOfBusinessAddress(GstAddressFields additionalPlaceOfBusinessAddress) {
        this.additionalPlaceOfBusinessAddress = additionalPlaceOfBusinessAddress;
    }

    public String getNatureOfAdditionalPlaceOfBusiness() {
        return natureOfAdditionalPlaceOfBusiness;
    }

    public void setNatureOfAdditionalPlaceOfBusiness(String natureOfAdditionalPlaceOfBusiness) {
        this.natureOfAdditionalPlaceOfBusiness = natureOfAdditionalPlaceOfBusiness;
    }

    public static interface AdditionalPlaceOfBusinessAddressStep {
        NatureOfAdditionalPlaceOfBusinessStep withAdditionalPlaceOfBusinessAddress(
                GstAddressFields additionalPlaceOfBusinessAddress);
    }

    public static interface NatureOfAdditionalPlaceOfBusinessStep {
        BuildStep withNatureOfAdditionalPlaceOfBusiness(String natureOfAdditionalPlaceOfBusiness);
    }

    public static interface BuildStep {
        GstAddress build();
    }

    public static class Builder
            implements AdditionalPlaceOfBusinessAddressStep, NatureOfAdditionalPlaceOfBusinessStep, BuildStep {
        private GstAddressFields additionalPlaceOfBusinessAddress;
        private String natureOfAdditionalPlaceOfBusiness;

        private Builder() {
        }

        public static AdditionalPlaceOfBusinessAddressStep gstAddressInfo() {
            return new Builder();
        }

        @Override
        public NatureOfAdditionalPlaceOfBusinessStep withAdditionalPlaceOfBusinessAddress(
                GstAddressFields additionalPlaceOfBusinessAddress) {
            this.additionalPlaceOfBusinessAddress = additionalPlaceOfBusinessAddress;
            return this;
        }

        @Override
        public BuildStep withNatureOfAdditionalPlaceOfBusiness(String natureOfAdditionalPlaceOfBusiness) {
            this.natureOfAdditionalPlaceOfBusiness = natureOfAdditionalPlaceOfBusiness;
            return this;
        }

        @Override
        public GstAddress build() {
            return new GstAddress(
                    this.additionalPlaceOfBusinessAddress,
                    this.natureOfAdditionalPlaceOfBusiness
            );
        }
    }
}


package com.ofb.crawler.commons.types.gstReturn.dto.parsing;

@Data
@NoArgsConstructor
public class GstReturnParsingResponseDto extends BaseParsingResponseDto {

    private GstReturnResponseDto gstReturnResponseDto;

    public GstReturnParsingResponseDto(GstReturnResponseDto gstReturnResponseDto) {
        this.gstReturnResponseDto = gstReturnResponseDto;
    }

    public GstReturnParsingResponseDto(String parsingId, String requestId, TaskType taskType, long parsingTime, GstReturnResponseDto gstReturnResponseDto) {
        super(parsingId, requestId, taskType, parsingTime);
        this.gstReturnResponseDto = gstReturnResponseDto;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        GstReturnParsingResponseDto that = (GstReturnParsingResponseDto) o;
        return Objects.equals(gstReturnResponseDto, that.gstReturnResponseDto);
    }

    @Override
    public int hashCode() {
        return Objects.hash(gstReturnResponseDto);
    }

    public static interface ParsingIdStep {
        RequestIdStep withParsingId(String parsingId);
    }

    public static interface RequestIdStep {
        TaskTypeStep withRequestId(String requestId);
    }

    public static interface TaskTypeStep {
        ParsingTimeStep withTaskType(TaskType taskType);
    }

    public static interface ParsingTimeStep {
        GstReturnResponseDtoStep withParsingTime(long parsingTime);
    }

    public static interface GstReturnResponseDtoStep {
        BuildStep withGstReturnResponseDto(GstReturnResponseDto gstReturnResponseDto);
    }

    public static interface BuildStep {
        GstReturnParsingResponseDto build();
    }


    public static class Builder implements ParsingIdStep, RequestIdStep, TaskTypeStep, ParsingTimeStep, GstReturnResponseDtoStep, BuildStep {
        private String parsingId;
        private String requestId;
        private TaskType taskType;
        private long parsingTime;
        private GstReturnResponseDto gstReturnResponseDto;

        private Builder() {
        }

        public static ParsingIdStep gstReturnParsingResponseDto() {
            return new Builder();
        }

        @Override
        public RequestIdStep withParsingId(String parsingId) {
            this.parsingId = parsingId;
            return this;
        }

        @Override
        public TaskTypeStep withRequestId(String requestId) {
            this.requestId = requestId;
            return this;
        }

        @Override
        public ParsingTimeStep withTaskType(TaskType taskType) {
            this.taskType = taskType;
            return this;
        }

        @Override
        public GstReturnResponseDtoStep withParsingTime(long parsingTime) {
            this.parsingTime = parsingTime;
            return this;
        }

        @Override
        public BuildStep withGstReturnResponseDto(GstReturnResponseDto gstReturnResponseDto) {
            this.gstReturnResponseDto = gstReturnResponseDto;
            return this;
        }

        @Override
        public GstReturnParsingResponseDto build() {
            return new GstReturnParsingResponseDto(
                    this.parsingId,
                    this.requestId,
                    this.taskType,
                    this.parsingTime,
                    this.gstReturnResponseDto
            );
        }
    }
}


package com.ofb.crawler.commons.types.gstToPan.dto.parsing;

public class PanToGstParsingDto extends BaseParsingDto {
}


package com.ofb.crawler.commons.util;

public class DateToLongDeserializer extends JsonDeserializer<Long> implements ContextualDeserializer {

    private SimpleDateFormat dateFormat;

    public DateToLongDeserializer() {
    }

    public DateToLongDeserializer(String dateFormat) {
        this.dateFormat = new SimpleDateFormat(dateFormat);
    }

    @Override
    public Long deserialize(JsonParser p, DeserializationContext ctxt)
        throws IOException, JsonProcessingException {
        String date = p.getText();
        if (ObjectUtils.isBlank(date)) {
            return null;
        }
        if (isLong(date)) {
            return Long.valueOf(date);
        }
        if (date.contains(" ") && !dateFormat.toPattern().contains(" ")) {
            date = date.split(" ")[0];
        }
        try {
            return dateFormat.parse(date).getTime();
        } catch (ParseException e) {
            throw new RuntimeException(e);
        }
    }

    public JsonDeserializer<?> createContextual(DeserializationContext var1, BeanProperty property) throws JsonMappingException {
        JsonDateToLong annotation = property.getAnnotation(JsonDateToLong.class);
        if (annotation != null) {
            return new DateToLongDeserializer(annotation.format());
        }
        return this;
    }

    public static boolean isLong(String str) {
        if (str == null || str.isEmpty()) {
            return false;
        }
        String regex = "^-?\\d+$";
        return str.matches(regex);
    }
}



package com.ofb.crawler.core.types.epfo.service;

@Service
public class EpfoParserCallback extends BaseParserCallback<EpfoDetailDto, EpfoTaskParamsDto> {

    private static final Logger logger = LoggerFactory.getLogger(EpfoParserCallback.class);

    private static final String URL_BASE = "https:

    private static final String HOME_URL = "https:

    private static final String REQUEST = "XMLHttpRequest";

    private static final String CONTENT_TYPE = "application/json; charset=UTF-8";

    private static final String CAPTCHA_SERVER_END_POINT = "/epf/captcha";

    @Override public TaskType getTaskType() {
        return TaskType.EPFO;
    }

    @Override public EpfoDetailDto parse(EpfoTaskParamsDto parsingParams) throws Throwable {
        return parseEpfo(parsingParams);
    }

    public static EpfoDetailDto parseEpfo(EpfoTaskParamsDto parsingParams) throws Throwable {
        String organisationName = parsingParams.getCompanyName();
        List<String[]> data = new ArrayList<>();
        HttpResponse response = null;
        try {
            response = HttpAsyncClientUtils.getHttpResponse(TaskType.EPFO, HOME_URL);
        } catch (IOException e) {
            logger.error("EpfoParserCallback, {}", e);
            throw new RequestParsingException(MessageFormat.format("Unable to post search request, {0}",
                e.getMessage()), TaskError.SERVER_DOWN);
        }

        if (response == null) {
            throw new RequestParsingException("Unable to post search request", TaskError.SERVER_DOWN);
        }

        Header[] headers = response.getHeaders("Set-Cookie");
        StringBuilder cookies = new StringBuilder();
        for (int i = 0; i < headers.length; i++) {
            cookies.append(headers[i].getValue().split(";")[0]);
            if(i!=cookies.length()-1){
                cookies.append("; ");
            }
        }

        Document doc = HttpUtils.getDocumentFromHttpResponse(response, HOME_URL);
        Elements info1 = doc.select("img#capImg");
        String url_end = String.valueOf(info1);
        String captcha_url = URL_BASE + url_end.substring(url_end.indexOf("/"), url_end.lastIndexOf(">") - 1);
        String captcha = "";
        Map<String, List<EpfoEstablishmentActionInfoDto>> establishmentDataResponseMap = new HashMap<>();
        boolean captcha_broken = false;
        for (int i = 0; i < 5; i++) {
            captcha = solveCaptcha(TaskType.EPFO, captcha_url, getHeaders(cookies.toString()),
                CAPTCHA_SERVER_END_POINT);
            
            Elements info2 = doc.select("input#searchEmployer");
            String search_url = String.valueOf(info2);
            search_url = URL_BASE + search_url.substring(search_url.indexOf("/"), search_url.lastIndexOf("'"));
            logger.info("Parsing for " + organisationName);
            establishmentDataResponseMap = getEstablishment(search_url, captcha, cookies.toString(), organisationName);
            if (establishmentDataResponseMap != null && establishmentDataResponseMap.containsKey("SUCCESS")) {
                captcha_broken = true;
                break;
            } else {
                continue;
            }
        }
        if (!captcha_broken) {
            logger.warn("error getting captcha for " + organisationName);
            throw new RequestParsingException("Unable to break captcha", TaskError.UNABLE_TO_BREAK_CAPTCHA);
        }
        List<EpfoEstablishmentActionInfoDto> establishmentDataList = establishmentDataResponseMap.get("SUCCESS");
        if (ObjectUtils.isBlankObject(establishmentDataList)) {
            logger.warn("No establishments found for " + organisationName);
            return EpfoDetailDto.Builder.epfoDetailDto()
                .withParsingId(String.valueOf(UUID.randomUUID()))
                .withTaskType(TaskType.EPFO)
                .withParsingTime(System.currentTimeMillis())
                .withBaseTaskParamsDto(null)
                .withEstablishmentDetailList(Collections.emptyList())
                .withEpfoTaskParamsDto(parsingParams)
                .build();
        }
        List<EpfoEstablishmentDetailDto> epfoEstablishmentDetailDtos = new ArrayList<>();
        for (EpfoEstablishmentActionInfoDto epfoEstablishmentInfo : establishmentDataList) {
            String establishmentId = epfoEstablishmentInfo.getEstablishmentId();
            String payment_url = null;
            if (ObjectUtils.isNotBlank(epfoEstablishmentInfo.getActionUrl())) {
                payment_url = getPaymentURL(URL_BASE + epfoEstablishmentInfo.getActionUrl(), establishmentId, cookies.toString());
            }
            List<EpfoPaymentDetailDto> paymentDetailDtos = new ArrayList<>();
            EpfoCinInfoDto epfoCinInfoDto = null;
            if (ObjectUtils.isNotBlank(epfoEstablishmentInfo.getCinInfoUrl())) {
                epfoCinInfoDto = getCompanyCinInfo(URL_BASE + epfoEstablishmentInfo.getCinInfoUrl(), establishmentId,
                    cookies.toString());
            }
            MatchingType matchingType = getCinAndPanMatchingStatus(epfoCinInfoDto, parsingParams);
            SystemAssignedStatus systemAssignedStatus =
                getNameMatchStatus(parsingParams.getCompanyName(),
                    epfoEstablishmentInfo.getName());
            if (matchingType == MatchingType.CIN_MATCHED || matchingType == MatchingType.PAN_MATCHED) {
                systemAssignedStatus = SystemAssignedStatus.MATCHED;
            }
            if (!isDataValid(matchingType, systemAssignedStatus, parsingParams)) {
                continue;
            }
            if (ObjectUtils.isNotBlank(payment_url)) {
                paymentDetailDtos = getData(URL_BASE + payment_url, cookies.toString());
            }

            String status = null;
            if (ObjectUtils.isNotBlank(epfoEstablishmentInfo.getStatusInfoUrl())) {
                status = getEstablishmentStatus(URL_BASE + epfoEstablishmentInfo.getStatusInfoUrl(), establishmentId,
                    cookies.toString());
            }

            epfoEstablishmentDetailDtos.add(EpfoEstablishmentDetailDto.Builder.epfoEstablishmentDetailDto()
                .withEstablishmentId(epfoEstablishmentInfo.getEstablishmentId())
                .withName(epfoEstablishmentInfo.getName())
                .withAddress(epfoEstablishmentInfo.getAddress())
                .withOfficeName(epfoEstablishmentInfo.getOfficeName())
                .withPaymentDetailList(paymentDetailDtos)
                .withEpfoCinInfoDto(epfoCinInfoDto)
                .withEstablishmentStatus(status)
                .withMatchingType(matchingType)
                .withSystemAssignedStatus(systemAssignedStatus)
                .build());
        }
        logger.info("Parsing successfully completed for " + organisationName);
        return EpfoDetailDto.Builder.epfoDetailDto()
            .withParsingId(String.valueOf(UUID.randomUUID()))
            .withTaskType(TaskType.EPFO)
            .withParsingTime(System.currentTimeMillis())
            .withBaseTaskParamsDto(null)
            .withEstablishmentDetailList(epfoEstablishmentDetailDtos)
            .withEpfoTaskParamsDto(parsingParams)
            .build();
    }

    private static boolean isDataValid(MatchingType matchingType, SystemAssignedStatus systemAssignedStatus,
        EpfoTaskParamsDto parsingParams) {
        if (matchingType == MatchingType.CIN_PAN_NOT_MATCHED
            || matchingType == MatchingType.UNKNOWN
            || systemAssignedStatus == SystemAssignedStatus.UNMATCHED
            || (ObjectUtils.isNotBlank(parsingParams.getCompanyPan()) && !PanUtils.isCompanyPan(
            parsingParams.getCompanyPan())
            && matchingType == MatchingType.NAME_MATCHING)) {
            return false;
        }
        return true;
    }

    public static MatchingType getCinAndPanMatchingStatus(EpfoCinInfoDto epfoCinInfoDto,
        EpfoTaskParamsDto parsingParam) {
        if (ObjectUtils.isBlankObject(epfoCinInfoDto) || ObjectUtils.isBlankObject(parsingParam)) {
            return MatchingType.NAME_MATCHING;
        }
        String organisationCin = parsingParam.getCin();
        String organisationPan = parsingParam.getCompanyPan();
        String epfoCin = epfoCinInfoDto.getCin();
        String epfoPan = epfoCinInfoDto.getPan();
        if ((ObjectUtils.isBlank(organisationCin) || ObjectUtils.isBlank(epfoCin))
            && ((ObjectUtils.isBlank(organisationPan) || ObjectUtils.isBlank(epfoPan)))) {
            return MatchingType.NAME_MATCHING;
        }
        if (ObjectUtils.isNotBlank(organisationCin)
            && ObjectUtils.isNotBlank(epfoCin)
            && organisationCin.equalsIgnoreCase(epfoCin)) {
            return MatchingType.CIN_MATCHED;
        } else if (ObjectUtils.isNotBlank(organisationPan)
            && ObjectUtils.isNotBlank(epfoPan)
            && organisationPan.equalsIgnoreCase(epfoPan)) {
            return MatchingType.PAN_MATCHED;
        } else {
            return MatchingType.CIN_PAN_NOT_MATCHED;
        }
    }

    private static Map<String, String> getHeaders(String cookie) {
        HashMap<String, String> headers = new HashMap<>();
        if(ObjectUtils.isNotBlank(cookie)) {
            headers.put("Cookie", cookie);
        }
        
        headers.put("accept", "*/*");
        headers.put("referer", "https:
        headers.put("X-Requested-With", "XMLHttpRequest");
        headers.put("Content-type", "application/json; charset=UTF-8");
        return headers;
    }

    public static Map<String, List<EpfoEstablishmentActionInfoDto>> getEstablishment(String url, String captcha,
        String cookies, String establishmentName) throws IOException, JSONException, RequestParsingException {
        String payload = "{\"EstName\":\"" + establishmentName + "\",\"EstCode\":\"" + "" + "\",\"captcha\":\"" + captcha + "\"}";
        JSONObject json = new JSONObject(payload);
        Document doc = null;
        try {
            doc = HttpAsyncClientUtils.postAndGetDocument(TaskType.EPFO, url, String.valueOf(json),
                getHeaders(cookies));
        } catch (IOException e) {
            logger.error("EpfoParserCallback: Error while getting Establishment info for " + establishmentName, e);
            throw new RequestParsingException(MessageFormat.format("Unable to post search request, {0}",
                e.getMessage()), TaskError.SERVER_DOWN);
        }

        if (!String.valueOf(doc).contains("<tr>")) {
            if (String.valueOf(doc).contains("Please enter valid Establishment name or code number")) {
                return ImmutableMap.of("SUCCESS", Collections.emptyList());
            } else {
                return ImmutableMap.of("FAILED", Collections.emptyList());
            }
        }
        Element table = doc.select("table").get(0);
        Elements rows = table.select("tr");
        List<EpfoEstablishmentActionInfoDto> actionInfoDtos = new ArrayList<>();
        String action = null;
        String actionUrl = null;
        String cinDetailUrl = null;
        String statusInfoUrl = null;
        for (int i = 1; i < rows.size(); i++) {
            Element row = rows.get(i);
            Elements cols = row.select("td");
            String col = String.valueOf(cols);
            action = String.valueOf(cols.get(4));
            cinDetailUrl = action.substring(action.indexOf("/publicPortal/no-auth/estSearch/getDetails_12"),
                action.indexOf("')", action.lastIndexOf("/publicPortal/no-auth/estSearch/getDetails_12")));
            statusInfoUrl = action.substring(action.indexOf("/publicPortal/no-auth/estSearch/getDetails_4"),
                action.indexOf("'", action.lastIndexOf("/publicPortal/no-auth/estSearch/getDetails_4")));
            actionUrl = action.substring(action.indexOf(",") + 2,
                action.indexOf(",", action.indexOf(",") + 1) - 1);
            actionInfoDtos.add(EpfoEstablishmentActionInfoDto.Builder.epfoEstablishmentActionInfoDto()
                .withEstablishmentId(cols.get(0).text())
                .withName(cols.get(1).text())
                .withAddress(cols.get(2).text())
                .withOfficeName(cols.get(3).text())
                .withActionUrl(actionUrl)
                .withCinInfoUrl(cinDetailUrl)
                .withStatusInfoUrl(statusInfoUrl)
                .build());
        }
        return ImmutableMap.of("SUCCESS", actionInfoDtos);
    }

    public static String getPaymentURL(String url, String establishmentId, String cookies) throws IOException,
        JSONException, RequestParsingException {
        String payload2 = "{\"EstId\":\"" + establishmentId + "\"}";
        JSONObject json2 = new JSONObject(payload2);
        Document doc = null;
        try {
            doc = HttpAsyncClientUtils.postAndGetDocument(TaskType.EPFO, url, String.valueOf(json2),
                getHeaders(cookies));
        } catch (IOException e) {
            logger.error("EpfoParserCallback: Error while getting payment URL {}", e);
            throw new RequestParsingException(MessageFormat.format("Unable to post search request, {0}",
                e.getMessage()), TaskError.SERVER_DOWN);
        }
        Elements info = doc.select("a[href]");
        String payment_url = String.valueOf(info);
        if(!payment_url.contains("/") && !payment_url.contains("'")){
            logger.error("Error while getting payment URL");
            return null;
        }
        payment_url = payment_url.substring(payment_url.indexOf("/"), payment_url.lastIndexOf("'"));
        return payment_url;
    }

    private static EpfoCinInfoDto getCompanyCinInfo(String url, String establishmentId, String cookies)
        throws RequestParsingException {
        String payload2 = "{\"EstId\":\"" + establishmentId + "\"}";
        JSONObject json2 = new JSONObject(payload2);
        String docString = null;
        try {
            docString = HttpAsyncClientUtils.post(TaskType.EPFO, url, String.valueOf(json2),
                getHeaders(cookies));
        } catch (IOException e) {
            logger.error("EpfoParserCallback: Error while getting company Data {}", e);
        }
        if (docString == null) {
            throw new RequestParsingException("Unable to post search request", TaskError.SERVER_DOWN);
        }
        docString = docString.replaceAll("<!--", "").replaceAll("-->", "");
        Document doc = Jsoup.parse(docString, "UTF-8");

        return getEpfoCinInfoDtoFromRowElements(doc.select("tbody > tr"));
    }

    private static EpfoCinInfoDto getEpfoCinInfoDtoFromRowElements(Elements rows) {
        if (ObjectUtils.isBlankObject(rows)) {
            return null;
        }
        String establishmentId = null;
        String cin = null;
        String pan = null;
        EpfoCinInfoDto epfoCinInfoDto = null;
        if (rows.size() >= 9) {
            try {
                establishmentId = rows.get(0).select("td").get(1).text().trim();
            } catch (Exception e) {
                logger.error("Cannot map EstablishmentId From Rows", e);
            }
            try {
                cin = "NA".equalsIgnoreCase(rows.get(1).select("td").get(1).text().trim()) ? null
                    : rows.get(1).select("td").get(1).text().trim();
            } catch (Exception e) {
                logger.error("Cannot cin EstablishmentId From Rows", e);
            }
            try {
                pan = "NA".equalsIgnoreCase(rows.get(8).select("td").get(1).text().trim()) ? null
                    : rows.get(8).select("td").get(1).text().trim();
            } catch (Exception e) {
                logger.error("Cannot map pan From Rows", e);
            }
        }
        if (pan != null || cin != null) {
            epfoCinInfoDto = EpfoCinInfoDto.Builder.epfoCinInfoDto()
                .withEstablishmentId(establishmentId)
                .withCin(cin)
                .withPan(pan)
                .build();
        }
        return epfoCinInfoDto;
    }

    private static String getEstablishmentStatus(String url, String establishmentId, String cookies)
        throws RequestParsingException {
        String payload2 = "{\"EstId\":\"" + establishmentId + "\"}";
        JSONObject json2 = new JSONObject(payload2);
        Document document = null;
        try {
            document = HttpAsyncClientUtils.postAndGetDocument(TaskType.EPFO, url, String.valueOf(json2),
                getHeaders(cookies));
        } catch (IOException e) {
            logger.error("EpfoParserCallback: Error while getting company Data {}", e);
        }
        if (document == null) {
            throw new RequestParsingException("Unable to post search request", TaskError.SERVER_DOWN);
        }
        Elements tableRows = document.select("body > table > tbody > tr");
        if (tableRows.size() < 2) {
            return null;
        }
        String statusString = null;
        try {
            statusString = tableRows.get(1).select("td").get(1).text();
        } catch (Exception e) {
            logger.error(MessageFormat.format("Error while extracting statusString from statusInfoUrl: {}", url), e);
            return null;
        }
        return statusString;
    }

    public static List<EpfoPaymentDetailDto> getData(String url, String cookies)
        throws IOException, RequestParsingException {
        Document doc = null;
        try {
            doc = HttpAsyncClientUtils.postAndGetDocument(TaskType.EPFO, url, "", getHeaders(cookies));
        } catch (IOException e) {
            logger.error("EpfoParserCallback: Error while getting payment data", e);
            throw new RequestParsingException(MessageFormat.format("Unable to post search request, {0}",
                e.getMessage()), TaskError.SERVER_DOWN);
        }
        if (!String.valueOf(doc).contains("<tr>")) {
            return Collections.emptyList();
        }
        Element table = doc.select("table").get(0);
        Elements rows = table.select("tr");
        List<EpfoPaymentDetailDto> epfoPaymentDetailDtoList = new ArrayList<>();
        for (int i = 1; i < rows.size(); i++) {
            Element row = rows.get(i);
            Elements cols = row.select("td");
            epfoPaymentDetailDtoList.add(EpfoPaymentDetailDto.Builder.epfoPaymentDetailDto()
                .withTrrn(cols.get(0).text())
                .withDateOfCredit(EPFUtils.dateToTimeFormatter(cols.get(1).text()))
                .withAmount(BigDecimal.valueOf(numerify(cols.get(2).text())))
                .withWageMonth(cols.get(3).text())
                .withNumberOfEmployees(numerify(cols.get(4).text()))
                .withEcr(cols.get(5).text())
                .build());
        }

        return epfoPaymentDetailDtoList;
    }

    public static void main(String[] args) throws Throwable {
        EpfoTaskParamsDto ofb_tech_private_limited = EpfoTaskParamsDto.Builder.epfoTaskParamsDto()
            .withRequestId("")
            .withCompanyName("Oxyzo Financial Services")
            .withCin(null)
            .withGstIn(null)
            .withCompanyPan(null)
            .build();
        Calendar calendar = Calendar.getInstance();
        EpfoDetailDto epfoDetailDto = parseEpfo(ofb_tech_private_limited);
        System.out.println(epfoDetailDto);
    }
}


package com.ofb.crawler.core.util;

public class FileUtils {

    public static String getTempWorkDirectory(TaskType taskType) {
        return getTempWorkDirectory(taskType, null);
    }

    public static String getTempWorkDirectory(TaskType taskType, String extendedDir) {
        if (taskType == null) {
            return null;
        }

        if (ObjectUtils.isBlank(extendedDir)) {
            return "/tmp/crawlTask/temp/" + taskType.name() + "/";
        } else {
            if (extendedDir.endsWith("/")) {
                return "/tmp/crawlTask/temp/" + taskType.name() + "/" + extendedDir;
            }
            return "/tmp/crawlTask/temp/" + taskType.name() + "/" + extendedDir + "/";
        }
    }

    public static File getTempFile(TaskType taskType, String extension) {
        return getTempFile(taskType, null, extension);
    }

    public static File getTempFile(TaskType taskType, String extendedDir, String extension) {
        return getTempFile(getTempWorkDirectory(taskType, extendedDir), extension);
    }

    public static File getTempFile(String directory, String extension) {
        createDirectoryIfNotExists(directory);
        return new File(directory + System.currentTimeMillis() + "-" + UUID.randomUUID().toString() + extension);
    }
}


package com.ofb.crawler.commons.types.gstReturn.dto.parsing;

@Data
@NoArgsConstructor
public class GstReturnParsingDto extends BaseParsingDto {

    private String gstIn;

    public GstReturnParsingDto(String gstIn) {
        this.gstIn = gstIn;
    }

    public GstReturnParsingDto(String parsingId, String requestId, TaskType taskType, long parsingTime, String responseUrl, String gstIn) {
        super(parsingId, requestId, taskType, parsingTime, responseUrl);
        this.gstIn = gstIn;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        GstReturnParsingDto that = (GstReturnParsingDto) o;
        return Objects.equals(gstIn, that.gstIn);
    }

    @Override
    public int hashCode() {
        return Objects.hash(gstIn);
    }

    public static interface ParsingIdStep {
        RequestIdStep withParsingId(String parsingId);
    }

    public static interface RequestIdStep {
        TaskTypeStep withRequestId(String requestId);
    }

    public static interface TaskTypeStep {
        ParsingTimeStep withTaskType(TaskType taskType);
    }

    public static interface ParsingTimeStep {
        ResponseUrlStep withParsingTime(long parsingTime);
    }

    public static interface ResponseUrlStep {
        GstInStep withResponseUrl(String responseUrl);
    }

    public static interface GstInStep {
        BuildStep withGstIn(String gstIn);
    }

    public static interface BuildStep {
        GstReturnParsingDto build();
    }


    public static class Builder implements ParsingIdStep, RequestIdStep, TaskTypeStep, ParsingTimeStep, ResponseUrlStep, GstInStep, BuildStep {
        private String parsingId;
        private String requestId;
        private TaskType taskType;
        private long parsingTime;
        private String responseUrl;
        private String gstIn;

        private Builder() {
        }

        public static ParsingIdStep gstReturnParsingDto() {
            return new Builder();
        }

        @Override
        public RequestIdStep withParsingId(String parsingId) {
            this.parsingId = parsingId;
            return this;
        }

        @Override
        public TaskTypeStep withRequestId(String requestId) {
            this.requestId = requestId;
            return this;
        }

        @Override
        public ParsingTimeStep withTaskType(TaskType taskType) {
            this.taskType = taskType;
            return this;
        }

        @Override
        public ResponseUrlStep withParsingTime(long parsingTime) {
            this.parsingTime = parsingTime;
            return this;
        }

        @Override
        public GstInStep withResponseUrl(String responseUrl) {
            this.responseUrl = responseUrl;
            return this;
        }

        @Override
        public BuildStep withGstIn(String gstIn) {
            this.gstIn = gstIn;
            return this;
        }

        @Override
        public GstReturnParsingDto build() {
            return new GstReturnParsingDto(
                    this.parsingId,
                    this.requestId,
                    this.taskType,
                    this.parsingTime,
                    this.responseUrl,
                    this.gstIn
            );
        }
    }
}


package com.ofb.crawler.core.util;

public class RuntimeUtils {

    public static CommandOutput1 executeCommand(List<String> command) throws Exception {
        String[] arr = new String[command.size()];
        command.toArray(arr);
        return executeCommand(arr);
    }

    public static CommandOutput1 executeCommand(String[] command) throws Exception {
        Runtime rt = Runtime.getRuntime();
        Process proc = rt.exec(command);
        CommandOutput1 output = getOutput(proc);
        return output;
    }

    private static CommandOutput1 getOutput(Process proc) throws Exception {

        BufferedReader stdInput = null;
        BufferedReader stdError = null;
        try {
            stdInput = new BufferedReader(new InputStreamReader(proc.getInputStream()));

            stdError = new BufferedReader(new InputStreamReader(proc.getErrorStream()));

            String output = null;
            boolean error = false;

            
            String s = null;
            List<String> lines = new LinkedList<>();
            while ((s = stdError.readLine()) != null) {
                lines.add(s);
                error = true;
            }
            if (error) {
                throw new Exception(Arrays.toString(lines.toArray()));
            }
            

            while ((s = stdInput.readLine()) != null) {
                output = s;
                break;
            }
            return new CommandOutput1(false, output);
        } finally {
            IOUtils.closeQuietly(stdInput);
            IOUtils.closeQuietly(stdError);
        }
    }
}



package com.ofb.crawler.commons.types.mca.dto;

public class McaCompanyMasterDataCrawlDto {

    @JsonProperty("companyData")
    private CompanyDataCrawlDto companyData;

    @JsonProperty("directorData")
    private List<CompanyDirectorDataCrawlDto> directorDataList;

    @JsonProperty("indexChargesData")
    private List<CompanyChargesDataCrawlDto> chargesDataList;

    public McaCompanyMasterDataCrawlDto() {
    }

    public McaCompanyMasterDataCrawlDto(CompanyDataCrawlDto companyData,
        List<CompanyDirectorDataCrawlDto> directorDataList,
        List<CompanyChargesDataCrawlDto> chargesDataList) {
        this.companyData = companyData;
        this.directorDataList = directorDataList;
        this.chargesDataList = chargesDataList;
    }

    public CompanyDataCrawlDto getCompanyData() {
        return companyData;
    }

    public void setCompanyData(CompanyDataCrawlDto companyData) {
        this.companyData = companyData;
    }

    public List<CompanyDirectorDataCrawlDto> getDirectorDataList() {
        return directorDataList;
    }

    public void setDirectorDataList(
        List<CompanyDirectorDataCrawlDto> directorDataList) {
        this.directorDataList = directorDataList;
    }

    public List<CompanyChargesDataCrawlDto> getChargesDataList() {
        return chargesDataList;
    }

    public void setChargesDataList(
        List<CompanyChargesDataCrawlDto> chargesDataList) {
        this.chargesDataList = chargesDataList;
    }

    public static interface CompanyDataStep {
        DirectorDataListStep withCompanyData(CompanyDataCrawlDto companyData);
    }

    public static interface DirectorDataListStep {
        ChargesDataListStep withDirectorDataList(List<CompanyDirectorDataCrawlDto> directorDataList);
    }

    public static interface ChargesDataListStep {
        BuildStep withChargesDataList(List<CompanyChargesDataCrawlDto> chargesDataList);
    }

    public static interface BuildStep {
        McaCompanyMasterDataCrawlDto build();
    }

    public static class Builder implements CompanyDataStep, DirectorDataListStep, ChargesDataListStep, BuildStep {
        private CompanyDataCrawlDto companyData;
        private List<CompanyDirectorDataCrawlDto> directorDataList;
        private List<CompanyChargesDataCrawlDto> chargesDataList;

        private Builder() {
        }

        public static CompanyDataStep mcaCompanyMasterDataCrawlDto() {
            return new Builder();
        }

        @Override
        public DirectorDataListStep withCompanyData(CompanyDataCrawlDto companyData) {
            this.companyData = companyData;
            return this;
        }

        @Override
        public ChargesDataListStep withDirectorDataList(List<CompanyDirectorDataCrawlDto> directorDataList) {
            this.directorDataList = directorDataList;
            return this;
        }

        @Override
        public BuildStep withChargesDataList(List<CompanyChargesDataCrawlDto> chargesDataList) {
            this.chargesDataList = chargesDataList;
            return this;
        }

        @Override
        public McaCompanyMasterDataCrawlDto build() {
            return new McaCompanyMasterDataCrawlDto(
                this.companyData,
                this.directorDataList,
                this.chargesDataList
            );
        }
    }
}


package com.ofb.crawler.core.util;

public class CompanyProfileUtils {

    public static final Logger logger = LoggerFactory.getLogger(CompanyProfileUtils.class);

    public static final Pattern GST_REGEX=Pattern.compile("\\d{2}[A-Z]{5}\\d{4}[A-Z]{1}[A-Z\\d]{1}[Z]{1}[A-Z\\d]{1}");

    public static final Pattern CIN_REGEX=Pattern.compile("^([L|U]{1})([0-9]{5})([A-Za-z]{2})([0-9]{4})([A-Za-z]{3})"
        + "([0-9]{6})$\n");

    public static boolean fuzzyContainsMatch(String str1, String str2) {
        str1 = getLowercasedSimple(simpleCompanyName(str1));
        str2= getLowercasedSimple(simpleCompanyName(str2));
        return str1.contains(str2) || str2.contains(str1);
    }

    public static boolean fuzzyCompanyMatch(String str1, String str2, int threshold){
        str1 = str1.toLowerCase();
        str2 = str2.toLowerCase();
        return fuzzyMatch(simpleCompanyName(str1),simpleCompanyName(str2),threshold);
    }

    public static String simpleCompanyName(String str){
        return cleanSearchQuery(str);
    }

    public static boolean fuzzyMatch(String str1,String str2,int threshold){
        
        str1=getLowercasedSimple(str1);
        str2=getLowercasedSimple(str2);

        LevenshteinDistance ld = new LevenshteinDistance();
        return ld.apply(str1,str2)<=threshold;
    }

    public static String getLowercasedSimple(String str){
        return StringUtils.removeSpecialChars(StringUtils.removeAllSpaces(str.toLowerCase())).trim();
    }

    public static String cleanSearchQuery(String query){
        query=query.toLowerCase();
        query=query.replaceAll("m/s","");
        query=query.replaceAll("pvt."," ");
        query=query.replaceAll("ltd."," ");
        query=query.replaceAll("ltd"," ");
        query=query.replaceAll("pvt"," ");
        query=query.replaceAll("private"," ");
        query=query.replaceAll("llp"," ");
        query=query.replaceAll("limited"," ");
        query = query.replaceAll(" +"," ");
        return query.trim();
    }

    public static void main(String[] args) {
        matchRawCompanyNames("CBS Publihsers AND Distributors Pvt.Ltd.","CBS Publishers and distributors Pvt Ltd");
    }

    public static String trimRedundantInfoFromCompany(String companyName){
        String origName=companyName;
        List<String> patterns = Arrays.asList("pvt", "ltd", "limited", "private","( MSE ");
        if(StringUtils.isNotBlank(companyName)){
            companyName=companyName.toLowerCase();
            for(String p:patterns){
                if(companyName.contains(p)){
                    companyName=companyName.substring(0,companyName.indexOf(p));
                }
            }
        }

        companyName=companyName.replaceAll("\\(.*\\)","");
        companyName=companyName.trim();
        if(companyName.toLowerCase().startsWith("m/s.") || companyName.toLowerCase().startsWith("m/s")){
            companyName=companyName.replaceAll("m/s.","");
            companyName=companyName.replaceAll("m/s","");
        }
        companyName=companyName.replaceAll("&","and");
        companyName=companyName.replaceAll("\\.","");
        companyName=StringUtils.removeAllSpaces(companyName);
        
        return companyName.trim();
    }

    public static Pair<Boolean,Integer> matchRawCompanyNames(String company1,String company2){
        boolean match1= type1Match(company1, company2);
        boolean match2= type2Match(company1, company2);
        boolean match3 = type3Match(company1, company2);
        boolean anyMatch=match1||match2||match3;
        if(anyMatch){
             Integer matchScore=0;
             matchScore=33*boolToInt(match1)+33*boolToInt(match2)+33*boolToInt(match3);
             return new Pair<>(true,matchScore);
        }
        return new Pair<>(Boolean.FALSE,0);
    }

    private static boolean type1Match(String company1, String company2) {
        return trimRedundantInfoFromCompany(company1).toLowerCase()
            .contains(CompanyProfileUtils.trimRedundantInfoFromCompany(company2).toLowerCase())||
            trimRedundantInfoFromCompany(company2).toLowerCase()
                .contains(CompanyProfileUtils.trimRedundantInfoFromCompany(company1).toLowerCase());
    }

    private static boolean type2Match(String company1, String company2) {
        return StringUtils.removeAllSpaces(company1).toLowerCase()
            .contains(StringUtils.removeAllSpaces(company2).toLowerCase())
            ||StringUtils.removeAllSpaces(company2).toLowerCase()
            .contains(StringUtils.removeAllSpaces(company1).toLowerCase());
    }

    private static boolean type3Match(String company1, String company2) {
        String cName1=StringUtils.removeAllSpaces(trimRedundantInfoFromCompany(company1).toLowerCase());
        String cName2=StringUtils.removeAllSpaces(trimRedundantInfoFromCompany(company2).toLowerCase());
        boolean match3=cName1.contains(cName2)||cName2.contains(cName1);
        return match3;
    }

    private static int boolToInt(boolean b) {
        return b?1:0;
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
}


package com.ofb.crawler.core.types.credit.rating;

public class CreditRatingUtils {

    public static RatingAction getRatingAction(String ratingString) {
        ratingString = ratingString.toLowerCase();
        if (ratingString.contains("upgrade")){
            return RatingAction.UPGRADE;
        }
        if (ratingString.contains("downgrade")){
            return RatingAction.DOWNGRADE;
        }
        if (ratingString.contains("affirm")){
            return RatingAction.REAFFIRM;
        }
        if (ratingString.contains("assign")){
            return RatingAction.ASSIGNED;
        }
        if (ratingString.contains("withdraw") || ratingString.contains("WD")){
            return RatingAction.WITHDRAWN;
        }
        if (ratingString.contains("suspend")){
            return RatingAction.SUSPENDED;
        }
        return null;
    }


    private static Map<String, RatingType> ratingTypeMap = new HashMap<>();
    static {
        ratingTypeMap.put("bank guarantee", RatingType.SHORT_TERM);
        ratingTypeMap.put("bg", RatingType.SHORT_TERM);
        ratingTypeMap.put("lc", RatingType.SHORT_TERM);
        ratingTypeMap.put("line of credit", RatingType.SHORT_TERM);
        ratingTypeMap.put("letter of credit", RatingType.SHORT_TERM);
        ratingTypeMap.put("credit line", RatingType.SHORT_TERM);
        ratingTypeMap.put("bill discounting", RatingType.SHORT_TERM);
        ratingTypeMap.put("short-term", RatingType.SHORT_TERM);
        ratingTypeMap.put("short term", RatingType.SHORT_TERM);
        ratingTypeMap.put("vendor financing", RatingType.SHORT_TERM);
        ratingTypeMap.put("fund-based", RatingType.LONG_TERM);
        ratingTypeMap.put("non-fund-based", RatingType.SHORT_TERM);
        ratingTypeMap.put("non-convertible", RatingType.LONG_TERM);
        ratingTypeMap.put("ncds", RatingType.LONG_TERM);
        ratingTypeMap.put("commercial paper", RatingType.SHORT_TERM);
        ratingTypeMap.put("cp", RatingType.SHORT_TERM);

        ratingTypeMap.put("long term", RatingType.LONG_TERM);
        ratingTypeMap.put("cash credit", RatingType.LONG_TERM);
        ratingTypeMap.put("overdraft", RatingType.LONG_TERM);
        ratingTypeMap.put("cc", RatingType.LONG_TERM);
        ratingTypeMap.put("od", RatingType.LONG_TERM);
        ratingTypeMap.put("tl", RatingType.LONG_TERM);
        ratingTypeMap.put("term loan", RatingType.LONG_TERM);
        ratingTypeMap.put("lap", RatingType.LONG_TERM);
        ratingTypeMap.put("property", RatingType.LONG_TERM);
        ratingTypeMap.put("ecb", RatingType.LONG_TERM);
        ratingTypeMap.put("working capital", RatingType.LONG_TERM);


    }

    public static RatingType getRatingType(String facilityName) {
        facilityName = facilityName.toLowerCase().replaceAll("[^a-z]]", "");

        if (facilityName.contains("non-fund-based")) {
                return ratingTypeMap.get("non-fund-based");
        }
        for (String key : ratingTypeMap.keySet()) {
            if (facilityName.contains(key)) {
                return ratingTypeMap.get(key);
            }
        }
        return null;
    }


    public static final BigDecimal getAmount(String size) {
        size = size.replaceAll(",","");
        Matcher matcher = Pattern.compile("(\\d+(?:\\.\\d+)?)").matcher(size);
        matcher.find();
        try {
            return new BigDecimal(matcher.group(1));
        } catch (Exception e) {
            return BigDecimal.ZERO;
        }
    }

    public static boolean isNameMatched(String label, String searchKey) {
        if (searchKey.equalsIgnoreCase(label)) {
            return true;
        }

        if (sanitizeName(searchKey).equals(sanitizeName(label))) {
            return true;
        }
        return false;

    }

    public static Boolean checkIfHtmlString(String htmlString) {
        if (htmlString.contains("<") && htmlString.contains(">")) {
            return true;
        }
        return false;
    }

    public static String sanitizeSearchName(String name) {
        return name.toLowerCase()
                .replaceAll("private", "")
                .replaceAll("-", " ")
                .replaceAll("limited", "")
                .replaceAll("'s ", " ")
                .replaceAll("`s ", " ")
                .replaceAll("llp", " ")
                .replaceAll("pvt", "")
                .replaceAll("ltd", "")
                .replaceAll("m/s", "")
                .replaceAll("ms\\.", "")
                .replaceAll("\\s+", " ")
                .replaceAll("\\.", " ")
                .replaceAll(" & ", " and ")
                .replaceAll(" &", " and ")
                .replaceAll("& ", " and ")
                .replaceAll("&", "and")
                .trim();

    }

    public static String sanitizeName(String name) {
        if (ObjectUtils.isBlank(name)) {
            return "";
        }
        return name.toLowerCase()
                .replaceAll("\\(p\\)", " private ")
                .replaceAll("private", "")
                .replaceAll("-", " ")
                .replaceAll("limited", "")
                .replaceAll("llp", " ")
                .replaceAll("pvt", "")
                .replaceAll("ltd", "")
                .replaceAll("m/s", "")
                .replaceAll("m/s\\.", "")
                .replaceAll("ms\\.", "")
                
                .replaceAll("\\s+", " ")
                .replaceAll(" & ", " and ")
                .replaceAll(" &", " and ")
                .replaceAll("& ", " and ")
                .replaceAll("&", "and")
                .replaceAll("[^a-z0-9 ]", "")
                .trim();
    }

}


package com.ofb.crawler.core.util;

public class HtmlParserUtils {

    public static final Long ONE_THOUSAND = 1000l;

    public static final Long ONE_LAC = 100 * ONE_THOUSAND;

    public static final Long ONE_CRORE = 100 * ONE_LAC;

    private static final Logger logger = LoggerFactory.getLogger(HtmlParserUtils.class);

    public static boolean isPatternAvailable(String regex, String type) {
        Pattern pattern = Pattern.compile(regex, Pattern.CASE_INSENSITIVE);
        Matcher matcher = pattern.matcher(type);
        if (matcher.find()) {
            return true;
        } else {
            return false;
        }
    }

    public static Long covertDateStringToLong(String date, SimpleDateFormat formatter)
        throws ParseException {
        if (date != null
            && !date.trim().contains("NA")
            && !com.ofb.libs.utils.ObjectUtils.isBlank(date)
            && !date.trim().contains("Not available")) {
            return formatter.parse(date).getTime();
        }
        return null;
    }

    public static Long tryCovertDateStringToLong(String date, SimpleDateFormat formatter) {
        try {
            return covertDateStringToLong(date, formatter);
        } catch (Exception e) {
            return null;
        }
    }

    public static String getTextByParentSibling(String query, Document document) {
        if (document.select(query).first() == null) {
            return null;
        }
        if (document.select(query).first().parent() == null) {
            return null;
        }
        if (document.select(query)
            .first().parent().nextElementSibling() == null) {
            return null;
        }
        return document.select(query).first().parent().nextElementSibling().text();
    }

    public static Element getParentSiblingElement(String query, Document document) {
        if (document.select(query).first() == null) {
            return null;
        }
        if (document.select(query).first().parent() == null) {
            return null;
        }
        return document.select(query)
            .first().parent().nextElementSibling();
    }

    public static Element getParentSiblingChildElement(String query, Document document) {
        if (document.select(query).first() == null) {
            return null;
        }
        if (document.select(query).first().parent() == null) {
            return null;
        }
        if (document.select(query)
            .first().parent().nextElementSibling() == null) {
            return null;
        }
        return document.select(query)
            .first().parent().nextElementSibling().child(0);
    }

    public static Element getTextMatchesParentSiblingChildElement(String query, Document document,
        String text) {
        text = text.toLowerCase().trim();
        Elements elements = document.select(query);
        Element element = elements.first();
        for (Element tempelement : elements) {
            if (tempelement.text().toLowerCase().trim().equals(text)) {
                element = tempelement;
                break;
            }
        }
        if (element.parent() == null) {
            return null;
        }
        if (element.parent().nextElementSibling() == null) {
            return null;
        }
        if (element.parent().nextElementSibling().children().size() == 0) {
            return null;
        }
        return element.parent().nextElementSibling().child(0);
    }

    public static String getTextByParentSiblingChild(String query, Document document) {
        if (document.select(query).first() == null) {
            return null;
        }
        if (document.select(query).first().parent() == null) {
            return null;
        }
        if (document.select(query)
            .first().parent().nextElementSibling() == null) {
            return null;
        }
        if (document.select(query)
            .first().parent().nextElementSibling().child(0) == null) {
            return null;
        }
        return document.select(query)
            .first().parent().nextElementSibling().child(0).text();
    }

    public static String getTextByFirstNodeSibling(String query, Document document) {
        if (document.select(query).first() != null) {
            if (document.select(query)
                .first().nextElementSibling() != null) {
                    return document.select(query)
                    .first().nextElementSibling().text();
            }
            return null;
        }
        return null;
    }

    public static Element getFirstNodeSiblingElement(String query, Document document) {
        if (document.select(query).first() != null) {
            if (document.select(query)
                    .first().nextElementSibling() != null) {
                return document.select(query)
                        .first().nextElementSibling();
            }
            return null;
        }
        return null;
    }

    public static String getTextByLastNodeSibling(String query, Document document) {
        if (document.select(query).last() != null) {
            if (document.select(query)
                .last().nextElementSibling() != null) {
                return document.select(query)
                    .last().nextElementSibling().text();
            }
            return null;
        }
        return null;
    }

    public static String getTextByLastNodeParentSibling(String query, Document document) {
        if (document.select(query).last() == null) {
            return null;
        }
        if (document.select(query).last().parent() == null) {
            return null;
        }
        if (document.select(query).last().parent().nextElementSibling() == null) {
            return null;
        }
        return document.select(query)
            .last().parent().nextElementSibling().text();
    }

    public static String getDomainNameFromUrl(String url) {
        try {
            return new URI(url).getHost();
        } catch (URISyntaxException e) {
            return null;
        }
    }

    public static String fetchFileNameFromContentType(Header[] headers) {
        if (headers == null || headers.length == 0) {
            return null;
        }
        String value = null;
        for (Header header : headers) {
            if (header.getName().toLowerCase().equals(Headers.CONTENT_TYPE.toLowerCase())) {
                value = header.getValue();
                value = value.split(";")[0];
                break;
            }
        }
        return value;
    }

    public static String fetchFileNameFromHeaders(Header[] headers) {
        if (headers == null || headers.length == 0) {
            return null;
        }
        String value = null;
        for (Header header : headers) {
            if (header.getName().toLowerCase().equals(Headers.CONTENT_DISPOSITION.toLowerCase())) {
                value = header.getValue();
                break;
            }
        }
        return fetchFileNameFromContentDeposition(value);
    }

    public static String fetchFileNameFromContentDeposition(String contentDepositionValue) {
        if (contentDepositionValue == null || !contentDepositionValue.contains("=")) {
            return null;
        }
        if(contentDepositionValue.toLowerCase().contains("utf-8")){
            contentDepositionValue=contentDepositionValue.substring(contentDepositionValue.toLowerCase().indexOf("utf-8")+7);
            contentDepositionValue=contentDepositionValue.replaceAll("'","");
            contentDepositionValue=contentDepositionValue.replace("filename=","");
            return contentDepositionValue;
        }else {
            String fileName =
                contentDepositionValue.substring(contentDepositionValue.indexOf("=") + 1);
            if (fileName.contains(";")) {
                fileName = fileName.substring(0, fileName.indexOf(";") - 1);
            }
            return fileName.replaceAll("\"", "");
        }
    }

    public static String normalizeUrl(String url) throws UnsupportedEncodingException {
        int pos = url.lastIndexOf("?") + 1;
        String parsedURI = url.substring(0, pos) + URLEncoder.encode(url.substring(pos),
            StandardCharsets.UTF_8.name())
            .replaceAll("\\+", "%20");
        return parsedURI;
    }

    public static String parseFileNameFromFile(File file) {
        return parseFileNameFromPath(file.getName());
    }

    public static String parseFileNameFromPath(String path) {
        int pos = path.lastIndexOf("/");
        if (pos >= 0) {
            path = path.substring(pos + 1);
        }
        if (!path.contains(".")) {
            return null;
        }
        String fileName = path.substring(0, path.lastIndexOf(".")).replaceAll("%20", " ");
        if (fileName.startsWith("/")) {
            fileName = fileName.substring(1);
        }
        return fileName;
    }

    public static String parseFileNameFromUrl(String path) {
        int pos = path.lastIndexOf("/");
        if (pos >= 0) {
            path = path.substring(pos + 1);
        }
        if (!path.contains(".")) {
            return null;
        }
        String fileName = path.replaceAll("%20", " ");
        if (fileName.startsWith("/")) {
            fileName = fileName.substring(1);
        }
        return fileName;
    }

    public static String parseFileNameWithoutExtentionFromUrl(String path) {
        int pos = path.lastIndexOf("/");
        if (pos >= 0) {
            path = path.substring(pos + 1);
        }
        if (!path.contains(".")) {
            return null;
        }
        String fileName = path.replaceAll("%20", " ");
        if (fileName.startsWith("/")) {
            fileName = fileName.substring(1);
        }
        String[] temp = fileName.split("\\.");
        fileName = temp[0];
        return fileName;
    }

    public static String parseMimeType(ContentType contentType) {
        return parseMimeType(contentType.getMimeType());
    }

    public static String parseFileType(HttpResponse response) {
        if (response.getEntity() == null) {
            return null;
        }
        Header[] headers = response.getAllHeaders();
        String fileName = fetchFileNameFromHeaders(headers);
        if (fileName != null && fileName.contains(".")) {
            return fileName.substring(fileName.lastIndexOf(".") + 1);
        }
        return null;
    }

    public static String parseMimeType(String value) {
        String fileType = value.substring(value.indexOf("/") + 1);
        if (fileType.contains(";")) {
            int endPos = fileType.indexOf(";");
            fileType = fileType.substring(0, endPos);
        }
        return fileType;
    }

    public static String normalizeString(String string) {
        if (com.ofb.libs.utils.ObjectUtils.isBlank(string)) {
            return string;
        }
        int ch;
        StringBuilder stringBuilder = new StringBuilder();
        for (int i = 0; i < string.length(); i++) {
            ch = string.charAt(i);
            if (ch <= 127) {
                stringBuilder.append((char) ch);
            }
        }
        return stringBuilder.toString();
    }

    public static String getLinkBySibling(String query, Document document) {
        if (document.select(query).first().nextElementSibling().child(0).hasText()) {
            return document.select(query)
                .first().nextElementSibling().child(0).attr("href");
        }
        return null;
    }

    public static String getFormUrl(Document document) {
        if (!CollectionUtils.isEmpty(document.select("form"))) {
            return document.select("form").attr("action").trim();
        }
        if (CollectionUtils.isEmpty(document.select("html > body > form"))) {
            return null;
        }
        String actionUrl = document.select("html > body > form").get(0).attr("action");
        if (ObjectUtils.isEmpty(actionUrl)) {
            return null;
        }
        actionUrl = actionUrl.trim();
        return actionUrl;
    }

    public static HashMap<String, String> getSelectAndInputElements(Document doc) {
        HashMap<String, String> map = new LinkedHashMap<>();
        Elements allSelectElems = doc.select("select");
        Elements allInputElems = doc.select("input");
        for (Element element : allSelectElems) {
            String attrName = element.attr("name");
            String attrValue = element.attr("value");
            boolean valueSelected = false;
            if (ObjectUtils.isEmpty(attrValue)) {
                for (Element option : element.select("option")) {
                    if (option.hasAttr("selected")) {
                        if (option.hasAttr("value")) {
                            attrValue = option.attr("value");
                        } else {
                            attrValue = option.text();
                        }
                        valueSelected = true;
                        break;
                    }
                }
            }
            if (ObjectUtils.isEmpty(attrValue) && !valueSelected
                && !CollectionUtils.isEmpty(element.select("option"))) {
                attrValue = element.select("option").get(0).text();
            }
            boolean isMultipleType = element.hasAttr("multiple");
            if (isMultipleType) {
                continue;
            }
            if (ObjectUtils.isEmpty(attrName)) {
                continue;
            }
            map.put(attrName, attrValue);
        }

        for (Element element : allInputElems) {
            String attrName = element.attr("name");
            String attrValue = element.attr("value");
            if (!ObjectUtils.isEmpty(attrName)) {
                map.put(attrName, attrValue);
            }
        }

        return map;
    }

    public static HashMap<String, String> getHiddenInputElements(Elements doc) {
        HashMap<String, String> map = new HashMap<>();
        Elements allInputElems = doc.select("input[type=hidden]");
        for (Element element : allInputElems) {
            map.put(element.attr("name"), element.attr("value"));
        }
        return map;
    }

    public static String buildUrlFromPayload(HashMap<String, String> map) {
        URIBuilder uriBuilder = new URIBuilder();
        for (Map.Entry<String, String> entry : map.entrySet()) {
            uriBuilder.addParameter(entry.getKey(), entry.getValue());
        }
        return uriBuilder.toString().substring(1);
    }

    public static boolean isParsable(String input) {
        boolean parsable = true;
        try {
            Integer.parseInt(input);
        } catch (NumberFormatException e) {
            parsable = false;
        }
        return parsable;
    }

    public static boolean compareListOfObjects(List<?> l1, List<?> l2) {
        
        if (l1 == null && l2 == null) {
            return true;
        }
        if ((l1 == null && l2 != null) || (l2 == null && l1 != null)) {
            return false;
        }
        ArrayList<?> cp = new ArrayList<>(l1);
        for (Object o : l2) {
            if (!cp.remove(o)) {
                return false;
            }
        }
        return cp.isEmpty();
    }

    public static boolean isZipNameValid(String name) {
        Pattern pattern = Pattern.compile("work_\\d+\\.zip");
        Matcher matcher = pattern.matcher(name);
        if (matcher.find()) {
            return true;
        } else {
            return false;
        }
    }

    public static String trimSquareBraces(String input) {
        if (!ObjectUtils.isEmpty(input)) {
            if (input.startsWith("[") && input.endsWith("]")) {
                input = input.substring(1, input.length() - 1);
            }
        }
        return input;
    }

    public static String trimNbspAndSpaces(String str) {
        if (str == null) {
            return null;
        }
        return str.replaceAll(String.valueOf((char) 160), "").trim();
    }

    public static Map<String, String> getQueryMap(String query) {
        String[] params = query.split("&");
        Map<String, String> map = new HashMap<String, String>();
        for (String param : params) {
            String[] p = param.split("=");
            String name = p[0];
            if (p.length > 1) {
                String value = p[1];
                map.put(name, value);
            }
        }
        return map;
    }

    public static Double tryParseAmount(String raw) {
        try {
            return parseAmount(raw);
        } catch (Exception ex) {

        }
        return null;
    }

    public static Double parseAmount(String raw) {
        if(com.ofb.libs.utils.ObjectUtils.isBlank(raw)){
            return null;
        }
        raw=raw.replaceAll(",","");
        Pattern p = Pattern.compile("\\d*\\.\\d+|\\d+\\.\\d*$");
        Matcher m = p.matcher(raw);
        Double amt = null;
        while (m.find()) {
            String val = m.group();
            amt = Double.parseDouble(val);
            return amt*getAmtMultiplier(raw);
        }
        return null;
    }

    public static Long getAmtMultiplier(String raw) {
        Long multiplier = 1l;
        if (com.ofb.libs.utils.ObjectUtils.isNotBlank(raw)) {
            raw = raw.toLowerCase();
            if (raw.contains("crore") || raw.contains("cr")) {
                multiplier = ONE_CRORE;
            }
            else if (raw.contains("mill") || raw.contains("lakh")) {
                multiplier = 10*ONE_LAC;
            }
            else if (raw.contains("lac") || raw.contains("lakh")) {
                multiplier = ONE_LAC;
            } else if (raw.contains("thousand")) {
                multiplier = ONE_THOUSAND;
            }
        }
        return multiplier;
    }

    public static String convertDoubleToNumericString(Double val){
        if(ObjectUtils.isEmpty(val)){
            return null;
        }
        return String.format("%.2f",val);
    }

    public static Long getTimeSilently(String date, String format) {
        if (com.ofb.libs.utils.ObjectUtils.isBlank(date)) {
            return null;
        }
        try {
            return DateUtils.parse(format, date).getTime();
        } catch (Exception e) {
            logger.error(MessageFormat.format("Exception while converting date {0} to format {1} ", date, format), e);
            return null;
        }
    }
}

package com.ofb.crawler.commons.types.mca.dto;

public class ChargesDetail {
    private String chargeId ;
    private Long creationDate ;
    private Long modificationDate;
    private Long closureDate;
    private Long amount;
    private String assetsUnderCharge ;
    private String chargeHolder;
    private String status;

    public ChargesDetail() {
    }

    public ChargesDetail(String chargeId, Long creationDate, Long modificationDate, Long closureDate, Long amount,
        String assetsUnderCharge, String chargeHolder, String status) {
        this.chargeId = chargeId;
        this.creationDate = creationDate;
        this.modificationDate = modificationDate;
        this.closureDate = closureDate;
        this.amount = amount;
        this.assetsUnderCharge = assetsUnderCharge;
        this.chargeHolder = chargeHolder;
        this.status = status;
    }

    public String getChargeId() {
        return chargeId;
    }

    public void setChargeId(String chargeId) {
        this.chargeId = chargeId;
    }

    public Long getCreationDate() {
        return creationDate;
    }

    public void setCreationDate(Long creationDate) {
        this.creationDate = creationDate;
    }

    public Long getModificationDate() {
        return modificationDate;
    }

    public void setModificationDate(Long modificationDate) {
        this.modificationDate = modificationDate;
    }

    public Long getClosureDate() {
        return closureDate;
    }

    public void setClosureDate(Long closureDate) {
        this.closureDate = closureDate;
    }

    public Long getAmount() {
        return amount;
    }

    public void setAmount(Long amount) {
        this.amount = amount;
    }

    public String getAssetsUnderCharge() {
        return assetsUnderCharge;
    }

    public void setAssetsUnderCharge(String assetsUnderCharge) {
        this.assetsUnderCharge = assetsUnderCharge;
    }

    public String getChargeHolder() {
        return chargeHolder;
    }

    public void setChargeHolder(String chargeHolder) {
        this.chargeHolder = chargeHolder;
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    public static interface ChargeIdStep {
        CreationDateStep withChargeId(String chargeId);
    }

    public static interface CreationDateStep {
        ModificationDateStep withCreationDate(Long creationDate);
    }

    public static interface ModificationDateStep {
        ClosureDateStep withModificationDate(Long modificationDate);
    }

    public static interface ClosureDateStep {
        AmountStep withClosureDate(Long closureDate);
    }

    public static interface AmountStep {
        AssetsUnderChargeStep withAmount(Long amount);
    }

    public static interface AssetsUnderChargeStep {
        ChargeHolderStep withAssetsUnderCharge(String assetsUnderCharge);
    }

    public static interface ChargeHolderStep {
        StatusStep withChargeHolder(String chargeHolder);
    }

    public static interface StatusStep {
        BuildStep withStatus(String status);
    }

    public static interface BuildStep {
        ChargesDetail build();
    }

    public static class Builder
        implements ChargeIdStep, CreationDateStep, ModificationDateStep, ClosureDateStep, AmountStep,
        AssetsUnderChargeStep, ChargeHolderStep, StatusStep, BuildStep {
        private String chargeId;
        private Long creationDate;
        private Long modificationDate;
        private Long closureDate;
        private Long amount;
        private String assetsUnderCharge;
        private String chargeHolder;
        private String status;

        private Builder() {
        }

        public static ChargeIdStep chargesDetail() {
            return new Builder();
        }

        @Override
        public CreationDateStep withChargeId(String chargeId) {
            this.chargeId = chargeId;
            return this;
        }

        @Override
        public ModificationDateStep withCreationDate(Long creationDate) {
            this.creationDate = creationDate;
            return this;
        }

        @Override
        public ClosureDateStep withModificationDate(Long modificationDate) {
            this.modificationDate = modificationDate;
            return this;
        }

        @Override
        public AmountStep withClosureDate(Long closureDate) {
            this.closureDate = closureDate;
            return this;
        }

        @Override
        public AssetsUnderChargeStep withAmount(Long amount) {
            this.amount = amount;
            return this;
        }

        @Override
        public ChargeHolderStep withAssetsUnderCharge(String assetsUnderCharge) {
            this.assetsUnderCharge = assetsUnderCharge;
            return this;
        }

        @Override
        public StatusStep withChargeHolder(String chargeHolder) {
            this.chargeHolder = chargeHolder;
            return this;
        }

        @Override
        public BuildStep withStatus(String status) {
            this.status = status;
            return this;
        }

        @Override
        public ChargesDetail build() {
            return new ChargesDetail(
                this.chargeId,
                this.creationDate,
                this.modificationDate,
                this.closureDate,
                this.amount,
                this.assetsUnderCharge,
                this.chargeHolder,
                this.status
            );
        }
    }
}


package com.ofb.crawler.commons.dto;

@Data
public class CallBackResponseDto implements Serializable {

    private String requestId;

    
    private String response;

    
    private String taskResponse;

    private TaskStatus taskStatus;

    private String error;

    private TaskError taskError;

    public CallBackResponseDto() {
    }

    public CallBackResponseDto(String requestId, String response, String taskResponse,
        TaskStatus taskStatus, String error, TaskError taskError) {
        this.requestId = requestId;
        this.response = response;
        this.taskResponse = taskResponse;
        this.taskStatus = taskStatus;
        this.error = error;
        this.taskError = taskError;
    }

    public static interface RequestIdStep {
        ResponseStep withRequestId(String requestId);
    }

    public static interface ResponseStep {
        TaskResponseStep withResponse(String response);
    }

    public static interface TaskResponseStep {
        TaskStatusStep withTaskResponse(String taskResponse);
    }

    public static interface TaskStatusStep {
        ErrorStep withTaskStatus(TaskStatus taskStatus);
    }

    public static interface ErrorStep {
        TaskErrorStep withError(String error);
    }

    public static interface TaskErrorStep {
        BuildStep withTaskError(TaskError taskError);
    }

    public static interface BuildStep {
        CallBackResponseDto build();
    }

    public static class Builder
        implements RequestIdStep, ResponseStep, TaskResponseStep, TaskStatusStep, ErrorStep, TaskErrorStep, BuildStep {
        private String requestId;
        private String response;
        private String taskResponse;
        private TaskStatus taskStatus;
        private String error;
        private TaskError taskError;

        private Builder() {
        }

        public static RequestIdStep callBackResponseDto() {
            return new Builder();
        }

        @Override
        public ResponseStep withRequestId(String requestId) {
            this.requestId = requestId;
            return this;
        }

        @Override
        public TaskResponseStep withResponse(String response) {
            this.response = response;
            return this;
        }

        @Override
        public TaskStatusStep withTaskResponse(String taskResponse) {
            this.taskResponse = taskResponse;
            return this;
        }

        @Override
        public ErrorStep withTaskStatus(TaskStatus taskStatus) {
            this.taskStatus = taskStatus;
            return this;
        }

        @Override
        public TaskErrorStep withError(String error) {
            this.error = error;
            return this;
        }

        @Override
        public BuildStep withTaskError(TaskError taskError) {
            this.taskError = taskError;
            return this;
        }

        @Override
        public CallBackResponseDto build() {
            return new CallBackResponseDto(
                this.requestId,
                this.response,
                this.taskResponse,
                this.taskStatus,
                this.error,
                this.taskError
            );
        }
    }
}


package com.ofb.crawler.commons.types.litigation.itat.dto.response;

@Data
@NoArgsConstructor
public class ItatResponseDto extends BaseS3ResponseDto {

    private List<ItatResponse> itatResponseList;

    private ItatTaskParamsDto itatTaskParamsDto;

    public ItatResponseDto(List<ItatResponse> itatResponseList, ItatTaskParamsDto itatTaskParamsDto) {
        this.itatResponseList = itatResponseList;
        this.itatTaskParamsDto = itatTaskParamsDto;
    }

    public ItatResponseDto(String parsingId, TaskType taskType, long parsingTime, BaseTaskParamsDto baseTaskParamsDto, List<ItatResponse> itatResponseList, ItatTaskParamsDto itatTaskParamsDto) {
        super(parsingId, taskType, parsingTime, baseTaskParamsDto);
        this.itatResponseList = itatResponseList;
        this.itatTaskParamsDto = itatTaskParamsDto;
    }

    public static interface ParsingIdStep {
        TaskTypeStep withParsingId(String parsingId);
    }

    public static interface TaskTypeStep {
        ParsingTimeStep withTaskType(TaskType taskType);
    }

    public static interface ParsingTimeStep {
        BaseTaskParamsDtoStep withParsingTime(long parsingTime);
    }

    public static interface BaseTaskParamsDtoStep {
        ItatResponseListStep withBaseTaskParamsDto(BaseTaskParamsDto baseTaskParamsDto);
    }

    public static interface ItatResponseListStep {
        ItatTaskParamsDtoStep withItatResponseList(List<ItatResponse> itatResponseList);
    }

    public static interface ItatTaskParamsDtoStep {
        BuildStep withItatTaskParamsDto(ItatTaskParamsDto itatTaskParamsDto);
    }

    public static interface BuildStep {
        ItatResponseDto build();
    }


    public static class Builder implements ParsingIdStep, TaskTypeStep, ParsingTimeStep, BaseTaskParamsDtoStep, ItatResponseListStep, ItatTaskParamsDtoStep, BuildStep {
        private String parsingId;
        private TaskType taskType;
        private long parsingTime;
        private BaseTaskParamsDto baseTaskParamsDto;
        private List<ItatResponse> itatResponseList;
        private ItatTaskParamsDto itatTaskParamsDto;

        private Builder() {
        }

        public static ParsingIdStep itatResponseDto() {
            return new Builder();
        }

        @Override
        public TaskTypeStep withParsingId(String parsingId) {
            this.parsingId = parsingId;
            return this;
        }

        @Override
        public ParsingTimeStep withTaskType(TaskType taskType) {
            this.taskType = taskType;
            return this;
        }

        @Override
        public BaseTaskParamsDtoStep withParsingTime(long parsingTime) {
            this.parsingTime = parsingTime;
            return this;
        }

        @Override
        public ItatResponseListStep withBaseTaskParamsDto(BaseTaskParamsDto baseTaskParamsDto) {
            this.baseTaskParamsDto = baseTaskParamsDto;
            return this;
        }

        @Override
        public ItatTaskParamsDtoStep withItatResponseList(List<ItatResponse> itatResponseList) {
            this.itatResponseList = itatResponseList;
            return this;
        }

        @Override
        public BuildStep withItatTaskParamsDto(ItatTaskParamsDto itatTaskParamsDto) {
            this.itatTaskParamsDto = itatTaskParamsDto;
            return this;
        }

        @Override
        public ItatResponseDto build() {
            return new ItatResponseDto(
                    this.parsingId,
                    this.taskType,
                    this.parsingTime,
                    this.baseTaskParamsDto,
                    this.itatResponseList,
                    this.itatTaskParamsDto
            );
        }
    }
}


package com.ofb.crawler.commons.types.gstInfo.dto.task;

@Data
@NoArgsConstructor
public class GstInfoTaskResponseDto extends BaseTaskResponseDto {

    private GstInfoResponseDto gstInfoResponseDto;

    public GstInfoTaskResponseDto(GstInfoResponseDto gstInfoResponseDto) {
        this.gstInfoResponseDto = gstInfoResponseDto;
    }

    public GstInfoTaskResponseDto(String requestId, TaskType taskType, TaskStatus status, TaskError error, GstInfoResponseDto gstInfoResponseDto) {
        super(requestId, taskType, status, error);
        this.gstInfoResponseDto = gstInfoResponseDto;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        GstInfoTaskResponseDto that = (GstInfoTaskResponseDto) o;
        return Objects.equals(gstInfoResponseDto, that.gstInfoResponseDto);
    }

    @Override
    public int hashCode() {
        return Objects.hash(gstInfoResponseDto);
    }

    public static interface RequestIdStep {
        TaskTypeStep withRequestId(String requestId);
    }

    public static interface TaskTypeStep {
        StatusStep withTaskType(TaskType taskType);
    }

    public static interface StatusStep {
        ErrorStep withStatus(TaskStatus status);
    }

    public static interface ErrorStep {
        GstInfoResponseDtoStep withError(TaskError error);
    }

    public static interface GstInfoResponseDtoStep {
        BuildStep withGstInfoResponseDto(GstInfoResponseDto gstInfoResponseDto);
    }

    public static interface BuildStep {
        GstInfoTaskResponseDto build();
    }


    public static class Builder implements RequestIdStep, TaskTypeStep, StatusStep, ErrorStep, GstInfoResponseDtoStep, BuildStep {
        private String requestId;
        private TaskType taskType;
        private TaskStatus status;
        private TaskError error;
        private GstInfoResponseDto gstInfoResponseDto;

        private Builder() {
        }

        public static RequestIdStep gstInfoTaskResponseDto() {
            return new Builder();
        }

        @Override
        public TaskTypeStep withRequestId(String requestId) {
            this.requestId = requestId;
            return this;
        }

        @Override
        public StatusStep withTaskType(TaskType taskType) {
            this.taskType = taskType;
            return this;
        }

        @Override
        public ErrorStep withStatus(TaskStatus status) {
            this.status = status;
            return this;
        }

        @Override
        public GstInfoResponseDtoStep withError(TaskError error) {
            this.error = error;
            return this;
        }

        @Override
        public BuildStep withGstInfoResponseDto(GstInfoResponseDto gstInfoResponseDto) {
            this.gstInfoResponseDto = gstInfoResponseDto;
            return this;
        }

        @Override
        public GstInfoTaskResponseDto build() {
            return new GstInfoTaskResponseDto(
                    this.requestId,
                    this.taskType,
                    this.status,
                    this.error,
                    this.gstInfoResponseDto
            );
        }
    }
}


package com.ofb.crawler.core.util;

@Component
public class IpRotationUtil {

    private static final Logger logger = LoggerFactory.getLogger(IpRotationUtil.class);

    private static final Map<TaskType, TaskIpRotationInfoDto> ipRotationInfoMap = new ConcurrentHashMap<>();

    @Autowired
    private ProxyConfig proxyConfig;

    private static String proxyServerUserName = "";

    private static String proxyServerPassword = "";

    private static String proxyServerAutoUserName = "";

    private static String proxyServerAutoPassword = "";

    private static boolean isProxyEnabled = false;

    private static CloseableHttpAsyncClient defaultAsyncClient;

    private static CloseableHttpAsyncClient autoRotateIPClient;

    private static CloseableHttpAsyncClient unsafeAsyncClient;

    private static final Map<TaskType, Map<RotationIp, CloseableHttpAsyncClient>> clientPool = new ConcurrentHashMap<>();

    @PostConstruct
    private void postConstruct() {
        initCredentials();
    }

    static {
        try {
            initDefaultClient();
            initAutoRotatingClient();
            initUnsafeAsyncClient();
        } catch (Exception e) {
            logger.error("Error While Initialising ", e);
        }
    }

    public static CloseableHttpAsyncClient getUnsafeClosableAsyncClient(TaskType taskType) {
        return unsafeAsyncClient;
    }

    public static CloseableHttpAsyncClient getClosableAsyncHttpClient(TaskType taskType) {
        return getClosableAsyncHttpClient(taskType, true);
    }

    public static CloseableHttpAsyncClient getClosableAsyncHttpClient(TaskType taskType, boolean useNewIp) {
        if (!isProxyEnabled || taskType == null || !taskType.getRotateIp()) {
            return defaultAsyncClient;
        }
        if (taskType.getRotateUsingAuto()) {
            return autoRotateIPClient;
        }

        TaskIpRotationInfoDto taskIpRotationInfo = getTaskIpRotationInfo(taskType, useNewIp);
        if (taskIpRotationInfo == null) {
            return defaultAsyncClient;
        }

        List<RotationIp> ipsList = taskIpRotationInfo.getIpList();
        if (ObjectUtils.isBlankObject(ipsList)) {
            return defaultAsyncClient;
        }

        RotationIp rotationIp = ipsList.get(taskIpRotationInfo.getCurrentIpIndex());

        return getOrCreateClientWithProxy(taskType, rotationIp);
    }

    public static CloseableHttpAsyncClient getClosableAsyncHttpClientWithSpecificIp(TaskType taskType, RotationIp rotationIp) {
        if (!isProxyEnabled) {
            return null;
        }
        if (rotationIp == null) {
            return null;
        }

        HttpHost proxy = new HttpHost(rotationIp.getActualIp(), rotationIp.getPort());
        CredentialsProvider credentialsProvider = new BasicCredentialsProvider();
        credentialsProvider.setCredentials(new AuthScope(proxy),
            new UsernamePasswordCredentials(proxyServerUserName, proxyServerPassword));

        return HttpAsyncClients.custom()
            .setProxy(proxy)
            .setDefaultCredentialsProvider(credentialsProvider)
            .build();
    }

    private static CloseableHttpAsyncClient getOrCreateClientWithProxy(TaskType taskType, RotationIp rotationIp) {

        Map<RotationIp, CloseableHttpAsyncClient> ipToClient =
            clientPool.computeIfAbsent(taskType, k -> new ConcurrentHashMap<>());

        CloseableHttpAsyncClient client = ipToClient.get(rotationIp);

        if (client != null) {
            return client;
        }

        IOReactorConfig ioReactorConfig = IOReactorConfig.custom()
            .setIoThreadCount(Runtime.getRuntime().availableProcessors())
            .setConnectTimeout(30000)
            .setSoTimeout(30000)
            .build();
        PoolingNHttpClientConnectionManager cm;
        try {
            cm = new PoolingNHttpClientConnectionManager(new DefaultConnectingIOReactor(ioReactorConfig, null));
        } catch (IOReactorException e) {
            logger.error("Unable to get PoolingNHttpClientConnectionManager", e);
            return defaultAsyncClient;
        }
        cm.setMaxTotal(100);
        cm.setDefaultMaxPerRoute(10);

        HttpHost proxy = new HttpHost(rotationIp.getActualIp(), rotationIp.getPort());
        CredentialsProvider credentialsProvider = new BasicCredentialsProvider();
        credentialsProvider.setCredentials(new AuthScope(proxy),
            new UsernamePasswordCredentials(proxyServerUserName, proxyServerPassword));

        client = HttpAsyncClients.custom()
            .setConnectionManager(cm)
            .setProxy(proxy)
            .setDefaultCredentialsProvider(credentialsProvider)
            .build();
        client.start();

        ipToClient.put(rotationIp, client);
        clientPool.put(taskType, ipToClient);

        return client;
    }

    private static TaskIpRotationInfoDto getTaskIpRotationInfo(TaskType taskType, boolean useNewIp) {
        TaskIpRotationInfoDto ipRotationInfo = ipRotationInfoMap.get(taskType);
        if (ipRotationInfo == null) {
            ipRotationInfo = TaskIpRotationInfoDto.Builder.taskIpRotationInfoDto()
                    .withTaskType(taskType)
                    .withCurrentIpIndex(0)
                    .withIpList(taskType.getIpsList())
                    .build();
        } else if (useNewIp) {
            int currentIpIndex = ipRotationInfo.getCurrentIpIndex();
            if (currentIpIndex >= (taskType.getIpsList().size() - 1)) {
                currentIpIndex = 0;
            } else {
                currentIpIndex = currentIpIndex + 1;
            }
            ipRotationInfo.setCurrentIpIndex(currentIpIndex);
        }
        ipRotationInfoMap.put(taskType, ipRotationInfo);

        return ipRotationInfo;
    }

    

    private void initCredentials() {
        isProxyEnabled = proxyConfig.getEnableProxy();
        proxyServerUserName = proxyConfig.getProxyServerUserName();
        proxyServerPassword = proxyConfig.getProxyServerPassword();
        proxyServerAutoUserName = proxyConfig.getProxyServerAutoUserName();
        proxyServerAutoPassword = proxyConfig.getProxyServerAutoPassword();
    }

    private static void initDefaultClient() throws IOReactorException {
        IOReactorConfig ioReactorConfig = IOReactorConfig.custom()
            .setIoThreadCount(Runtime.getRuntime().availableProcessors())
            .setConnectTimeout(120000)
            .setSoTimeout(120000)
            .build();
        PoolingNHttpClientConnectionManager cm =
            new PoolingNHttpClientConnectionManager(new DefaultConnectingIOReactor(ioReactorConfig, null));
        cm.setMaxTotal(500);
        
        cm.setDefaultMaxPerRoute(15);
        defaultAsyncClient = HttpAsyncClients.custom()
            .setConnectionManager(cm)
            .build();
        defaultAsyncClient.start();
    }

    private static void initUnsafeAsyncClient()
        throws IOReactorException, NoSuchAlgorithmException, KeyStoreException, KeyManagementException {
        ConnectingIOReactor ioreactor = new DefaultConnectingIOReactor(IOReactorConfig.custom()
            .setIoThreadCount(Runtime.getRuntime().availableProcessors())
            .setConnectTimeout(30000)
            .setSoTimeout(30000)
            .build(), null);

        TrustStrategy acceptingTrustStrategy = (certificate, authType) -> true;
        SSLIOSessionStrategy reuseStrategy = new SSLIOSessionStrategy(SSLContexts.custom()
            .loadTrustMaterial(null, acceptingTrustStrategy)
            .build(), null, null, (HostnameVerifier)null);

        Registry<SchemeIOSessionStrategy> build = RegistryBuilder.<SchemeIOSessionStrategy>create()
            .register("http", NoopIOSessionStrategy.INSTANCE)
            .register("https", reuseStrategy)
            .build();
        PoolingNHttpClientConnectionManager poolingmgr = new PoolingNHttpClientConnectionManager(ioreactor, build);
        
        poolingmgr.setMaxTotal(100);
        poolingmgr.setDefaultMaxPerRoute(10);

        unsafeAsyncClient = HttpAsyncClientBuilder.create()
            .setSSLHostnameVerifier(NoopHostnameVerifier.INSTANCE)
            .setConnectionManager(poolingmgr)
            .setSSLContext(SSLContexts.custom()
                .loadTrustMaterial(null, acceptingTrustStrategy)
                .build())
            .build();
        unsafeAsyncClient.start();
    }

    private static void initAutoRotatingClient() {
        IOReactorConfig ioReactorConfig = IOReactorConfig.custom()
            .setIoThreadCount(Runtime.getRuntime().availableProcessors())
            .setConnectTimeout(30000)
            .setSoTimeout(30000)
            .build();
        PoolingNHttpClientConnectionManager cm;
        try {
            cm = new PoolingNHttpClientConnectionManager(new DefaultConnectingIOReactor(ioReactorConfig, null));
        } catch (IOReactorException e) {
            logger.error("Unable to get PoolingNHttpClientConnectionManager", e);
            autoRotateIPClient = defaultAsyncClient;
            return;
        }
        
        cm.setMaxTotal(100);
        cm.setDefaultMaxPerRoute(10);

        RotationIp rotationIp = RotationIp.AUTO;
        HttpHost proxy = new HttpHost(rotationIp.getActualIp(), rotationIp.getPort());
        CredentialsProvider credentialsProvider = new BasicCredentialsProvider();
        credentialsProvider.setCredentials(new AuthScope(proxy),
            new UsernamePasswordCredentials(proxyServerAutoUserName, proxyServerAutoPassword));

        autoRotateIPClient = HttpAsyncClients.custom()
            .setConnectionManager(cm)
            .setProxy(proxy)
            .setDefaultCredentialsProvider(credentialsProvider)
            .build();
        autoRotateIPClient.start();
    }

    
}


package com.ofb.crawler.commons.types.gstReturn.dto.task;

@Data
@NoArgsConstructor
public class GstReturnTaskResponseDto extends BaseTaskResponseDto {

    private GstReturnResponseDto gstReturnResponseDto;

    public GstReturnTaskResponseDto(GstReturnResponseDto gstReturnResponseDto) {
        this.gstReturnResponseDto = gstReturnResponseDto;
    }

    public GstReturnTaskResponseDto(String requestId, TaskType taskType, TaskStatus status, TaskError error, GstReturnResponseDto gstReturnResponseDto) {
        super(requestId, taskType, status, error);
        this.gstReturnResponseDto = gstReturnResponseDto;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        GstReturnTaskResponseDto that = (GstReturnTaskResponseDto) o;
        return Objects.equals(gstReturnResponseDto, that.gstReturnResponseDto);
    }

    @Override
    public int hashCode() {
        return Objects.hash(gstReturnResponseDto);
    }

    public static interface RequestIdStep {
        TaskTypeStep withRequestId(String requestId);
    }

    public static interface TaskTypeStep {
        StatusStep withTaskType(TaskType taskType);
    }

    public static interface StatusStep {
        ErrorStep withStatus(TaskStatus status);
    }

    public static interface ErrorStep {
        GstReturnResponseDtoStep withError(TaskError error);
    }

    public static interface GstReturnResponseDtoStep {
        BuildStep withGstReturnResponseDto(GstReturnResponseDto gstReturnResponseDto);
    }

    public static interface BuildStep {
        GstReturnTaskResponseDto build();
    }


    public static class Builder implements RequestIdStep, TaskTypeStep, StatusStep, ErrorStep, GstReturnResponseDtoStep, BuildStep {
        private String requestId;
        private TaskType taskType;
        private TaskStatus status;
        private TaskError error;
        private GstReturnResponseDto gstReturnResponseDto;

        private Builder() {
        }

        public static RequestIdStep gstReturnTaskResponseDto() {
            return new Builder();
        }

        @Override
        public TaskTypeStep withRequestId(String requestId) {
            this.requestId = requestId;
            return this;
        }

        @Override
        public StatusStep withTaskType(TaskType taskType) {
            this.taskType = taskType;
            return this;
        }

        @Override
        public ErrorStep withStatus(TaskStatus status) {
            this.status = status;
            return this;
        }

        @Override
        public GstReturnResponseDtoStep withError(TaskError error) {
            this.error = error;
            return this;
        }

        @Override
        public BuildStep withGstReturnResponseDto(GstReturnResponseDto gstReturnResponseDto) {
            this.gstReturnResponseDto = gstReturnResponseDto;
            return this;
        }

        @Override
        public GstReturnTaskResponseDto build() {
            return new GstReturnTaskResponseDto(
                    this.requestId,
                    this.taskType,
                    this.status,
                    this.error,
                    this.gstReturnResponseDto
            );
        }
    }
}


package com.ofb.crawler.core.util;

public class UrlUtils {

    private static final Logger logger = LoggerFactory.getLogger(UrlUtils.class);

    private static final String pattern = "[\"<>#%{}|\\^~`\\[\\]]";

    
    private static final Map<Character, String> UNSAFE_CHAR_MAP = new HashMap() {{
        put(' ', "%20");
        put('#', "%23");
        put('%', "%25");
        put('{', "%7B");
        put('}', "%7D");
        put('|', "%7C");
        put('\\', "%5C");
        put('^', "%5E");
        put('~', "%7E");
        put('[', "%5B");
        put(']', "%5D");
        put('`', "%60");
        put('\"', "%22");
        put('<', "%3C");
        put('>', "%3E");
    }};

    public static String encodeUrl(String base) throws URISyntaxException {
        if (base == null) {
            return null;
        }
        base = removeDirPeriodsFromUrl(base);
        if (base.contains("%3D")) {
            return base;
        }
        if (!base.contains("?")) {
            return encodeUrlNotContainingParams(base);
        }
        String basePath = base.substring(0, base.indexOf("?"));
        String queryPath = base.substring(base.indexOf("?") + 1);

        URIBuilder uriBuilder = new URIBuilder(basePath);
        String paramName;
        String paramValue;
        int indexOfEqualSign;
        String url = basePath + "?" + UriEncoder.encode(queryPath);



















        if (url.startsWith("/src/main")) {
            url = url.replaceFirst("/src/main", "..");
        }
        return url;
    }

    public static String encodeUrlNotContainingParams(String base) {
        return base.replaceAll("\\s", "%20").replace("[", "%5B")
                .replace("]", "%5D");
    }

    public static String removeDirPeriodsFromUrl(String completeUrl) {
        final String mainUrlPath;
        String srcUrl;
        try {
            URL url = new URL(completeUrl);
            srcUrl = url.getPath();
        } catch (MalformedURLException e) {
            srcUrl = completeUrl;
        }
        mainUrlPath = srcUrl;

        if (srcUrl.indexOf("src/main") <= 0) {
            return completeUrl;
        }
        if (srcUrl.charAt(srcUrl.indexOf("src/main") - 1) != '/') {
            srcUrl = srcUrl.substring(0, srcUrl.indexOf("src/main")) + "/" + srcUrl.substring(srcUrl.indexOf(
                "src/main"));
        }
        int start = srcUrl.indexOf("src/main");
        int count = 1;
        int current = start;
        while (srcUrl.indexOf("src/main", current + 2) >= 0) {
            count++;
            current = srcUrl.indexOf("src/main", current + 2);
        }
        int startSecondPart = start + count * 3;
        String reverse = new StringBuffer(srcUrl.substring(0, start - 1)).reverse().toString();
        int endIndex = 0;
        while (count-- > 0) {
            endIndex = reverse.indexOf("/", endIndex + 1);
        }
        String effectiveUrl = srcUrl.substring(0, reverse.length() - endIndex) + srcUrl.substring(startSecondPart);
        return completeUrl.replaceAll(mainUrlPath, effectiveUrl);
    }

    public static String encodeParamValue(String paramValue) {
        return paramValue
                .replaceAll(" ", "+")
                .replaceAll(",", "%2C")
                .replaceAll(":", "%3A");
    }

    public static String parseFileType(String fileName) {
        fileName = fileName.toLowerCase();

        String ext = fileName.substring(fileName.lastIndexOf(".") + 1);
        if (ext.contains(" ")) {
            ext = ext.substring(0, ext.indexOf(" "));
        }
        if (ext.endsWith("_") || ext.endsWith("-")) {
            ext = ext.substring(0, ext.length() - 1);
        }
        if (fileName.contains("vnd")) {
            ext = fileName.substring(fileName.indexOf("vnd"));

        }
        return ext;
    }

    public static boolean isStringEncoded(String queryString) throws UnsupportedEncodingException {
        String decoded = URLDecoder.decode(queryString, StandardCharsets.UTF_8.name());
        if (decoded.equals(queryString)) {
            return false;
        }
        return true;
    }

    public static String parseFileNameFromUrl(String fileUrl) {
        if (ObjectUtils.isEmpty(fileUrl)) {
            return null;
        }
        int startIndex = fileUrl.lastIndexOf("/") + 1;
        String fileName = fileUrl.substring(startIndex);
        return fileName;
    }

    public static String parseFileNameFromUrlLastParam(String fileUrl) {
        if (ObjectUtils.isEmpty(fileUrl)) {
            return null;
        }
        String fileName = fileUrl.substring(fileUrl.lastIndexOf("=") + 1);
        return fileName;
    }

    public static String encodeUnsafeChars(String url) {
        



        
        boolean foundUnsafeChar = false;
        for (char ch : url.toCharArray()) {
            if (UNSAFE_CHAR_MAP.containsKey(ch)) {
                foundUnsafeChar = true;
            }
        }
        if (!foundUnsafeChar) {
            return url;
        }
        StringBuilder sb = new StringBuilder();
        for (char ch : url.toCharArray()) {
            if (UNSAFE_CHAR_MAP.containsKey(ch)) {
                sb.append(UNSAFE_CHAR_MAP.get(ch));
            } else {
                sb.append(ch);
            }
        }
        return sb.toString();
    }

    public static boolean isHtmlUrl(String fileUrl) {
        if (fileUrl == null) {
            return false;
        }
        if (fileUrl.endsWith(".asp") || fileUrl.endsWith(".aspx")) {
            return true;
        }
        if (fileUrl.endsWith(".html") || fileUrl.endsWith(".htm")) {
            return true;
        }
        return false;
    }

    public static String getDomainName(String completeUrl) throws MalformedURLException {
        return new URL(completeUrl).getHost();
    }
}


package com.ofb.crawler.core.types.litigation.itat.service;

@Service
public class ItatParserCallback extends BaseParserCallback<ItatResponseDto, ItatTaskParamsDto> {

    private static final Logger logger = LoggerFactory.getLogger(ItatParserCallback.class);

    private static final String homePageUrl = "https:

    private static final String captchaFileNameUrl = "https:

    private static final String judicialDetailUrl = "https:

    private static final String CAPTCHA_SERVER_END_POINT = "/itat/captcha";

    private static List<String> benches = null;

    private static List<String> appealTypes = null;

    private static Long benchLastFetchedAt = null;

    private static final Integer NUMBER_OF_ATTEMPTS_TO_BREAK_CAPTCHA = 5;

    private static final int THREAD_COUNT = 8;

    private static List<RotationIp> ipList = IPS_FOR_ITAT;

    private static IpDistributor IP_DISTRIBUTOR = new IpDistributor(TaskType.LITIGATION_ITAT_CASE, ipList, 64);

    private static Long sanitizeIpTime = 0L;


    @Override
    public ItatResponseDto parse(ItatTaskParamsDto parsingParams) throws Throwable {
        return ItatResponseDto.Builder.itatResponseDto()
            .withParsingId(String.valueOf(UUID.randomUUID()))
            .withTaskType(getTaskType())
            .withParsingTime(System.currentTimeMillis())
            .withBaseTaskParamsDto(null)
            .withItatResponseList(getDetails(parsingParams.getCompanyName(), parsingParams.getRequestId()))
            .withItatTaskParamsDto(parsingParams)
            .build();
    }

    private static List<ItatResponse> getDetails(String assesseeName, String requestId) throws Exception {
        List<ItatResponse> itatResponseList = new ArrayList<>();
        List<Callable<List<ItatResponse>>> callables = new ArrayList<>();
        Long startTime = System.currentTimeMillis();
        sanitizeIps();
        if (ObjectUtils.isBlankObject(ipList)) {
            throw new RequestParsingException("Proxies Exhausted in ItatParserCallback",
                TaskError.PROXY_IPS_EXHAUSTED);
        }
        int ipListSize = ipList.size();
        getCleanedNameIfValid(assesseeName);
        Integer iterator = 1;
        populateBenchesAndAppealTypes();
        for (String bench : benches) {
            for (String appealType : appealTypes) {
                File tempFile = getTempFile(TaskType.LITIGATION_ITAT_CASE, "captcha/Captcha", ".jpeg");
                Integer finalIterator = iterator;
                callables.add(() -> {
                    IpInfoIpDistributor ip = IP_DISTRIBUTOR.getAvailableIp();
                    try {
                        List<ItatResponse> itatResponses = new ArrayList<>();
                        try {
                            itatResponses =
                                getDetailsForBenchAndAppealType(bench, appealType, assesseeName,
                                    ip.getRotationIp(), tempFile);
                        } catch (Exception e) {
                            logger.error("Error while parsing bench [{}], appealType : [{}], assessee : [{}], {}",
                                bench, appealType, assesseeName, e);
                        } finally {
                            FileUtils.deleteSilently(tempFile);
                        }
                        logger.info(String.format("Combination number %d completed", finalIterator));
                        return itatResponses;
                    }
                    finally {
                        IP_DISTRIBUTOR.markIpAsAvailable(ip);
                    }
                });
                iterator++;
            }
        }
        ExecutorService executorService = ExecutorServicesPool.fixedThreadPool(requestId, THREAD_COUNT);
        try {
            List<Future<List<ItatResponse>>> futures = executorService.invokeAll(callables);
            for (Future<List<ItatResponse>> future : futures) {
                try {
                    itatResponseList.addAll(future.get());
                } catch (Exception e) {
                    logger.error("Failed to get future response: ", e);
                }
            }
            Long endTime = System.currentTimeMillis();
            logger.info(String.format("ParserCallBack for this API took %d seconds", (endTime - startTime) / 1000));
            return itatResponseList;
        }
        finally {
            ExecutorServicesPool.shutDownExecutorService(requestId);
        }
    }

    private synchronized static void sanitizeIps() throws RequestParsingException {
        if (System.currentTimeMillis() - sanitizeIpTime < DateUtils.HOUR * 6) {
            return;
        }
        List<RotationIp> sanitizedIpList = new ArrayList<>(ipList);
        for (RotationIp rotationIp : ipList) {
            HttpResponse httpResponse = null;
            String apiResponse = null;
            int statusCode = 0;
            Map<String, String> apiHeaders = new HashMap<>();
            apiHeaders.put("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like "
                    + "Gecko) Chrome/121.0.0.0 Safari/537.36");
            try {
                httpResponse = HttpAsyncClientUtils.getHttpResponseWithSpecifIp(TaskType.LITIGATION_ITAT_CASE, homePageUrl,
                        apiHeaders, 120 * 1000, rotationIp);
                apiResponse = getStringResponse(httpResponse);
                statusCode = httpResponse.getStatusLine().getStatusCode();
            } catch (Exception e) {
                logger.error("Failed to fetch bench and appeal type for ITAT", e);
            } finally {
                if (httpResponse != null) {
                    EntityUtils.consumeQuietly(httpResponse.getEntity());
                }
            }
            
            
            
            
            if (statusCode == 200 && "".equals(apiResponse)) {
                GoogleChatAlertUtil.sendProxyIPFailureAlert(TaskType.LITIGATION_ITAT_CASE,
                    rotationIp.getActualIp() + ":" + rotationIp.getPort(), sanitizedIpList.size() - 1);
                logger.info("Removing proxy from ItatParserCallback IpList - IP: {}", rotationIp);
                sanitizedIpList.remove(rotationIp);
            }
        }
        sanitizeIpTime = System.currentTimeMillis();
        ipList = sanitizedIpList;
        IP_DISTRIBUTOR = new IpDistributor(TaskType.LITIGATION_ITAT_CASE, ipList, 64);
    }

    private synchronized static void populateBenchesAndAppealTypes() throws Exception {
        Long startTime = System.currentTimeMillis();
        if (ObjectUtils.isBlankObject(benches) || ObjectUtils.isBlankObject(appealTypes)) {
            IpInfoIpDistributor ip = IP_DISTRIBUTOR.getAvailableIp();
            try {
                getBenchAndAppealType(ip.getRotationIp());
            } catch (Exception e) {
                logger.error("Caught exception while fetching bench and appeal type in ItatParserCallback", e);
            }
            finally {
                IP_DISTRIBUTOR.markIpAsAvailable(ip);
            }
        } else {
            if (startTime - benchLastFetchedAt > DateUtils.DAY * 30) {
                IpInfoIpDistributor ip = IP_DISTRIBUTOR.getAvailableIp();
                try {
                    getBenchAndAppealType(ip.getRotationIp());
                } catch (Exception e) {
                    logger.error("Caught exception while fetching bench and appeal type in ItatParserCallback", e);
                }
                finally {
                    IP_DISTRIBUTOR.markIpAsAvailable(ip);
                }
            }
        }
        if (ObjectUtils.isBlankObject(benches) || ObjectUtils.isBlankObject(appealTypes)) {
            throw new RequestParsingException("Failed to fetch benches and appeal types in ItatParserCallback",
                TaskError.SERVER_DOWN);
        }
    }

    private static List<ItatResponse> getDetailsForBenchAndAppealType(String bench, String appealType,
        String assesseeName, RotationIp rotationIp, File tempFile) {

        for (Integer captchaAttemptNumber = 0; captchaAttemptNumber < NUMBER_OF_ATTEMPTS_TO_BREAK_CAPTCHA;
            captchaAttemptNumber++) {
            try {
                List<ItatResponse> itatResponseListForBenchAndAppealType =
                    getCaptchaAndTry(tempFile, assesseeName, bench, appealType, rotationIp);
                if (itatResponseListForBenchAndAppealType != null) {
                    return itatResponseListForBenchAndAppealType;
                }
            } catch (RequestParsingException e) {
                if (e.getTaskError() == TaskError.PROXY_IP_BLOCKED) {
                    logger.error("No response received from detail page due to ip block", e);
                    break;
                }
            } catch (Exception e) {
                logger.error(String.format("Failed to parse cases for assessee : %s, bench : %s and appeal type : %s",
                    assesseeName, bench, appealType), e);
            }

        }
        logger.info(
            String.format("Unable to break captcha, max attempts reached blocked for bench : %s and appeal type "
                    + ": %s", bench,
                appealType));
        return new ArrayList<>();
    }

    private static List<ItatResponse> getCaptchaAndTry(File tempFile, String assesseeName, String bench,
        String appealType, RotationIp rotationIp) throws Exception {
        Pair<String, String> captchaResponses = getCaptchaUrl(rotationIp);
        String captchaUrl = captchaResponses.getFirst();
        String captchaCookies = captchaResponses.getSecond();
        if (ObjectUtils.isBlank(captchaUrl) || ObjectUtils.isBlank(captchaCookies)) {
            return null;
        }
        CaptchaSaver.saveCaptchaImageWithSpecificIp(TaskType.LITIGATION_ITAT_CASE, captchaUrl,
            getHeaders(captchaCookies), tempFile, rotationIp);
        File clearFile = PreProcessCaptcha.preProcessImage(TaskType.LITIGATION_ITAT_CASE, tempFile);
        String captchaResult = CaptchaServer.solveCaptchaNew(CAPTCHA_SERVER_END_POINT, clearFile);
        FileUtils.deleteSilently(clearFile);
        if (captchaResult.length() != 6) {
            return null;
        }
        return getItatCaseInfo(captchaResult, captchaCookies, assesseeName, bench, appealType, rotationIp);
    }

    private static List<ItatResponse> getItatCaseInfo(String captchaResult, String cookie, String assesseeName,
        String bench, String appealType, RotationIp rotationIp) throws Exception {
        String apiResponse;
        String cleanedAssesseeName = getCleanedNameIfValid(assesseeName);
        try {
            HashMap<String, String> apiHeaders = new HashMap<>();
            apiHeaders.put("Content-Type", "application/x-www-form-urlencoded");
            apiHeaders.put("Cookie", cookie);
            apiHeaders.put("User-Agent","Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like "
                + "Gecko) Chrome/121.0.0.0 Safari/537.36");

            List<BasicNameValuePair> formData = new ArrayList<>();
            formData.add(new BasicNameValuePair("bench3", bench));
            formData.add(new BasicNameValuePair("appeal_type3", appealType));
            formData.add(new BasicNameValuePair("btnSubmit3", "submit3"));
            formData.add(new BasicNameValuePair("assesse_name",
                cleanedAssesseeName.substring(0, Math.min(cleanedAssesseeName.length(), 20))));
            formData.add(new BasicNameValuePair("userCaptcha3", captchaResult));
            String encodedFormData = encodeFormData(formData);
            HttpEntity multiPartEntity = new StringEntity(encodedFormData, StandardCharsets.UTF_8);

            apiResponse = HttpAsyncClientUtils.putOrPostWithSpecificIp(TaskType.LITIGATION_ITAT_CASE, HttpMethod.POST,
                homePageUrl, multiPartEntity,
                apiHeaders, 90 * 1000, rotationIp);
        } catch (Exception e) {
            logger.error(String.format(
                "Error occurred while fetching cases for company : %s, bench : %s and appeal type : %s, trying again",
                assesseeName, bench, appealType), e);
            return null;
        }

        if (ObjectUtils.isBlank(apiResponse)) {
            if ("".equals(apiResponse)) {
                throw new RequestParsingException("Ip has been blocked : " + rotationIp, TaskError.PROXY_IP_BLOCKED);
            }
            return null;
        }

        if (apiResponse.contains("Please Enter Valid Captcha!")) {
            return null;
        }

        List<ItatResponse> itatResponseList = new ArrayList<>();
        Document doc = Jsoup.parse(apiResponse);
        Elements tables = doc.select("table.searchtble");
        if (tables.size() == 0) {
            return itatResponseList;
        }
        Element table = tables.get(0);
        Elements tableRows = table.select("tbody tr");
        tableRows.forEach(
            tableRow -> {
                String csrf_test_name = tableRow.select("input[name=csrf_test_name]").attr("value");
                String btnDetail = tableRow.select("button[name=btnDetail]").attr("value");
                String petitioner = tableRow.select("td[data-label=Appellant]").text().trim();
                String respondent = tableRow.select("td[data-label=Respondent]").text().trim();
                if (LitigationUtils.rejectCase(SetUtils.newSet(petitioner), SetUtils.newSet(respondent),
                    assesseeName)) {
                    return;
                }
                ItatResponse itatResponse = null;
                try {
                    itatResponse =
                        getJudicialDetail(cookie, csrf_test_name, btnDetail, appealType, assesseeName, rotationIp);
                } catch (ParseException e) {
                    logger.error(
                        String.format("Failed to parse response for assessee : %s and appeal type : %s", assesseeName,
                            appealType), e);
                }
                if (itatResponse != null) {
                    itatResponseList.add(itatResponse);
                }
            }
        );
        return itatResponseList;
    }

    private static ItatResponse getJudicialDetail(String cookie, String csrf_test_name, String btnDetail,
        String appealType, String assesseeName, RotationIp rotationIp) throws ParseException {
        String apiResponse;
        try {
            HashMap<String, String> apiHeaders = new HashMap<>();
            apiHeaders.put("Content-Type", "application/x-www-form-urlencoded");
            apiHeaders.put("Cookie", addCsrfToCookie(cookie, csrf_test_name));
            apiHeaders.put("User-Agent","Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like "
                + "Gecko) Chrome/121.0.0.0 Safari/537.36");

            List<BasicNameValuePair> formData = new ArrayList<>();
            formData.add(new BasicNameValuePair("csrf_test_name", csrf_test_name));
            formData.add(new BasicNameValuePair("btnDetail", btnDetail));
            String encodedFormData = encodeFormData(formData);
            HttpEntity multiPartEntity = new StringEntity(encodedFormData, StandardCharsets.UTF_8);

            apiResponse = HttpAsyncClientUtils.putOrPostWithSpecificIp(TaskType.LITIGATION_ITAT_CASE, HttpMethod.POST,
                judicialDetailUrl, multiPartEntity,
                apiHeaders, 90 * 1000, rotationIp);
        } catch (Exception e) {
            logger.error("Error occurred while fetching case data, skipping this case.", e);
            return null;
        }

        if (ObjectUtils.isBlank(apiResponse)) {
            return null;
        }

        return parseDetailsFromResponse(apiResponse, appealType, assesseeName);
    }

    private static String addCsrfToCookie(String cookie, String csrfTestName) {
        return cookie + "csrf_cookie_name=" + csrfTestName + ";";
    }

    private static ItatResponse parseDetailsFromResponse(String apiResponse, String appealType, String assesseeName)
        throws ParseException {
        Document doc = Jsoup.parse(apiResponse);
        Elements tables = doc.select("#tSummary");
        if (tables.size() == 0) {
            return null;
        }
        Element table1 = tables.get(0);
        Element table2 = tables.get(1);
        String hrefValue = null;
        String orderDate = table2.select("td[data-label='Date of Order']").text();
        String result = table2.select("td[data-label='Result']").text();
        Element orderDownloadLink = table2.select("td[data-label='Order Link'] a").first();
        if ("No record found".equalsIgnoreCase(orderDate.trim())) {
            orderDate = null;
        }
        if ("No record found".equalsIgnoreCase(result.trim())) {
            result = null;
        }
        if (orderDownloadLink != null) {
            hrefValue = orderDownloadLink.attr("href");
            String regex = " ";
            Pattern pattern = Pattern.compile(regex);
            Matcher matcher = pattern.matcher(hrefValue);
            hrefValue = matcher.replaceAll("%20");
        }

        SimpleDateFormat dateFormat = new SimpleDateFormat("dd-MM-yyyy");
        String filingDate = removeHtmlTags(table1.select("td[data-label='Filed On']").text());
        orderDate = removeHtmlTags(orderDate);
        String lastHearingDate = doc.select("th:contains(Date of Last Hearing) + td").text();
        String nextHearingDate = doc.select("th:contains(Date of Next Hearing) + td").text();

        ItatResponse itatResponse = ItatResponse.Builder.itatResponse()
            .withAppealNumber(removeHtmlTags(table1.select("td[data-label='Appeal Number']").text()))
            .withFilingDate(ObjectUtils.isNotBlank(filingDate) ? dateFormat.parse(filingDate).getTime() : null)
            .withCaseStatus(removeHtmlTags(table1.select("td[data-label='Case Status']").text()))
            .withAssessmentYear(removeHtmlTags(table1.select("td[data-label='Assessment Year']").text()))
            .withBench(removeHtmlTags(table1.select("td[data-label='Bench Allotted']").text()))
            .withRespondentName(removeHtmlTags(table1.select("td[data-label='Respondent']").text()))
            .withAppellantName(removeHtmlTags(table1.select("td[data-label='Appellant']").text()))
            .withAppealType(appealType)
            .withOrderDownloadLink(removeHtmlTags(hrefValue))
            .withDateOfOrder(ObjectUtils.isNotBlank(orderDate) ? dateFormat.parse(orderDate).getTime() : null)
            .withOrderResult(removeHtmlTags(result))
            .withLastHearingDate(
                ObjectUtils.isNotBlank(lastHearingDate) ? dateFormat.parse(lastHearingDate).getTime() : null)
            .withNextHearingDate(
                ObjectUtils.isNotBlank(nextHearingDate) ? dateFormat.parse(nextHearingDate).getTime() : null)
            .withMatchedWith(null)
            .withSystemAssignedStatus(SystemAssignedStatus.PENDING)
            .withPartyInvolvement(PartyInvolvement.UNKNOWN)
            .withDetailUrl(homePageUrl)
            .build();

        Set<String> petetionerSet = new HashSet<>();
        petetionerSet.add(itatResponse.getAppellantName());
        Set<String> respondentSet = new HashSet<>();
        respondentSet.add(itatResponse.getRespondentName());
        InvolvementAndMatchDto
            involvementAndMatchDto = LitigationUtils.getPartyInvolvementAndMatchingStatus(assesseeName, petetionerSet, respondentSet);
        itatResponse.setPartyInvolvement(involvementAndMatchDto.getPartyInvolvement());
        itatResponse.setMatchedWith(involvementAndMatchDto.getMatchedWith());
        itatResponse.setSystemAssignedStatus(involvementAndMatchDto.getSystemAssignedStatus());
        return itatResponse;
    }

    public static String removeHtmlTags(String input) {
        if (input == null) {
            return null;
        }
        String regex = "<[^>]*>";
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(input);
        String result = matcher.replaceAll("");
        return result;
    }

    private static String encodeFormData(List<BasicNameValuePair> formData) throws UnsupportedEncodingException {
        StringBuilder encodedForm = new StringBuilder();

        for (BasicNameValuePair pair : formData) {
            if (encodedForm.length() > 0) {
                encodedForm.append("&");
            }
            encodedForm.append(URLEncoder.encode(pair.getName(), StandardCharsets.UTF_8.toString()));
            encodedForm.append("=");
            encodedForm.append(URLEncoder.encode(pair.getValue(), StandardCharsets.UTF_8.toString()));
        }

        return encodedForm.toString();
    }

    private static String extractCaptchaUrl(String htmlString) {
        Document doc = Jsoup.parse(htmlString);
        Element imgElement = doc.select("img").first();

        if (imgElement != null) {
            return imgElement.attr("src");
        } else {
            return "";
        }
    }

    private static Pair<String, String> getCaptchaUrl(RotationIp rotationIp) {
        HttpResponse httpResponse = null;
        String htmlStringResponse = null;
        StringBuilder cookies = new StringBuilder();
        HttpEntity requestEntity = null;
        HashMap<String, String> apiHeaders = new HashMap<>();
        apiHeaders.put("User-Agent","Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like "
            + "Gecko) Chrome/121.0.0.0 Safari/537.36");
        try {
            httpResponse = HttpAsyncClientUtils.putOrPostAndGetHttpResponseWithSpecificIp(TaskType.LITIGATION_ITAT_CASE,
                HttpMethod.POST, captchaFileNameUrl, requestEntity, apiHeaders, 90 * 1000, rotationIp);
            htmlStringResponse = getStringResponse(httpResponse);
            Header[] responseHeaders = httpResponse.getHeaders("Set-Cookie");
            for (int i = 0; i < responseHeaders.length; i++) {
                cookies.append(responseHeaders[i].getValue().split(";")[0]);
                if (i != cookies.length() - 1) {
                    cookies.append(";");
                }
            }
        } catch (Exception e) {
            logger.error("Exception while getting captcha url", e);
            return null;
        } finally {
            if (httpResponse != null) {
                EntityUtils.consumeQuietly(httpResponse.getEntity());
            }
        }
        Pair<String, String> responses = new Pair<>();
        responses.setFirst(extractCaptchaUrl(htmlStringResponse));
        responses.setSecond(cookies.toString());
        return responses;
    }

    private static void getBenchAndAppealType(RotationIp rotationIp) throws Exception {
        HttpResponse httpResponse = null;
        String apiResponse = null;
        try {
            httpResponse =
                HttpAsyncClientUtils.getHttpResponseWithSpecifIp(TaskType.LITIGATION_ITAT_CASE, homePageUrl, new HashMap<>(),
                    90 * 1000, rotationIp);
            apiResponse = getStringResponse(httpResponse);
        } catch (Exception e) {
            logger.error("Failed to fetch bench and appeal type for ITAT", e);
            return;
        } finally {
            if (httpResponse != null) {
                EntityUtils.consumeQuietly(httpResponse.getEntity());
            }
        }
        if (apiResponse == null) {
            return;
        }
        Document doc = Jsoup.parse(apiResponse);
        Element table = doc.select("#tSummary").get(0);
        Elements rows = table.select("tbody tr td");
        setBenches(rows.select("select#bench1 option"));
        setAppealTypes(rows.select("select#appeal_type1 option"));
        benchLastFetchedAt = System.currentTimeMillis();
    }

    private static void setAppealTypes(Elements appealTypesElements) {
        appealTypes = new ArrayList<>();
        Integer flag = 0;
        for (Element appealType : appealTypesElements) {
            if (flag == 0) {
                flag = 1;
                continue;
            }
            String value = appealType.attr("value");
            appealTypes.add(value);
        }
    }

    private static void setBenches(Elements benchesElements) {
        benches = new ArrayList<>();
        Integer flag = 0;
        for (Element bench : benchesElements) {
            if (flag == 0) {
                flag = 1;
                continue;
            }
            String value = bench.attr("value");
            benches.add(value);
        }
    }

    private static Map<String, String> getHeaders(String cookie) {
        HashMap<String, String> headers = new HashMap<>();
        if (ObjectUtils.isNotBlank(cookie)) {
            headers.put("cookie", cookie);
            headers.put("User-Agent","Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like "
                + "Gecko) Chrome/121.0.0.0 Safari/537.36");
        }
        return headers;
    }

    public static String getCleanedNameIfValid(String assesseeName) throws Exception {
        String cleanedAssesseName = LitigationUtils.sanitizeSearchName(assesseeName);
        if (cleanedAssesseName.length() < 3) {
            cleanedAssesseName = removeSpecialCharacters(assesseeName);
        }
        if (cleanedAssesseName.length() < 3) {
            throw new RequestParsingException(
                String.format("Assesseee Name without special characters {%s} must be more than 3 characters",
                    cleanedAssesseName), TaskError.INVALID_INPUT_PARAMETERS);
        }
        return cleanedAssesseName;
    }

    public static String removeSpecialCharacters(String input) {
        input = input.replaceAll("[^a-zA-Z0-9\\s]", "");
        input = input.replaceAll(" +", " ");
        return input.trim();
    }

    private static String getStringResponse(HttpResponse httpResponse) throws IOException {
        if (httpResponse == null) {
            return null;
        }
        BufferedReader reader = null;
        try {
            reader = new BufferedReader(
                new InputStreamReader(httpResponse.getEntity().getContent(), StandardCharsets.UTF_8));
            return reader.lines()
                .collect(Collectors.joining("\n"));
        } catch (Exception e) {
            logger.error("Error while getting String from Response", e);
            return null;
        } finally {
            IOUtils.closeQuietly(reader);
        }
    }

    @Override
    public TaskType getTaskType() {
        return TaskType.LITIGATION_ITAT_CASE;
    }

    public static void main(String[] args) throws Exception {
        List<ItatResponse> adani = getDetails("Adani", UUID.randomUUID().toString());
        System.out.println(adani);
    }
}

package com.ofb.crawler.commons.types.mca.dto;

public class CompanyChargesDataDto {

    private String chargeId;

    private String srn;

    private String chargeHolderName;

    private Long dateOfCreation;

    private Long dateOfModification;

    private Long dateOfSatisfaction;

    private BigDecimal amount;

    private String streetAddress;

    private String streetAddress2;

    private String streetAddress3;

    private String streetAddress4;

    private String country;

    private String locality;

    private String state;

    private String district;

    private String city;

    private Integer postalCode;

    private String registeredName;

    private String propertyIntUnRegdFlag;

    private String chargeName;

    private String chargeStatus;

    public CompanyChargesDataDto() {
    }

    public CompanyChargesDataDto(String chargeId, String srn, String chargeHolderName, Long dateOfCreation,
        Long dateOfModification, Long dateOfSatisfaction, BigDecimal amount, String streetAddress,
        String streetAddress2, String streetAddress3, String streetAddress4, String country, String locality,
        String state, String district, String city, Integer postalCode, String registeredName,
        String propertyIntUnRegdFlag, String chargeName, String chargeStatus) {
        this.chargeId = chargeId;
        this.srn = srn;
        this.chargeHolderName = chargeHolderName;
        this.dateOfCreation = dateOfCreation;
        this.dateOfModification = dateOfModification;
        this.dateOfSatisfaction = dateOfSatisfaction;
        this.amount = amount;
        this.streetAddress = streetAddress;
        this.streetAddress2 = streetAddress2;
        this.streetAddress3 = streetAddress3;
        this.streetAddress4 = streetAddress4;
        this.country = country;
        this.locality = locality;
        this.state = state;
        this.district = district;
        this.city = city;
        this.postalCode = postalCode;
        this.registeredName = registeredName;
        this.propertyIntUnRegdFlag = propertyIntUnRegdFlag;
        this.chargeName = chargeName;
        this.chargeStatus = chargeStatus;
    }

    public String getChargeId() {
        return chargeId;
    }

    public void setChargeId(String chargeId) {
        this.chargeId = chargeId;
    }

    public String getSrn() {
        return srn;
    }

    public void setSrn(String srn) {
        this.srn = srn;
    }

    public String getChargeHolderName() {
        return chargeHolderName;
    }

    public void setChargeHolderName(String chargeHolderName) {
        this.chargeHolderName = chargeHolderName;
    }

    public Long getDateOfCreation() {
        return dateOfCreation;
    }

    public void setDateOfCreation(Long dateOfCreation) {
        this.dateOfCreation = dateOfCreation;
    }

    public Long getDateOfModification() {
        return dateOfModification;
    }

    public void setDateOfModification(Long dateOfModification) {
        this.dateOfModification = dateOfModification;
    }

    public Long getDateOfSatisfaction() {
        return dateOfSatisfaction;
    }

    public void setDateOfSatisfaction(Long dateOfSatisfaction) {
        this.dateOfSatisfaction = dateOfSatisfaction;
    }

    public BigDecimal getAmount() {
        return amount;
    }

    public void setAmount(BigDecimal amount) {
        this.amount = amount;
    }

    public String getStreetAddress() {
        return streetAddress;
    }

    public void setStreetAddress(String streetAddress) {
        this.streetAddress = streetAddress;
    }

    public String getStreetAddress2() {
        return streetAddress2;
    }

    public void setStreetAddress2(String streetAddress2) {
        this.streetAddress2 = streetAddress2;
    }

    public String getStreetAddress3() {
        return streetAddress3;
    }

    public void setStreetAddress3(String streetAddress3) {
        this.streetAddress3 = streetAddress3;
    }

    public String getStreetAddress4() {
        return streetAddress4;
    }

    public void setStreetAddress4(String streetAddress4) {
        this.streetAddress4 = streetAddress4;
    }

    public String getCountry() {
        return country;
    }

    public void setCountry(String country) {
        this.country = country;
    }

    public String getLocality() {
        return locality;
    }

    public void setLocality(String locality) {
        this.locality = locality;
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }

    public String getDistrict() {
        return district;
    }

    public void setDistrict(String district) {
        this.district = district;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public Integer getPostalCode() {
        return postalCode;
    }

    public void setPostalCode(Integer postalCode) {
        this.postalCode = postalCode;
    }

    public String getRegisteredName() {
        return registeredName;
    }

    public void setRegisteredName(String registeredName) {
        this.registeredName = registeredName;
    }

    public String getPropertyIntUnRegdFlag() {
        return propertyIntUnRegdFlag;
    }

    public void setPropertyIntUnRegdFlag(String propertyIntUnRegdFlag) {
        this.propertyIntUnRegdFlag = propertyIntUnRegdFlag;
    }

    public String getChargeName() {
        return chargeName;
    }

    public void setChargeName(String chargeName) {
        this.chargeName = chargeName;
    }

    public String getChargeStatus() {
        return chargeStatus;
    }

    public void setChargeStatus(String chargeStatus) {
        this.chargeStatus = chargeStatus;
    }

    public static interface ChargeIdStep {
        SrnStep withChargeId(String chargeId);
    }

    public static interface SrnStep {
        ChargeHolderNameStep withSrn(String srn);
    }

    public static interface ChargeHolderNameStep {
        DateOfCreationStep withChargeHolderName(String chargeHolderName);
    }

    public static interface DateOfCreationStep {
        DateOfModificationStep withDateOfCreation(Long dateOfCreation);
    }

    public static interface DateOfModificationStep {
        DateOfSatisfactionStep withDateOfModification(Long dateOfModification);
    }

    public static interface DateOfSatisfactionStep {
        AmountStep withDateOfSatisfaction(Long dateOfSatisfaction);
    }

    public static interface AmountStep {
        StreetAddressStep withAmount(BigDecimal amount);
    }

    public static interface StreetAddressStep {
        StreetAddress2Step withStreetAddress(String streetAddress);
    }

    public static interface StreetAddress2Step {
        StreetAddress3Step withStreetAddress2(String streetAddress2);
    }

    public static interface StreetAddress3Step {
        StreetAddress4Step withStreetAddress3(String streetAddress3);
    }

    public static interface StreetAddress4Step {
        CountryStep withStreetAddress4(String streetAddress4);
    }

    public static interface CountryStep {
        LocalityStep withCountry(String country);
    }

    public static interface LocalityStep {
        StateStep withLocality(String locality);
    }

    public static interface StateStep {
        DistrictStep withState(String state);
    }

    public static interface DistrictStep {
        CityStep withDistrict(String district);
    }

    public static interface CityStep {
        PostalCodeStep withCity(String city);
    }

    public static interface PostalCodeStep {
        RegisteredNameStep withPostalCode(Integer postalCode);
    }

    public static interface RegisteredNameStep {
        PropertyIntUnRegdFlagStep withRegisteredName(String registeredName);
    }

    public static interface PropertyIntUnRegdFlagStep {
        ChargeNameStep withPropertyIntUnRegdFlag(String propertyIntUnRegdFlag);
    }

    public static interface ChargeNameStep {
        ChargeStatusStep withChargeName(String chargeName);
    }

    public static interface ChargeStatusStep {
        BuildStep withChargeStatus(String chargeStatus);
    }

    public static interface BuildStep {
        CompanyChargesDataDto build();
    }

    public static class Builder
        implements ChargeIdStep, SrnStep, ChargeHolderNameStep, DateOfCreationStep, DateOfModificationStep,
        DateOfSatisfactionStep, AmountStep, StreetAddressStep, StreetAddress2Step, StreetAddress3Step,
        StreetAddress4Step, CountryStep, LocalityStep, StateStep, DistrictStep, CityStep, PostalCodeStep,
        RegisteredNameStep, PropertyIntUnRegdFlagStep, ChargeNameStep, ChargeStatusStep, BuildStep {
        private String chargeId;
        private String srn;
        private String chargeHolderName;
        private Long dateOfCreation;
        private Long dateOfModification;
        private Long dateOfSatisfaction;
        private BigDecimal amount;
        private String streetAddress;
        private String streetAddress2;
        private String streetAddress3;
        private String streetAddress4;
        private String country;
        private String locality;
        private String state;
        private String district;
        private String city;
        private Integer postalCode;
        private String registeredName;
        private String propertyIntUnRegdFlag;
        private String chargeName;
        private String chargeStatus;

        private Builder() {
        }

        public static ChargeIdStep companyChargesDataDto() {
            return new Builder();
        }

        @Override
        public SrnStep withChargeId(String chargeId) {
            this.chargeId = chargeId;
            return this;
        }

        @Override
        public ChargeHolderNameStep withSrn(String srn) {
            this.srn = srn;
            return this;
        }

        @Override
        public DateOfCreationStep withChargeHolderName(String chargeHolderName) {
            this.chargeHolderName = chargeHolderName;
            return this;
        }

        @Override
        public DateOfModificationStep withDateOfCreation(Long dateOfCreation) {
            this.dateOfCreation = dateOfCreation;
            return this;
        }

        @Override
        public DateOfSatisfactionStep withDateOfModification(Long dateOfModification) {
            this.dateOfModification = dateOfModification;
            return this;
        }

        @Override
        public AmountStep withDateOfSatisfaction(Long dateOfSatisfaction) {
            this.dateOfSatisfaction = dateOfSatisfaction;
            return this;
        }

        @Override
        public StreetAddressStep withAmount(BigDecimal amount) {
            this.amount = amount;
            return this;
        }

        @Override
        public StreetAddress2Step withStreetAddress(String streetAddress) {
            this.streetAddress = streetAddress;
            return this;
        }

        @Override
        public StreetAddress3Step withStreetAddress2(String streetAddress2) {
            this.streetAddress2 = streetAddress2;
            return this;
        }

        @Override
        public StreetAddress4Step withStreetAddress3(String streetAddress3) {
            this.streetAddress3 = streetAddress3;
            return this;
        }

        @Override
        public CountryStep withStreetAddress4(String streetAddress4) {
            this.streetAddress4 = streetAddress4;
            return this;
        }

        @Override
        public LocalityStep withCountry(String country) {
            this.country = country;
            return this;
        }

        @Override
        public StateStep withLocality(String locality) {
            this.locality = locality;
            return this;
        }

        @Override
        public DistrictStep withState(String state) {
            this.state = state;
            return this;
        }

        @Override
        public CityStep withDistrict(String district) {
            this.district = district;
            return this;
        }

        @Override
        public PostalCodeStep withCity(String city) {
            this.city = city;
            return this;
        }

        @Override
        public RegisteredNameStep withPostalCode(Integer postalCode) {
            this.postalCode = postalCode;
            return this;
        }

        @Override
        public PropertyIntUnRegdFlagStep withRegisteredName(String registeredName) {
            this.registeredName = registeredName;
            return this;
        }

        @Override
        public ChargeNameStep withPropertyIntUnRegdFlag(String propertyIntUnRegdFlag) {
            this.propertyIntUnRegdFlag = propertyIntUnRegdFlag;
            return this;
        }

        @Override
        public ChargeStatusStep withChargeName(String chargeName) {
            this.chargeName = chargeName;
            return this;
        }

        @Override
        public BuildStep withChargeStatus(String chargeStatus) {
            this.chargeStatus = chargeStatus;
            return this;
        }

        @Override
        public CompanyChargesDataDto build() {
            return new CompanyChargesDataDto(
                this.chargeId,
                this.srn,
                this.chargeHolderName,
                this.dateOfCreation,
                this.dateOfModification,
                this.dateOfSatisfaction,
                this.amount,
                this.streetAddress,
                this.streetAddress2,
                this.streetAddress3,
                this.streetAddress4,
                this.country,
                this.locality,
                this.state,
                this.district,
                this.city,
                this.postalCode,
                this.registeredName,
                this.propertyIntUnRegdFlag,
                this.chargeName,
                this.chargeStatus
            );
        }
    }
}


package com.ofb.crawler.commons.types.litigation.itat.dto.parsing;

@Data
@NoArgsConstructor
public class ItatParsingResponseDto  extends BaseParsingResponseDto {

    private ItatResponseDto itatResponseDto;

    public ItatParsingResponseDto(ItatResponseDto itatResponseDto) {
        this.itatResponseDto = itatResponseDto;
    }

    public ItatParsingResponseDto(String parsingId, String requestId, TaskType taskType, long parsingTime, ItatResponseDto itatResponseDto) {
        super(parsingId, requestId, taskType, parsingTime);
        this.itatResponseDto = itatResponseDto;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ItatParsingResponseDto that = (ItatParsingResponseDto) o;
        return Objects.equals(itatResponseDto, that.itatResponseDto);
    }

    @Override
    public int hashCode() {
        return Objects.hash(itatResponseDto);
    }

    public static interface ParsingIdStep {
        RequestIdStep withParsingId(String parsingId);
    }

    public static interface RequestIdStep {
        TaskTypeStep withRequestId(String requestId);
    }

    public static interface TaskTypeStep {
        ParsingTimeStep withTaskType(TaskType taskType);
    }

    public static interface ParsingTimeStep {
        ItatResponseDtoStep withParsingTime(long parsingTime);
    }

    public static interface ItatResponseDtoStep {
        BuildStep withItatResponseDto(ItatResponseDto itatResponseDto);
    }

    public static interface BuildStep {
        ItatParsingResponseDto build();
    }


    public static class Builder implements ParsingIdStep, RequestIdStep, TaskTypeStep, ParsingTimeStep, ItatResponseDtoStep, BuildStep {
        private String parsingId;
        private String requestId;
        private TaskType taskType;
        private long parsingTime;
        private ItatResponseDto itatResponseDto;

        private Builder() {
        }

        public static ParsingIdStep itatParsingResponseDto() {
            return new Builder();
        }

        @Override
        public RequestIdStep withParsingId(String parsingId) {
            this.parsingId = parsingId;
            return this;
        }

        @Override
        public TaskTypeStep withRequestId(String requestId) {
            this.requestId = requestId;
            return this;
        }

        @Override
        public ParsingTimeStep withTaskType(TaskType taskType) {
            this.taskType = taskType;
            return this;
        }

        @Override
        public ItatResponseDtoStep withParsingTime(long parsingTime) {
            this.parsingTime = parsingTime;
            return this;
        }

        @Override
        public BuildStep withItatResponseDto(ItatResponseDto itatResponseDto) {
            this.itatResponseDto = itatResponseDto;
            return this;
        }

        @Override
        public ItatParsingResponseDto build() {
            return new ItatParsingResponseDto(
                    this.parsingId,
                    this.requestId,
                    this.taskType,
                    this.parsingTime,
                    this.itatResponseDto
            );
        }
    }
}


package com.ofb.crawler.commons.types.gstReturn.dto.task;

@Data
@NoArgsConstructor
public class GstReturnTaskParamsDto extends BaseTaskParamsDto {

    public GstReturnTaskParamsDto(String requestId, String companyName, String cin, String gstIn) {
        super(requestId, companyName, cin, gstIn);
    }

    public static interface RequestIdStep {
        CompanyNameStep withRequestId(String requestId);
    }

    public static interface CompanyNameStep {
        CinStep withCompanyName(String companyName);
    }

    public static interface CinStep {
        GstInStep withCin(String cin);
    }

    public static interface GstInStep {
        BuildStep withGstIn(String gstIn);
    }

    public static interface BuildStep {
        GstReturnTaskParamsDto build();
    }


    public static class Builder implements RequestIdStep, CompanyNameStep, CinStep, GstInStep, BuildStep {
        private String requestId;
        private String companyName;
        private String cin;
        private String gstIn;

        private Builder() {
        }

        public static RequestIdStep gstReturnTaskParamsDto() {
            return new Builder();
        }

        @Override
        public CompanyNameStep withRequestId(String requestId) {
            this.requestId = requestId;
            return this;
        }

        @Override
        public CinStep withCompanyName(String companyName) {
            this.companyName = companyName;
            return this;
        }

        @Override
        public GstInStep withCin(String cin) {
            this.cin = cin;
            return this;
        }

        @Override
        public BuildStep withGstIn(String gstIn) {
            this.gstIn = gstIn;
            return this;
        }

        @Override
        public GstReturnTaskParamsDto build() {
            return new GstReturnTaskParamsDto(
                    this.requestId,
                    this.companyName,
                    this.cin,
                    this.gstIn
            );
        }
    }
}


package com.ofb.crawler.commons.types.mca.dto.task;

public class McaTaskDto extends BaseTaskDto {

    private String companyName;

    private String cin;

    public McaTaskDto() {
    }

    public McaTaskDto(String requestId, long requestTime, String requestedBy, RequestSource source,
        TaskType taskType, TaskPriority priority, long maxStaleTime,
        TaskStatus status, TaskError error, String callBackUrl,
        boolean isCallbackSuccess, String responseParsingId, String companyName, String cin) {
        super(requestId, requestTime, requestedBy, source, taskType, priority, maxStaleTime, status, error, callBackUrl,
            isCallbackSuccess, responseParsingId);
        this.companyName = companyName;
        this.cin = cin;
    }

    public String getCompanyName() {
        return companyName;
    }

    public void setCompanyName(String companyName) {
        this.companyName = companyName;
    }

    public String getCin() {
        return cin;
    }

    public void setCin(String cin) {
        this.cin = cin;
    }

    public static interface RequestIdStep {
        RequestTimeStep withRequestId(String requestId);
    }

    public static interface RequestTimeStep {
        RequestedByStep withRequestTime(long requestTime);
    }

    public static interface RequestedByStep {
        SourceStep withRequestedBy(String requestedBy);
    }

    public static interface SourceStep {
        TaskTypeStep withSource(RequestSource source);
    }

    public static interface TaskTypeStep {
        PriorityStep withTaskType(TaskType taskType);
    }

    public static interface PriorityStep {
        MaxStaleTimeStep withPriority(TaskPriority priority);
    }

    public static interface MaxStaleTimeStep {
        StatusStep withMaxStaleTime(long maxStaleTime);
    }

    public static interface StatusStep {
        ErrorStep withStatus(TaskStatus status);
    }

    public static interface ErrorStep {
        CallBackUrlStep withError(TaskError error);
    }

    public static interface CallBackUrlStep {
        IsCallbackSuccessStep withCallBackUrl(String callBackUrl);
    }

    public static interface IsCallbackSuccessStep {
        ResponseParsingIdStep withIsCallbackSuccess(boolean isCallbackSuccess);
    }

    public static interface ResponseParsingIdStep {
        CompanyNameStep withResponseParsingId(String responseParsingId);
    }

    public static interface CompanyNameStep {
        CinStep withCompanyName(String companyName);
    }

    public static interface CinStep {
        BuildStep withCin(String cin);
    }

    public static interface BuildStep {
        McaTaskDto build();
    }

    public static class Builder
        implements RequestIdStep, RequestTimeStep, RequestedByStep, SourceStep, TaskTypeStep, PriorityStep,
        MaxStaleTimeStep, StatusStep, ErrorStep, CallBackUrlStep, IsCallbackSuccessStep, ResponseParsingIdStep,
        CompanyNameStep, CinStep, BuildStep {
        private String requestId;
        private long requestTime;
        private String requestedBy;
        private RequestSource source;
        private TaskType taskType;
        private TaskPriority priority;
        private long maxStaleTime;
        private TaskStatus status;
        private TaskError error;
        private String callBackUrl;
        private boolean isCallbackSuccess;
        private String responseParsingId;
        private String companyName;
        private String cin;

        private Builder() {
        }

        public static RequestIdStep mcaTaskDto() {
            return new Builder();
        }

        @Override
        public RequestTimeStep withRequestId(String requestId) {
            this.requestId = requestId;
            return this;
        }

        @Override
        public RequestedByStep withRequestTime(long requestTime) {
            this.requestTime = requestTime;
            return this;
        }

        @Override
        public SourceStep withRequestedBy(String requestedBy) {
            this.requestedBy = requestedBy;
            return this;
        }

        @Override
        public TaskTypeStep withSource(RequestSource source) {
            this.source = source;
            return this;
        }

        @Override
        public PriorityStep withTaskType(TaskType taskType) {
            this.taskType = taskType;
            return this;
        }

        @Override
        public MaxStaleTimeStep withPriority(TaskPriority priority) {
            this.priority = priority;
            return this;
        }

        @Override
        public StatusStep withMaxStaleTime(long maxStaleTime) {
            this.maxStaleTime = maxStaleTime;
            return this;
        }

        @Override
        public ErrorStep withStatus(TaskStatus status) {
            this.status = status;
            return this;
        }

        @Override
        public CallBackUrlStep withError(TaskError error) {
            this.error = error;
            return this;
        }

        @Override
        public IsCallbackSuccessStep withCallBackUrl(String callBackUrl) {
            this.callBackUrl = callBackUrl;
            return this;
        }

        @Override
        public ResponseParsingIdStep withIsCallbackSuccess(boolean isCallbackSuccess) {
            this.isCallbackSuccess = isCallbackSuccess;
            return this;
        }

        @Override
        public CompanyNameStep withResponseParsingId(String responseParsingId) {
            this.responseParsingId = responseParsingId;
            return this;
        }

        @Override
        public CinStep withCompanyName(String companyName) {
            this.companyName = companyName;
            return this;
        }

        @Override
        public BuildStep withCin(String cin) {
            this.cin = cin;
            return this;
        }

        @Override
        public McaTaskDto build() {
            return new McaTaskDto(
                this.requestId,
                this.requestTime,
                this.requestedBy,
                this.source,
                this.taskType,
                this.priority,
                this.maxStaleTime,
                this.status,
                this.error,
                this.callBackUrl,
                this.isCallbackSuccess,
                this.responseParsingId,
                this.companyName,
                this.cin
            );
        }
    }
}


package com.ofb.crawler.commons.types.gstInfo.dto.task;

@Data
@NoArgsConstructor
public class GstInfoTaskDto extends BaseTaskDto {

    private String gstIn;

    public GstInfoTaskDto(String gstIn) {
        this.gstIn = gstIn;
    }

    public GstInfoTaskDto(String requestId, long requestTime, String requestedBy, RequestSource source, TaskType taskType, TaskPriority priority, long maxStaleTime, TaskStatus status, TaskError error, String callBackUrl, boolean isCallbackSuccess, String responseParsingId, String gstIn) {
        super(requestId, requestTime, requestedBy, source, taskType, priority, maxStaleTime, status, error, callBackUrl, isCallbackSuccess, responseParsingId);
        this.gstIn = gstIn;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        GstInfoTaskDto that = (GstInfoTaskDto) o;
        return Objects.equals(gstIn, that.gstIn);
    }

    @Override
    public int hashCode() {
        return Objects.hash(gstIn);
    }

    public static interface RequestIdStep {
        RequestTimeStep withRequestId(String requestId);
    }

    public static interface RequestTimeStep {
        RequestedByStep withRequestTime(long requestTime);
    }

    public static interface RequestedByStep {
        SourceStep withRequestedBy(String requestedBy);
    }

    public static interface SourceStep {
        TaskTypeStep withSource(RequestSource source);
    }

    public static interface TaskTypeStep {
        PriorityStep withTaskType(TaskType taskType);
    }

    public static interface PriorityStep {
        MaxStaleTimeStep withPriority(TaskPriority priority);
    }

    public static interface MaxStaleTimeStep {
        StatusStep withMaxStaleTime(long maxStaleTime);
    }

    public static interface StatusStep {
        ErrorStep withStatus(TaskStatus status);
    }

    public static interface ErrorStep {
        CallBackUrlStep withError(TaskError error);
    }

    public static interface CallBackUrlStep {
        IsCallbackSuccessStep withCallBackUrl(String callBackUrl);
    }

    public static interface IsCallbackSuccessStep {
        ResponseParsingIdStep withIsCallbackSuccess(boolean isCallbackSuccess);
    }

    public static interface ResponseParsingIdStep {
        GstInStep withResponseParsingId(String responseParsingId);
    }

    public static interface GstInStep {
        BuildStep withGstIn(String gstIn);
    }

    public static interface BuildStep {
        GstInfoTaskDto build();
    }


    public static class Builder implements RequestIdStep, RequestTimeStep, RequestedByStep, SourceStep, TaskTypeStep, PriorityStep, MaxStaleTimeStep, StatusStep, ErrorStep, CallBackUrlStep, IsCallbackSuccessStep, ResponseParsingIdStep, GstInStep, BuildStep {
        private String requestId;
        private long requestTime;
        private String requestedBy;
        private RequestSource source;
        private TaskType taskType;
        private TaskPriority priority;
        private long maxStaleTime;
        private TaskStatus status;
        private TaskError error;
        private String callBackUrl;
        private boolean isCallbackSuccess;
        private String responseParsingId;
        private String gstIn;

        private Builder() {
        }

        public static RequestIdStep gstInfoTaskDto() {
            return new Builder();
        }

        @Override
        public RequestTimeStep withRequestId(String requestId) {
            this.requestId = requestId;
            return this;
        }

        @Override
        public RequestedByStep withRequestTime(long requestTime) {
            this.requestTime = requestTime;
            return this;
        }

        @Override
        public SourceStep withRequestedBy(String requestedBy) {
            this.requestedBy = requestedBy;
            return this;
        }

        @Override
        public TaskTypeStep withSource(RequestSource source) {
            this.source = source;
            return this;
        }

        @Override
        public PriorityStep withTaskType(TaskType taskType) {
            this.taskType = taskType;
            return this;
        }

        @Override
        public MaxStaleTimeStep withPriority(TaskPriority priority) {
            this.priority = priority;
            return this;
        }

        @Override
        public StatusStep withMaxStaleTime(long maxStaleTime) {
            this.maxStaleTime = maxStaleTime;
            return this;
        }

        @Override
        public ErrorStep withStatus(TaskStatus status) {
            this.status = status;
            return this;
        }

        @Override
        public CallBackUrlStep withError(TaskError error) {
            this.error = error;
            return this;
        }

        @Override
        public IsCallbackSuccessStep withCallBackUrl(String callBackUrl) {
            this.callBackUrl = callBackUrl;
            return this;
        }

        @Override
        public ResponseParsingIdStep withIsCallbackSuccess(boolean isCallbackSuccess) {
            this.isCallbackSuccess = isCallbackSuccess;
            return this;
        }

        @Override
        public GstInStep withResponseParsingId(String responseParsingId) {
            this.responseParsingId = responseParsingId;
            return this;
        }

        @Override
        public BuildStep withGstIn(String gstIn) {
            this.gstIn = gstIn;
            return this;
        }

        @Override
        public GstInfoTaskDto build() {
            return new GstInfoTaskDto(
                    this.requestId,
                    this.requestTime,
                    this.requestedBy,
                    this.source,
                    this.taskType,
                    this.priority,
                    this.maxStaleTime,
                    this.status,
                    this.error,
                    this.callBackUrl,
                    this.isCallbackSuccess,
                    this.responseParsingId,
                    this.gstIn
            );
        }
    }
}


package com.ofb.crawler.commons.types.gstInfo.dto.response;

public class GstAddressFields {

    private String buildingName;

    private String street;

    private String location;

    private String doorNumber;

    private String stateName;

    private String dst;

    private String city;

    private String floorNumber;

    private String lattitude;

    private String pinCode;

    private String longitude;

    public GstAddressFields() {
    }

    public GstAddressFields(String buildingName, String street, String location,
                            String doorNumber, String stateName, String dst, String city, String floorNumber, String lattitude,
                            String pinCode, String longitude) {
        this.buildingName = buildingName;
        this.street = street;
        this.location = location;
        this.doorNumber = doorNumber;
        this.stateName = stateName;
        this.dst = dst;
        this.city = city;
        this.floorNumber = floorNumber;
        this.lattitude = lattitude;
        this.pinCode = pinCode;
        this.longitude = longitude;
    }

    public String getBuildingName() {
        return buildingName;
    }

    public void setBuildingName(String buildingName) {
        this.buildingName = buildingName;
    }

    public String getStreet() {
        return street;
    }

    public void setStreet(String street) {
        this.street = street;
    }

    public String getLocation() {
        return location;
    }

    public void setLocation(String location) {
        this.location = location;
    }

    public String getDoorNumber() {
        return doorNumber;
    }

    public void setDoorNumber(String doorNumber) {
        this.doorNumber = doorNumber;
    }

    public String getStateName() {
        return stateName;
    }

    public void setStateName(String stateName) {
        this.stateName = stateName;
    }

    public String getDst() {
        return dst;
    }

    public void setDst(String dst) {
        this.dst = dst;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public String getFloorNumber() {
        return floorNumber;
    }

    public void setFloorNumber(String floorNumber) {
        this.floorNumber = floorNumber;
    }

    public String getLattitude() {
        return lattitude;
    }

    public void setLattitude(String lattitude) {
        this.lattitude = lattitude;
    }

    public String getPinCode() {
        return pinCode;
    }

    public void setPinCode(String pinCode) {
        this.pinCode = pinCode;
    }

    public String getLongitude() {
        return longitude;
    }

    public void setLongitude(String longitude) {
        this.longitude = longitude;
    }

    public static interface BuildingNameStep {
        StreetStep withBuildingName(String buildingName);
    }

    public static interface StreetStep {
        LocationStep withStreet(String street);
    }

    public static interface LocationStep {
        DoorNumberStep withLocation(String location);
    }

    public static interface DoorNumberStep {
        StateNameStep withDoorNumber(String doorNumber);
    }

    public static interface StateNameStep {
        DstStep withStateName(String stateName);
    }

    public static interface DstStep {
        CityStep withDst(String dst);
    }

    public static interface CityStep {
        FloorNumberStep withCity(String city);
    }

    public static interface FloorNumberStep {
        LattitudeStep withFloorNumber(String floorNumber);
    }

    public static interface LattitudeStep {
        PinCodeStep withLattitude(String lattitude);
    }

    public static interface PinCodeStep {
        LongitudeStep withPinCode(String pinCode);
    }

    public static interface LongitudeStep {
        BuildStep withLongitude(String longitude);
    }

    public static interface BuildStep {
        GstAddressFields build();
    }

    public static class Builder
            implements BuildingNameStep, StreetStep, LocationStep, DoorNumberStep, StateNameStep, DstStep, CityStep,
            FloorNumberStep, LattitudeStep, PinCodeStep, LongitudeStep, BuildStep {
        private String buildingName;
        private String street;
        private String location;
        private String doorNumber;
        private String stateName;
        private String dst;
        private String city;
        private String floorNumber;
        private String lattitude;
        private String pinCode;
        private String longitude;

        private Builder() {
        }

        public static BuildingNameStep gstAddressSummary() {
            return new Builder();
        }

        @Override
        public StreetStep withBuildingName(String buildingName) {
            this.buildingName = buildingName;
            return this;
        }

        @Override
        public LocationStep withStreet(String street) {
            this.street = street;
            return this;
        }

        @Override
        public DoorNumberStep withLocation(String location) {
            this.location = location;
            return this;
        }

        @Override
        public StateNameStep withDoorNumber(String doorNumber) {
            this.doorNumber = doorNumber;
            return this;
        }

        @Override
        public DstStep withStateName(String stateName) {
            this.stateName = stateName;
            return this;
        }

        @Override
        public CityStep withDst(String dst) {
            this.dst = dst;
            return this;
        }

        @Override
        public FloorNumberStep withCity(String city) {
            this.city = city;
            return this;
        }

        @Override
        public LattitudeStep withFloorNumber(String floorNumber) {
            this.floorNumber = floorNumber;
            return this;
        }

        @Override
        public PinCodeStep withLattitude(String lattitude) {
            this.lattitude = lattitude;
            return this;
        }

        @Override
        public LongitudeStep withPinCode(String pinCode) {
            this.pinCode = pinCode;
            return this;
        }

        @Override
        public BuildStep withLongitude(String longitude) {
            this.longitude = longitude;
            return this;
        }

        @Override
        public GstAddressFields build() {
            return new GstAddressFields(
                    this.buildingName,
                    this.street,
                    this.location,
                    this.doorNumber,
                    this.stateName,
                    this.dst,
                    this.city,
                    this.floorNumber,
                    this.lattitude,
                    this.pinCode,
                    this.longitude
            );
        }
    }
}


package com.ofb.crawler.core.types.epfo.service;

public class EPFUtils implements Comparator<List<String>> {


    public static String dateCompare(String date1, String date2) {
        long d1 = Long.valueOf(date1);
        long d2 = Long.valueOf(date2);
        if (d1 < d2) {
            return date2;
        }
        return date1;
    }

    public static int numerify(String number) {
        number = number.replaceAll(",", "");
        Integer num = Integer.parseInt(number);

        return num;
    }

    public static long dateToTimeFormatter(String date) {
        if (StringUtils.countOccurrencesOf(date, "-") == 1) {
            date = "01-" + date.substring(0, 4) + "20" + date.substring(4) + " 00:00:00";
        }
        if (date.length() == 20) {
            date = date.replace(date.charAt(4), Character.toLowerCase(date.charAt(4)));
            date = date.replace(date.charAt(5), Character.toLowerCase(date.charAt(5)));
            date = dateTimeConverter(date);
            return Timestamp.valueOf(date).getTime();
        }
        return -1L;
    }

    public static String dateTimeConverter(String date) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd-MMM-yyyy HH:mm:ss");
        LocalDateTime dt = LocalDateTime.parse(date, formatter);
        DateTimeFormatter outputFormat = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        String s = dt.format(outputFormat);
        return s;
    }

    @Override
    public int compare(List<String> o1,
                       List<String> o2) {
        String firstString_o1 = o1.get(0);
        String firstString_o2 = o2.get(0);
        return firstString_o1.compareTo(firstString_o2);
    }
}


package com.ofb.crawler.core.util;

public class ProcessUtils {

    public static void destroyProcessSilently(Process process){
        try{
            if(process!=null){
                process.destroyForcibly();
            }
        }catch (Exception ex){

        }
    }

    public static void wget(String url,String downloadLocation){
        Process process=null;
        new File(downloadLocation).getParentFile().mkdirs();
        if(!downloadLocation.startsWith("/")){
            downloadLocation="/data/spider/scripts/"+downloadLocation;
        }
        try{
            String command =
                "curl -L -o "+downloadLocation+" "+url;
            process = Runtime.getRuntime().exec(command);
            process.waitFor(5, TimeUnit.SECONDS);
            if(process.exitValue()==0){
                if(new File(downloadLocation).exists()){
                    return;
                }
            }
            throw new RuntimeException("Could not download");
        } catch (IOException | InterruptedException e) {
            e.printStackTrace();
        } finally {
            if(process!=null){
                destroyProcessSilently(process);
            }
        }
    }
}


package com.ofb.crawler.core.types.masterIndia.service;

@Service
public class MasterIndiaParserCallBack extends BaseParserCallback<MasterIndiaResponseDto, MasterIndiaTaskParamsDto> {

    public static final Logger logger = LoggerFactory.getLogger(MasterIndiaParserCallBack.class);

    private static final SimpleDateFormat DATEFORMATTER = new SimpleDateFormat("dd/MM/yyyy");

    public static final String masterIndiaApiBaseUrl =
        "https:

    @Override public MasterIndiaResponseDto parse(MasterIndiaTaskParamsDto parsingParams) throws Throwable {
        String companyName = parsingParams.getCompanyName();
        HttpResponse httpResponse = null;
        String apiResponse ;
        String searchQuery = companyName;
        try {
            companyName = companyName.replaceAll(" +", " ");
            companyName = companyName.trim().replaceAll(" ", "+");
            String url = masterIndiaApiBaseUrl.concat(companyName);
            HashMap<String,String> apiHeaders = new HashMap<>();
            apiHeaders.put("origin","https:
            httpResponse = HttpAsyncClientUtils.getHttpResponse(TaskType.MASTER_INDIA, url,apiHeaders);
            apiResponse = EntityUtils.toString(httpResponse.getEntity());
        } catch (Exception e) {
            logger.error("Master India API Failed", e);
            return null;
        } finally {
            if (httpResponse != null) {
                EntityUtils.consumeQuietly(httpResponse.getEntity());
            }
        }

        if (httpResponse.getStatusLine().getStatusCode() != 200) {
            return null;
        }
        if (ObjectUtils.isBlankObject(apiResponse)) {
            return null;
        }
        String cleanCompanyName = cleanSearchQuery(searchQuery);
        CompanyProfile companyProfile =  parser(apiResponse, cleanCompanyName);
        return MasterIndiaResponseDto.Builder.masterIndiaResponseDto()
            .withParsingId(String.valueOf(UUID.randomUUID()))
            .withTaskType(getTaskType())
            .withParsingTime(System.currentTimeMillis())
            .withBaseTaskParamsDto(parsingParams)
            .withCompanyProfile(companyProfile)
            .build();
    }

    private CompanyProfile parser(String apiResponse, String companyName) {
        JSONObject jsonResponse = new JSONObject(apiResponse);
        if (ObjectUtils.isBlankObject(jsonResponse.opt("data"))) {
            return null;
        }
        BusinessProfileDto businessProfile = new BusinessProfileDto();
        List<GstInfoDto> gstInfoList = new ArrayList<>();
        List<AddressInfoDto> addressInfoList = new ArrayList<>();
        JSONArray responses = jsonResponse.optJSONArray("data");
        for (int i = 0; i < responses.length(); i++) {
            JSONObject response = responses.optJSONObject(i);
            if (ObjectUtils.isBlankObject(response)) {
                continue;
            }
            String responseCompanyName = response.optString("lgnm");
            if (!cleanSearchQuery(responseCompanyName).equals(companyName)) {
                continue;
            }
            String gstStatus = response.getString("sts");
            if (ObjectUtils.isBlankObject(gstStatus) || !gstStatus.equals("Active")) {
                continue;
            }
            String dateOfRegistration = response.optString("rgdt");
            Long dateOfRegistrationLong = null;
            if (ObjectUtils.isNotBlankObject(dateOfRegistration)) {
                dateOfRegistrationLong = convertGstDate(dateOfRegistration);
            }
            GstInfoDto gstInfo = GstInfoDto
                .Builder
                .gstInfoDto()
                .withGstIn(response.optString("gstin"))
                .withGstStatus(gstStatus)
                .withDateOfRegistration(dateOfRegistrationLong)
                .withEnrichmentSubSource(null)
                .build();

            JSONObject responseAddress = (JSONObject) response.opt("pradr");
            if(ObjectUtils.isNotBlankObject(responseAddress)) {
                JSONObject principalPlaceOfBusiness = responseAddress.optJSONObject("addr");
                if(ObjectUtils.isNotBlankObject(principalPlaceOfBusiness)){
                    AddressInfoDto addressInfo = AddressInfoDto
                        .Builder
                        .addressInfoDto()
                        .withAddressLine(principalPlaceOfBusiness.optString("bno") + " , " +
                            principalPlaceOfBusiness.optString("st"))
                        .withCountry(Country.INDIA.getName())
                        .withState(principalPlaceOfBusiness.optString("stcd"))
                        .withCity(principalPlaceOfBusiness.optString("dst"))
                        .withPinCode(principalPlaceOfBusiness.optString("pncd"))
                        .withLinkedGst(gstInfo.getGstIn())
                        .build();
                    addressInfoList.add(addressInfo);
                }
                if(ObjectUtils.isBlankObject(businessProfile.getNatureOfBusiness())){
                    businessProfile.setNatureOfBusiness(responseAddress.optString("ntr"));
                }
            }
            if(ObjectUtils.isBlankObject(businessProfile.getCompanyName())){
                businessProfile.setCompanyName(responseCompanyName);
                businessProfile.setCompanyLegalName(responseCompanyName);
            }
            gstInfoList.add(gstInfo);
        }
        if(ObjectUtils.isBlankObject(gstInfoList)){
            return null;
        }
        businessProfile.setGstInfo(gstInfoList);
        businessProfile.setAddressInfo(addressInfoList);
        CompanyProfile companyProfile = new CompanyProfile();
        companyProfile.setBusinessProfile(businessProfile);
        companyProfile.setCompanyCrawlingSource(getTaskType().toString());
        return companyProfile;
    }

    private Long convertGstDate(String dateOfRegistration) {
        return DateUtils.tryParseDateToLong(DATEFORMATTER, dateOfRegistration);
    }

    @Override public TaskType getTaskType() {
        return TaskType.MASTER_INDIA;
    }
}


package com.ofb.crawler.commons.dto;

public class PincodeDetail {

    private String pincode;

    private String city;

    private String state;

    public String getPincode() {
        return pincode;
    }

    public void setPincode(String pincode) {
        this.pincode = pincode;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }

    @Override public String toString() {
        return "PincodeDetail{" +
            "city='" + city + '\'' +
            ", state='" + state + '\'' +
            '}';
    }
}


package com.ofb.crawler.commons.util;

public class DateUtils {
    
    public static Date MAX_DATE = new Date(Long.MAX_VALUE);

    public static final long MS_IN_A_DAY = 86400000;

    public static final long MS_TWO_HOURS = 1000L * 60L * 60L * 2L;

    public static final long MS_ONE_HOUR = 1000L * 60L * 60L;

    public static final long MS_FIFTEEN_MIN = 1000L * 60L * 15L;

    public static final String dateRegex = "\\d{4}-\\d{2}-\\d{2}";

    public static final String decimalRegex = "\\d+(\\.\\d+)?";

    public static final long SECOND = 1 * 1000;

    public static final long MINUTE = 60 * SECOND;

    public static final long HOUR = 60 * MINUTE;

    public static final long DAY = 24 * HOUR;

    public static TimeZone GMT_TIMEZONE = TimeZone.getTimeZone("GMT");

    public static final long OFFICE_START_TIME_ON_DAY = 10 * HOUR;

    public static final long OFFICE_SHUT_TIME_ON_DAY = 18 * HOUR;

    public static final long OFFICE_WORKING_HOURS =
        (OFFICE_SHUT_TIME_ON_DAY - OFFICE_START_TIME_ON_DAY);

    public static Pattern datePattern = Pattern.compile(dateRegex);

    public static Pattern decimalPattern = Pattern.compile(decimalRegex);

    public static final SimpleDateFormat dateFormat_HH_mm =
        new SimpleDateFormat("HH:mm");

    public static final SimpleDateFormat dateFormatyyyy_MM_dd_HH_mm_ss_hyphened =
        new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss");

    public static final SimpleDateFormat dateFormatyyyy_MM_dd_HH_mm_ss =
        new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

    public static final SimpleDateFormat dateFormat_MMM_dd_yy_HH_mm =
        new SimpleDateFormat("MMM dd, yy - HH:mm");

    public static final SimpleDateFormat dateFormat_MMMM_yyyy =
        new SimpleDateFormat("MMMM yy");

    public static final SimpleDateFormat dateFormat_dd_MMMM_yyyy =
        new SimpleDateFormat("dd MMMM yyyy");

    public static final SimpleDateFormat dateFormat_dd_MMM_yyyy =
        new SimpleDateFormat("dd MMM yyyy");

    public static final SimpleDateFormat dateFormat_dd_MM_yyyy_HH_mm =
        new SimpleDateFormat("dd-MM-yy,HH:mm");

    public static final SimpleDateFormat dateFormat_dd_MM_yyyy_hh_mm_a =
        new SimpleDateFormat("dd-MM-yy, hh:mm a");

    public static final SimpleDateFormat dateFormat_HH_mm_ss =
        new SimpleDateFormat("HH:mm:ss");

    public static final SimpleDateFormat dateFormat_dd_MMMM_yyyy_hyphened =
        new SimpleDateFormat("yyyy-MM-dd");

    public static final SimpleDateFormat dateFormat_dd_MM =
        new SimpleDateFormat("ddMMM");

    public static final SimpleDateFormat dateFormat_dd_MMM =
        new SimpleDateFormat("dd MMM");

    public static final SimpleDateFormat dateFormat_dd_MMM_yyyy_hyphened =
        new SimpleDateFormat("dd-MMM-yyyy");

    public static final SimpleDateFormat dateFormat_dd_MMM_yyyy_HH_mm_ss_hyphened =
        new SimpleDateFormat("dd-MMM-yyyy HH:mm:ss");

    public static final SimpleDateFormat dateFormat_MMM_yy =
        new SimpleDateFormat("MMM-yy");

    public static final List<String> commonDateFormats = Lists.newArrayList(
        "dd-MM-yyyy",
        "dd.MM.yyyy",
        "dd/MM/yyyy",
        "yyyy-MM-dd",
        "yyyy.MM.dd",
        "yyyy/MM/dd"
    );

    public static final List<SimpleDateFormat> commonSimpleDateFormats = new ArrayList<>();

    static {
        for (String dateFormat : commonDateFormats) {
            commonSimpleDateFormats.add(new SimpleDateFormat(dateFormat));
        }
    }

    private static final DateUtils instance = new DateUtils();

    public static DateUtils getInstance() {
        return instance;
    }

    public static int getCurrentYear() {
        Calendar calendar = Calendar.getInstance();
        return calendar.get(YEAR);
    }

    public static int getYearYYYY(Date date) {
        DateFormat df = new SimpleDateFormat("yyyy");
        return Integer.parseInt(df.format(date));
    }

    public static String getMonthMMM(Date date) {
        return getMonth(date, "MMM");
    }

    public static String getMonth(Date date, String pattern) {
        DateFormat df = new SimpleDateFormat(pattern);
        return df.format(date).toUpperCase();
    }

    public static int getCurrentYearYY() {
        DateFormat df = new SimpleDateFormat("yy");
        return Integer.parseInt(df.format(new Date()));
    }

    public static int getNextYearYY() {
        DateFormat df = new SimpleDateFormat("yy");
        return Integer.parseInt(df.format(new Date())) + 1;
    }

    public static Date getMinutesAfterCurrentTime(int minutesAfter) {
        Calendar calendar = Calendar.getInstance();
        calendar.add(Calendar.MINUTE, minutesAfter);
        return calendar.getTime();
    }

    public static int getCurrentMonth() {
        Calendar calendar = Calendar.getInstance();
        return calendar.get(Calendar.MONTH) + 1;
    }

    public static int getCurrentDate() {
        Calendar calendar = Calendar.getInstance();
        return calendar.get(Calendar.DAY_OF_MONTH);
    }

    public static int getCurrentHour() {
        Calendar calendar = Calendar.getInstance();
        return calendar.get(Calendar.HOUR);
    }

    public static int getCurrentMinutes() {
        Calendar calendar = Calendar.getInstance();
        return calendar.get(Calendar.MINUTE);
    }

    public static String getCurrentYYYYMMDDHHmm() {

        return new StringBuilder()
            .append(getCurrentYear())
            .append("-")
            .append(getCurrentMonth())
            .append("-")
            .append(getCurrentDate())
            .append("_")
            .append(getCurrentHour())
            .append("-")
            .append(getCurrentMinutes())
            .toString();
    }

    public static Date getCurrentDateTime() {
        return new Date();
    }

    public static Date getLastHourStartDateTime() {
        Calendar cal = Calendar.getInstance();
        cal.setTime(getCurrentDateTime());
        cal.set(Calendar.MINUTE, 0);
        cal.set(Calendar.SECOND, 0);
        cal.set(Calendar.MILLISECOND, 0);

        cal.add(Calendar.HOUR_OF_DAY, -1);
        return cal.getTime();
    }

    public static Date getCurrentHourStartDateTime() {
        Calendar cal = Calendar.getInstance();
        cal.setTime(getCurrentDateTime());
        cal.set(Calendar.MINUTE, 0);
        cal.set(Calendar.SECOND, 0);
        cal.set(Calendar.MILLISECOND, 0);
        return cal.getTime();
    }

    public static long getCurrentHourStartMillis() {
        Calendar cal = Calendar.getInstance();
        cal.setTime(getCurrentDateTime());
        cal.set(Calendar.MINUTE, 0);
        cal.set(Calendar.SECOND, 0);
        cal.set(Calendar.MILLISECOND, 0);
        return cal.getTimeInMillis();
    }

    public static long getCurrentTimeInMillis() {
        Calendar cal = Calendar.getInstance();
        cal.setTime(getCurrentDateTime());
        return cal.getTimeInMillis();
    }

    public static Long getLastHourStartMillis() {

        Calendar cal = Calendar.getInstance();
        cal.setTime(getCurrentDateTime());
        cal.set(Calendar.MINUTE, 0);
        cal.set(Calendar.SECOND, 0);
        cal.set(Calendar.MILLISECOND, 0);
        cal.add(Calendar.HOUR_OF_DAY, -1);
        return cal.getTimeInMillis();
    }

    public static Date dateOneDayBefore(Date currentDate) {
        return dateNDaysBefore(currentDate, 1);
    }

    public static Date dateNDaysBefore(Date currentDate, int daysBeforeCurrents) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(currentDate);
        cal.add(DAY_OF_YEAR, -1 * daysBeforeCurrents);
        return cal.getTime();
    }

    public static String formatToPattern(String pattern, long date) {
        SimpleDateFormat sdf = new SimpleDateFormat(pattern);
        return sdf.format(new Date(date));
    }

    public boolean isValidDate(String dateString) {
        SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd");
        try {
            df.parse(dateString);
            return true;
        } catch (ParseException e) {
            return false;
        }
    }

    public static String format(SimpleDateFormat formatter, Date date) {
        return formatter.format(date);
    }

    public static String format(SimpleDateFormat formatter, Long date) {
        return formatter.format(date);
    }

    public static String format(SimpleDateFormat formatter, Long date, String defaultValue) {
        try {
            return formatter.format(date);
        } catch (Exception e) {
        }
        return defaultValue;
    }

    public static String format(SimpleDateFormat formatter, Date date, String defaultValue) {
        try {
            return formatter.format(date);
        } catch (Exception e) {
        }
        return defaultValue;
    }

    
    public static long timeAfterNHours(long currentMills, int nHours) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(new Date(currentMills));
        cal.add(Calendar.HOUR_OF_DAY, nHours);
        return cal.getTime().getTime();
    }

    
    public static long timeAfterNDays(long currentMills, int nDays) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(new Date(currentMills));
        cal.add(Calendar.DAY_OF_MONTH, nDays);
        return cal.getTime().getTime();
    }

    public static long timeAfterNMonths(long currentMills, int nMonths) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(new Date(currentMills));
        cal.add(Calendar.MONTH, nMonths);
        return cal.getTime().getTime();
    }

    public static Date parse(String format, String date) throws ParseException {
        if (StringUtils.isEmpty(date) || StringUtils.isEmpty(format)) {
            return null;
        }
        SimpleDateFormat formatter = new SimpleDateFormat(format);
        return formatter.parse(date);
    }

    public static Date parse(SimpleDateFormat formatter, String date) throws ParseException {
        if (StringUtils.isEmpty(date) || formatter == null) {
            return null;
        }
        return formatter.parse(date);
    }

    public static Date parse(String date) {
        if (StringUtils.isEmpty(date)) {
            return null;
        }
        for (SimpleDateFormat simpleDateFormat : commonSimpleDateFormats) {
            try {
                return simpleDateFormat.parse(date);
            } catch (Throwable ignored) {
            }
        }
        return null;
    }

    public static Date parse(String format, String date, Date defaultValue) {
        Date result = defaultValue;
        try {
            return new SimpleDateFormat(format).parse(date);
        } catch (Exception e) {
            return result;
        }
    }

    public static String format(String format, Date date) {
        if (date == null || StringUtils.isEmpty(format)) {
            return "";
        }

        SimpleDateFormat formatter = new SimpleDateFormat(format);
        return formatter.format(date);
    }

    

    public static String format(String format, long timestamp) {
        if (StringUtils.isEmpty(format) || timestamp <= 0) {
            return "";
        }

        SimpleDateFormat formatter = new SimpleDateFormat(format);
        return formatter.format(new Date(timestamp));
    }

    public static String formatIfTimeGreaterThanZero(String format, Long timestamp) {
        if (StringUtils.isEmpty(format) || timestamp == null || timestamp <= 0) {
            return "";
        }

        SimpleDateFormat formatter = new SimpleDateFormat(format);
        return formatter.format(new Date(timestamp));
    }

    public static long toMillis(Date date) {
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        return calendar.getTimeInMillis();
    }

    public static Date getEODDate(Date date) {
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        calendar.set(Calendar.MILLISECOND, 999);
        calendar.set(Calendar.SECOND, 59);
        calendar.set(Calendar.MINUTE, 59);
        calendar.set(Calendar.HOUR, 23);
        return calendar.getTime();
    }

    public static long getStartOfMonth(long timestamp) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(new Date(timestamp));
        cal.set(Calendar.DATE, 1);
        cal.set(Calendar.HOUR_OF_DAY, 0);
        cal.set(Calendar.MINUTE, 0);
        cal.set(Calendar.SECOND, 0);
        cal.set(Calendar.MILLISECOND, 0);
        long startTimestmap = cal.getTimeInMillis();
        return startTimestmap;
    }

    public static long getEndOfMonth(long timestamp) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(new Date(timestamp));
        cal.set(Calendar.DATE, cal.getActualMaximum(Calendar.DAY_OF_MONTH) - 1);
        cal.set(Calendar.MILLISECOND, 999);
        cal.set(Calendar.SECOND, 59);
        cal.set(Calendar.MINUTE, 59);
        cal.set(Calendar.HOUR, 23);
        long startTimestmap = cal.getTimeInMillis();
        return startTimestmap;
    }

    public static Date getStartOfCurrentYearMinusOneYear() {
        Calendar calendar = Calendar.getInstance();
        calendar.set(Calendar.YEAR, calendar.get(Calendar.YEAR) - 1);
        calendar.set(Calendar.MONTH, 0);
        calendar.set(DAY_OF_MONTH, 1);

        Date date = new Date(calendar.getTimeInMillis());

        
        return date;
    }

    public static long getOfficeStartTime(long day) {
        return getStartOfDay(day) + OFFICE_START_TIME_ON_DAY;
    }

    public static long getOfficeShutTime(long day) {
        return getStartOfDay(day) + OFFICE_SHUT_TIME_ON_DAY;
    }

    public static long normalizeToOfficeTime(long endTime) {
        long officeOpeningTime = getOfficeStartTime(endTime);
        long officeClosingTime = getOfficeShutTime(endTime);
        endTime = Math.min(officeClosingTime, endTime);
        endTime = Math.max(officeOpeningTime, endTime);
        return endTime;
    }

    public static long getWorkedTimeForStartedAt(long startTime) {
        startTime = normalizeToOfficeTime(startTime);
        long officialEndTime = getOfficeShutTime(startTime);
        
        return officialEndTime - startTime;
    }

    public static long getWorkedTimeForEndedAt(long endTime) {
        endTime = normalizeToOfficeTime(endTime);
        long officialStartTime = getOfficeStartTime(endTime);
        return endTime - officialStartTime;
    }

    public static Pair<Long, Long> getStartAndEndOfDayLong(long timestamp) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(new Date(timestamp));
        cal.set(Calendar.HOUR_OF_DAY, 0);
        cal.set(Calendar.MINUTE, 0);
        cal.set(Calendar.SECOND, 0);
        cal.set(Calendar.MILLISECOND, 0);
        long startTimestmap = cal.getTimeInMillis();
        long endTimestamp = startTimestmap + 86400000;
        return new Pair<Long, Long>(startTimestmap, endTimestamp);
    }

    public static Long getStartOfDay(long timestamp) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(new Date(timestamp));
        cal.set(Calendar.HOUR_OF_DAY, 0);
        cal.set(Calendar.MINUTE, 0);
        cal.set(Calendar.SECOND, 0);
        cal.set(Calendar.MILLISECOND, 0);
        long startTimestamp = cal.getTimeInMillis();
        return startTimestamp;
    }

    public static Long getStartOfNextDay(long timestamp) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(new Date(timestamp));
        cal.set(Calendar.HOUR_OF_DAY, 0);
        cal.set(Calendar.MINUTE, 0);
        cal.set(Calendar.SECOND, 0);
        cal.set(Calendar.MILLISECOND, 0);
        long startTimestamp = cal.getTimeInMillis();
        return startTimestamp + 86400000;
    }

    public static Long getStartOfYesterDay(long timestamp) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(new Date(timestamp));
        cal.set(Calendar.HOUR_OF_DAY, 0);
        cal.set(Calendar.MINUTE, 0);
        cal.set(Calendar.SECOND, 0);
        cal.set(Calendar.MILLISECOND, 0);
        long startTimestamp = cal.getTimeInMillis();
        return startTimestamp - DateUtils.DAY;
    }

    public static Long getEndOfDay(long timestamp) {
        
        
        if (timestamp
            > 9007199254740991L) {
            return 9007199254740991L;
        }
        Calendar cal = Calendar.getInstance();
        cal.setTime(new Date(timestamp));
        cal.set(Calendar.HOUR_OF_DAY, 0);
        cal.set(Calendar.MINUTE, 0);
        cal.set(Calendar.SECOND, 0);
        cal.set(Calendar.MILLISECOND, 0);
        long startTimestamp = cal.getTimeInMillis();
        return startTimestamp + 86399999;
    }

    public static String getFinancialYear(Date date) {
        Calendar calander = Calendar.getInstance();
        calander.setTime(date);
        long endYear = calander.get(YEAR);
        if (calander.get(Calendar.MONTH) >= 3) {
            endYear++;
        }
        return String.valueOf(endYear - 1).substring(2) + "-" + String.valueOf(endYear)
            .substring(2);
    }

    public static String getDateMonth(Date date) {
        Calendar calander = Calendar.getInstance();
        calander.setTime(date);
        Calendar cal = Calendar.getInstance();

        return new SimpleDateFormat("MMM").format(cal.getTime());
    }

    public static Date add(Date date, int l, TimeUnit timeUnit) throws CustomException {
        switch (timeUnit) {
            case MILLISECONDS:
                Calendar calendar = Calendar.getInstance();
                calendar.setTime(date);
                calendar.add(Calendar.MILLISECOND, l);
                return calendar.getTime();
            case SECONDS:
                calendar = Calendar.getInstance();
                calendar.setTime(date);
                calendar.add(Calendar.MILLISECOND, l);
                return calendar.getTime();
            case MINUTES:
                calendar = Calendar.getInstance();
                calendar.setTime(date);
                calendar.add(Calendar.MINUTE, l);
                return calendar.getTime();
            case HOURS:
                calendar = Calendar.getInstance();
                calendar.setTime(date);
                calendar.add(Calendar.HOUR, l);
                return calendar.getTime();
            case DAYS:
                calendar = Calendar.getInstance();
                calendar.setTime(date);
                calendar.add(Calendar.DATE, l);
                return calendar.getTime();
            default:
                throw new CustomException("TimeUnit not supported");
        }
    }

    public static boolean isSameDay(long timeStamp1, long timeStamp2) {
        if (timeStamp1 < 0 || timeStamp2 < 0) {
            throw new IllegalArgumentException("Timestamps must not be less than zero");
        }
        return isSameDay(new Date(timeStamp1), new Date(timeStamp2));
    }

    
    public static boolean isSameDay(Date date1, Date date2) {
        if (date1 == null || date2 == null) {
            throw new IllegalArgumentException("The dates must not be null");
        }
        Calendar cal1 = Calendar.getInstance();
        cal1.setTime(date1);
        Calendar cal2 = Calendar.getInstance();
        cal2.setTime(date2);
        return isSameDay(cal1, cal2);
    }

    
    public static boolean isSameDay(Calendar cal1, Calendar cal2) {
        if (cal1 == null || cal2 == null) {
            throw new IllegalArgumentException("The dates must not be null");
        }
        return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&
            cal1.get(YEAR) == cal2.get(YEAR) &&
            cal1.get(DAY_OF_YEAR) == cal2.get(DAY_OF_YEAR));
    }

    
    public static boolean isToday(Date date) {
        return isSameDay(date, Calendar.getInstance().getTime());
    }

    
    public static boolean isToday(Calendar cal) {
        return isSameDay(cal, Calendar.getInstance());
    }

    
    public static boolean isBeforeDay(Date date1, Date date2) {
        if (date1 == null || date2 == null) {
            throw new IllegalArgumentException("The dates must not be null");
        }
        Calendar cal1 = Calendar.getInstance();
        cal1.setTime(date1);
        Calendar cal2 = Calendar.getInstance();
        cal2.setTime(date2);
        return isBeforeDay(cal1, cal2);
    }

    
    public static boolean isBeforeDay(Calendar cal1, Calendar cal2) {
        if (cal1 == null || cal2 == null) {
            throw new IllegalArgumentException("The dates must not be null");
        }
        if (cal1.get(Calendar.ERA) < cal2.get(Calendar.ERA)) return true;
        if (cal1.get(Calendar.ERA) > cal2.get(Calendar.ERA)) return false;
        if (cal1.get(YEAR) < cal2.get(YEAR)) return true;
        if (cal1.get(YEAR) > cal2.get(YEAR)) return false;
        return cal1.get(DAY_OF_YEAR) < cal2.get(DAY_OF_YEAR);
    }

    
    public static boolean isAfterDay(Date date1, Date date2) {
        if (date1 == null || date2 == null) {
            throw new IllegalArgumentException("The dates must not be null");
        }
        Calendar cal1 = Calendar.getInstance();
        cal1.setTime(date1);
        Calendar cal2 = Calendar.getInstance();
        cal2.setTime(date2);
        return isAfterDay(cal1, cal2);
    }

    
    public static boolean isAfterDay(Calendar cal1, Calendar cal2) {
        if (cal1 == null || cal2 == null) {
            throw new IllegalArgumentException("The dates must not be null");
        }
        if (cal1.get(Calendar.ERA) < cal2.get(Calendar.ERA)) return false;
        if (cal1.get(Calendar.ERA) > cal2.get(Calendar.ERA)) return true;
        if (cal1.get(YEAR) < cal2.get(YEAR)) return false;
        if (cal1.get(YEAR) > cal2.get(YEAR)) return true;
        return cal1.get(DAY_OF_YEAR) > cal2.get(DAY_OF_YEAR);
    }

    
    public static boolean isWithinDaysFuture(Date date, int days) {
        if (date == null) {
            throw new IllegalArgumentException("The date must not be null");
        }
        Calendar cal = Calendar.getInstance();
        cal.setTime(date);
        return isWithinDaysFuture(cal, days);
    }

    
    public static boolean isWithinDaysFuture(Calendar cal, int days) {
        if (cal == null) {
            throw new IllegalArgumentException("The date must not be null");
        }
        Calendar today = Calendar.getInstance();
        Calendar future = Calendar.getInstance();
        future.add(DAY_OF_YEAR, days);
        return (isAfterDay(cal, today) && !isAfterDay(cal, future));
    }

    public static Long getStartOfCurrentMonth() {
        Calendar c = Calendar.getInstance();
        c.set(Calendar.DAY_OF_MONTH, 1);
        return getStartOfDay(c.getTime().getTime());
    }

    
    public static Date getStart(Date date) {
        return clearTime(date);
    }

    
    public static Date clearTime(Date date) {
        if (date == null) {
            return null;
        }
        Calendar c = Calendar.getInstance();
        c.setTime(date);
        c.set(Calendar.HOUR_OF_DAY, 0);
        c.set(Calendar.MINUTE, 0);
        c.set(Calendar.SECOND, 0);
        c.set(Calendar.MILLISECOND, 0);
        return c.getTime();
    }

    

    
    public static boolean hasTime(Date date) {
        if (date == null) {
            return false;
        }
        Calendar c = Calendar.getInstance();
        c.setTime(date);
        if (c.get(Calendar.HOUR_OF_DAY) > 0) {
            return true;
        }
        if (c.get(Calendar.MINUTE) > 0) {
            return true;
        }
        if (c.get(Calendar.SECOND) > 0) {
            return true;
        }
        if (c.get(Calendar.MILLISECOND) > 0) {
            return true;
        }
        return false;
    }

    
    public static Date getEnd(Date date) {
        if (date == null) {
            return null;
        }
        Calendar c = Calendar.getInstance();
        c.setTime(date);
        c.set(Calendar.HOUR_OF_DAY, 23);
        c.set(Calendar.MINUTE, 59);
        c.set(Calendar.SECOND, 59);
        c.set(Calendar.MILLISECOND, 999);
        return c.getTime();
    }

    
    public static Date max(Date d1, Date d2) {
        if (d1 == null && d2 == null) return null;
        if (d1 == null) return d2;
        if (d2 == null) return d1;
        return (d1.after(d2)) ? d1 : d2;
    }

    
    public static Date min(Date d1, Date d2) {
        if (d1 == null && d2 == null) return null;
        if (d1 == null) return d2;
        if (d2 == null) return d1;
        return (d1.before(d2)) ? d1 : d2;
    }

    public static long getNumberOfDaysTillDate(Long date) {
        Calendar calendar = Calendar.getInstance();
        Long startOfDayMillis = getStartOfDay(calendar.getTimeInMillis());
        long diff = date - startOfDayMillis;
        return TimeUnit.DAYS.convert(diff, TimeUnit.MILLISECONDS);
    }

    public static String diffInDays(long timeInMillis) {
        Date date1 = new Date(timeInMillis);
        Date date2 = new Date();

        return diffBetweenDates(date1, date2);
    }

    public static String diffBetweenDates(Date date1, Date date2) {
        long difference = date2.getTime() - date1.getTime();
        return timeDiffString(difference);
    }

    public static String timeDiffString(long difference) {
        long daysDifference = (long) floor(difference / DAY);
        difference -= daysDifference * DAY;

        long hoursDifference = (long) floor(difference / HOUR);
        difference -= hoursDifference * HOUR;

        long minutesDifference = (long) floor(difference / MINUTE);
        difference -= minutesDifference * MINUTE;

        long secondsDifference = (long) floor(difference / SECOND);

        int count = 0;
        String diffString = "";
        if (daysDifference > 0) {
            ++count;
            diffString += daysDifference + "d";
        }
        if (hoursDifference > 0) {
            if (diffString != "") {
                diffString += " ";
            }
            ++count;
            diffString += hoursDifference + "h";
        }
        if (count > 1) {
            return diffString;
        }

        if (minutesDifference > 0) {
            if (diffString != "") {
                diffString += " ";
            }
            ++count;
            diffString += minutesDifference + "m";
        }
        if (count > 1) {
            return diffString;
        }
        if (secondsDifference > 0 && minutesDifference < 2) {
            if (diffString != "") {
                diffString += " ";
            }
            diffString += secondsDifference + "s";
        }

        return diffString;
    }

    public static String getReadableElapsedTime(long time) {
        long diffMilliSeconds = System.currentTimeMillis() - time;
        long timeUnit;
        String postString;
        if (diffMilliSeconds < MINUTE) {
            return "few seconds ago";
        } else if (diffMilliSeconds < HOUR) {
            timeUnit = MINUTE;
            postString = " minute";
        } else if (diffMilliSeconds < DAY) {
            timeUnit = HOUR;
            postString = " hour";
        } else {
            timeUnit = DAY;
            postString = " day";
        }

        if (diffMilliSeconds / timeUnit != 1) {
            postString = postString.concat("s");
        }
        return String.valueOf(diffMilliSeconds / timeUnit).concat(postString).concat(" ago");
    }

    public static String timeDiffStringForWorkingHours(long differenceInWorkingHours) {
        if (differenceInWorkingHours < SECOND) {
            return "0s";
        }
        long daysDifference = (long) floor(differenceInWorkingHours / OFFICE_WORKING_HOURS);
        differenceInWorkingHours -= daysDifference * OFFICE_WORKING_HOURS;

        long hoursDifference = (long) floor(differenceInWorkingHours / HOUR);
        differenceInWorkingHours -= hoursDifference * HOUR;

        long minutesDifference = (long) floor(differenceInWorkingHours / MINUTE);
        differenceInWorkingHours -= minutesDifference * MINUTE;

        long secondsDifference = (long) floor(differenceInWorkingHours / SECOND);

        int count = 0;
        String diffString = "";
        if (daysDifference > 0) {
            ++count;
            diffString += daysDifference + "d";
        }
        if (hoursDifference > 0) {
            if (diffString != "") {
                diffString += " ";
            }
            ++count;
            diffString += hoursDifference + "h";
        }
        if (count > 1) {
            return diffString;
        }

        if (minutesDifference > 0) {
            if (diffString != "") {
                diffString += " ";
            }
            ++count;
            diffString += minutesDifference + "m";
        }
        if (count > 1) {
            return diffString;
        }
        if (secondsDifference > 0 && minutesDifference < 2) {
            if (diffString != "") {
                diffString += " ";
            }
            diffString += secondsDifference + "s";
        }

        return diffString;
    }

    public static int getDay(long timeStamp) {
        long startOfMonth = getStartOfMonth(timeStamp);
        return (int) ((timeStamp - startOfMonth) / DAY) + 1;
    }

    public static void chopOffDayTime(Calendar date) {
        date.set(Calendar.HOUR_OF_DAY, 0);
        date.set(Calendar.MINUTE, 0);
        date.set(Calendar.SECOND, 0);
        date.set(Calendar.MILLISECOND, 0);
    }

    public static long numberOfDaysBtw(long fromDate, long toDate, boolean includeFromDay) {
        long difference = getEndOfDay(toDate) - getStartOfDay(fromDate);
        long daysDifference = (long) floor(difference / DAY);
        if (includeFromDay) {
            daysDifference++;
        }
        return daysDifference;
    }

    public static boolean isLeapYear(long timeStamp) {
        final Calendar cal = Calendar.getInstance();
        cal.setTimeInMillis(timeStamp);
        return Year.of(cal.get(YEAR)).isLeap();
    }

    public static int getNumberOfDaysInYear(long timeStamp) {
        final Calendar cal = Calendar.getInstance();
        cal.setTimeInMillis(timeStamp);
        return cal.getActualMaximum(DAY_OF_YEAR);
    }

    public static String correctDateAndTime(String date) {
        if (date != null) {
            return date.substring(0, date.length() - 3);
        }
        return null;
    }

    public static Long convertDateStringToLong(String string, SimpleDateFormat formatter)
        throws ParseException {
        if (StringUtils.isBlank(string)) {
            return null;
        }
        if ((!string.matches("\\d{2}/\\d{2}/\\d{4} \\d{2}:\\d{2}"))) {
            return null;
        }
        return formatter.parse(string).getTime();
    }


    public static Long parseDateToLong(SimpleDateFormat format, String date) throws ParseException {
        return format.parse(date).getTime();
    }

    public static Long parseDateToLong(SimpleDateFormat format, String text, TimeZone timeZone) throws ParseException {
        Calendar calendar =Calendar.getInstance(timeZone);
        Date date=format.parse(text);
        calendar.setTime(date);
        return calendar.getTimeInMillis();
    }


    public static Long tryParseDateToLong(SimpleDateFormat format1,SimpleDateFormat format2, String text, TimeZone timeZone){
        Long date=tryParseDateToLong(format1,text,timeZone);
        if(date==null){
            date=tryParseDateToLong(format2,text,timeZone);
        }
        return date;
    }

    public static Long tryParseDateToLong(SimpleDateFormat format, String text, TimeZone timeZone){
        try{
            return parseDateToLong(format,text,timeZone);
        }catch (Exception e){
            return null;
        }
    }

    public static Long tryParseDateToLong(SimpleDateFormat format,String date) {
        if(StringUtils.isBlank(date)){
            return null;
        }
        try {
            return parseDateToLong(format, date);
        } catch (Exception e) {
            return null;
        }
    }

    public static Long tryParseUsingPattern(SimpleDateFormat sdf, String pattern, String date) {
        Pattern p = Pattern.compile(pattern);
        Matcher m = p.matcher(date);
        while (m.find()) {
            String res = m.group();
            return tryParseDateToLong(sdf, res);
        }
        return null;
    }

    public static TimeZone getTimezoneByCountry(Country country){
        switch (country){
            case SOUTH_KOREA:
                return TimeZone.getTimeZone("Asia/Seoul");
            default:return null;
        }
    }
}


package com.ofb.crawler.commons.types.gstToPan.dto.task;

public class PanToGstTaskParamsDto extends BaseTaskParamsDto {

    private String pan ;

    public PanToGstTaskParamsDto() {
    }

    public PanToGstTaskParamsDto(String requestId, String companyName, String cin, String gstIn, String pan) {
        super(requestId, companyName, cin, gstIn);
        this.pan = pan;
    }

    public String getPan() {
        return pan;
    }

    public void setPan(String pan) {
        this.pan = pan;
    }

    public static interface RequestIdStep {
        CompanyNameStep withRequestId(String requestId);
    }

    public static interface CompanyNameStep {
        CinStep withCompanyName(String companyName);
    }

    public static interface CinStep {
        GstInStep withCin(String cin);
    }

    public static interface GstInStep {
        PanStep withGstIn(String gstIn);
    }

    public static interface PanStep {
        BuildStep withPan(String pan);
    }

    public static interface BuildStep {
        PanToGstTaskParamsDto build();
    }


    public static class Builder implements RequestIdStep, CompanyNameStep, CinStep, GstInStep, PanStep, BuildStep {
        private String requestId;
        private String companyName;
        private String cin;
        private String gstIn;
        private String pan;

        private Builder() {
        }

        public static RequestIdStep panToGstTaskParamsDto() {
            return new Builder();
        }

        @Override
        public CompanyNameStep withRequestId(String requestId) {
            this.requestId = requestId;
            return this;
        }

        @Override
        public CinStep withCompanyName(String companyName) {
            this.companyName = companyName;
            return this;
        }

        @Override
        public GstInStep withCin(String cin) {
            this.cin = cin;
            return this;
        }

        @Override
        public PanStep withGstIn(String gstIn) {
            this.gstIn = gstIn;
            return this;
        }

        @Override
        public BuildStep withPan(String pan) {
            this.pan = pan;
            return this;
        }

        @Override
        public PanToGstTaskParamsDto build() {
            return new PanToGstTaskParamsDto(
                    this.requestId,
                    this.companyName,
                    this.cin,
                    this.gstIn,
                    this.pan
            );
        }
    }
}


package com.ofb.crawler.commons.util;

public class TaskGeneratedEventUtil {

    private static final Logger logger = LoggerFactory.getLogger(TaskGeneratedEventUtil.class);

    private static final String typeForTaskGeneratedQueueListeners = "TASK_GENERATED";

    public static final String JMS_CRAWLER_PREFIX = "CRAWLER.";

    public static void consumeEvent(Request<TaskGeneratedEvent> request, Callback callback, Callback exceptionCallback) throws Exception {

        Long jmsOutTimeStamp = System.currentTimeMillis();
        Long jmsInTimeStamp = null;
        Long timeInBroker = null;
        try {
            jmsInTimeStamp = request.getMessage().getJMSTimestamp();
            timeInBroker = (jmsOutTimeStamp - jmsInTimeStamp);
        } catch (JMSException ignore) {
        }

        TaskGeneratedEvent event = request.getPayload();
        String classNameOfEvent = Optional.ofNullable(event.getClass().getName()).orElse("");
        String eventStr = getEventString(event);

        logger.info(String.format("JMS Received : event message of class [%s] and payload [%s]." +
                " Broker in time [%s], Broker out time [%s], Time in broker [%s] ms",
            classNameOfEvent, eventStr,
            jmsInTimeStamp, jmsOutTimeStamp, timeInBroker));

        if (event.getTaskType().getExecutionThreadCount() > 1) {
            String executorServiceName =
                getExecutorServiceName(TASK_GENERATED_EXECUTOR_PREFIX, event.getTaskType());
            ExecutorService executorService = ExecutorServicesPool.fixedThreadPool(executorServiceName,
                event.getTaskType().getExecutionThreadCount());

            executorService.submit(() -> {
                executeCallbacks(callback, exceptionCallback);
            });
        } else {
            executeCallbacks(callback, exceptionCallback);
        }

        long processingTime = System.currentTimeMillis() - jmsOutTimeStamp;
        logger.info(String.format("JMS Processed : event message of class [%s] and payload [%s]." +
                " Broker in time [%s], Broker out time [%s], Time in broker [%s] ms. Processing time [%s] ms",
            classNameOfEvent, eventStr,
            jmsInTimeStamp, jmsOutTimeStamp, timeInBroker, processingTime));
    }

    public static void executeCallbacks(Callback callback, Callback exceptionCallback) {
        try {
            callback.call();
        } catch (Throwable throwable) {
            logger.error("Exception occurred while executing callback during event consumption {}", throwable);
            try {
                exceptionCallback.call();
            } catch (Throwable throwable1) {
                logger.error("Exception occurred while executing exception callback during event consumption {}",
                    throwable1);
            }
        }
    }

    public static String getJmsDestinationForTaskGeneratedQueue(TaskType taskType, TaskPriority taskPriority) {
        return JMS_CRAWLER_PREFIX + taskType.name() + "." + taskPriority.name();
    }

    public static String getTypeForTaskGeneratedQueueListeners() {
        return typeForTaskGeneratedQueueListeners;
    }

    private static <T> String getEventString(T event) {
        try {
            return ObjectUtils.objectMapper().writeValueAsString(event);
        } catch (JsonProcessingException e) {
            return event.toString();
        }
    }
}


package com.ofb.crawler.commons.types.gstToPan.dto.parsing;

public class PanToGstParsingResponseDto extends BaseParsingResponseDto {
}


package com.ofb.crawler.commons.types.gstInfo.dto.parsing;

@Data
@NoArgsConstructor
public class GstInfoParsingResponseDto extends BaseParsingResponseDto {

    private GstInfoResponseDto gstInfoResponseDto;

    public GstInfoParsingResponseDto(GstInfoResponseDto gstInfoResponseDto) {
        this.gstInfoResponseDto = gstInfoResponseDto;
    }

    public GstInfoParsingResponseDto(String parsingId, String requestId, TaskType taskType, long parsingTime, GstInfoResponseDto gstInfoResponseDto) {
        super(parsingId, requestId, taskType, parsingTime);
        this.gstInfoResponseDto = gstInfoResponseDto;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        GstInfoParsingResponseDto that = (GstInfoParsingResponseDto) o;
        return Objects.equals(gstInfoResponseDto, that.gstInfoResponseDto);
    }

    @Override
    public int hashCode() {
        return Objects.hash(gstInfoResponseDto);
    }

    public static interface ParsingIdStep {
        RequestIdStep withParsingId(String parsingId);
    }

    public static interface RequestIdStep {
        TaskTypeStep withRequestId(String requestId);
    }

    public static interface TaskTypeStep {
        ParsingTimeStep withTaskType(TaskType taskType);
    }

    public static interface ParsingTimeStep {
        GstInfoResponseDtoStep withParsingTime(long parsingTime);
    }

    public static interface GstInfoResponseDtoStep {
        BuildStep withGstInfoResponseDto(GstInfoResponseDto gstInfoResponseDto);
    }

    public static interface BuildStep {
        GstInfoParsingResponseDto build();
    }


    public static class Builder implements ParsingIdStep, RequestIdStep, TaskTypeStep, ParsingTimeStep, GstInfoResponseDtoStep, BuildStep {
        private String parsingId;
        private String requestId;
        private TaskType taskType;
        private long parsingTime;
        private GstInfoResponseDto gstInfoResponseDto;

        private Builder() {
        }

        public static ParsingIdStep gstInfoParsingResponseDto() {
            return new Builder();
        }

        @Override
        public RequestIdStep withParsingId(String parsingId) {
            this.parsingId = parsingId;
            return this;
        }

        @Override
        public TaskTypeStep withRequestId(String requestId) {
            this.requestId = requestId;
            return this;
        }

        @Override
        public ParsingTimeStep withTaskType(TaskType taskType) {
            this.taskType = taskType;
            return this;
        }

        @Override
        public GstInfoResponseDtoStep withParsingTime(long parsingTime) {
            this.parsingTime = parsingTime;
            return this;
        }

        @Override
        public BuildStep withGstInfoResponseDto(GstInfoResponseDto gstInfoResponseDto) {
            this.gstInfoResponseDto = gstInfoResponseDto;
            return this;
        }

        @Override
        public GstInfoParsingResponseDto build() {
            return new GstInfoParsingResponseDto(
                    this.parsingId,
                    this.requestId,
                    this.taskType,
                    this.parsingTime,
                    this.gstInfoResponseDto
            );
        }
    }
}


package com.ofb.crawler.commons.types.mca.dto.task;

public class McaTaskResponseDto extends BaseTaskResponseDto {

    private McaCompanyDetailDto mcaCompanyDetailDto;

    public McaTaskResponseDto() {
    }

    public McaTaskResponseDto(String requestId, TaskType taskType,
        TaskStatus status, TaskError error,
        McaCompanyDetailDto mcaCompanyDetailDto) {
        super(requestId, taskType, status, error);
        this.mcaCompanyDetailDto = mcaCompanyDetailDto;
    }

    public McaCompanyDetailDto getMcaCompanyDetailDto() {
        return mcaCompanyDetailDto;
    }

    public void setMcaCompanyDetailDto(McaCompanyDetailDto mcaCompanyDetailDto) {
        this.mcaCompanyDetailDto = mcaCompanyDetailDto;
    }

    public static interface RequestIdStep {
        TaskTypeStep withRequestId(String requestId);
    }

    public static interface TaskTypeStep {
        StatusStep withTaskType(TaskType taskType);
    }

    public static interface StatusStep {
        ErrorStep withStatus(TaskStatus status);
    }

    public static interface ErrorStep {
        McaCompanyDetailDtoStep withError(TaskError error);
    }

    public static interface McaCompanyDetailDtoStep {
        BuildStep withMcaCompanyDetailDto(McaCompanyDetailDto mcaCompanyDetailDto);
    }

    public static interface BuildStep {
        McaTaskResponseDto build();
    }

    public static class Builder
        implements RequestIdStep, TaskTypeStep, StatusStep, ErrorStep, McaCompanyDetailDtoStep, BuildStep {
        private String requestId;
        private TaskType taskType;
        private TaskStatus status;
        private TaskError error;
        private McaCompanyDetailDto mcaCompanyDetailDto;

        private Builder() {
        }

        public static RequestIdStep mcaTaskResponseDto() {
            return new Builder();
        }

        @Override
        public TaskTypeStep withRequestId(String requestId) {
            this.requestId = requestId;
            return this;
        }

        @Override
        public StatusStep withTaskType(TaskType taskType) {
            this.taskType = taskType;
            return this;
        }

        @Override
        public ErrorStep withStatus(TaskStatus status) {
            this.status = status;
            return this;
        }

        @Override
        public McaCompanyDetailDtoStep withError(TaskError error) {
            this.error = error;
            return this;
        }

        @Override
        public BuildStep withMcaCompanyDetailDto(McaCompanyDetailDto mcaCompanyDetailDto) {
            this.mcaCompanyDetailDto = mcaCompanyDetailDto;
            return this;
        }

        @Override
        public McaTaskResponseDto build() {
            return new McaTaskResponseDto(
                this.requestId,
                this.taskType,
                this.status,
                this.error,
                this.mcaCompanyDetailDto
            );
        }
    }
}


package com.ofb.crawler.core.types.litigation.drt.service;

@Service
public class DrtParserCallback extends BaseParserCallback<DrtDetailDto, DrtTaskParamsDto> {

    private static final Logger logger = LoggerFactory.getLogger(DrtParserCallback.class);
    private static final String BASE_URL = "https:
    private static final String SCHEMA_URL = "https:
    private static final String BASE_DETAIL_URL = "https:
    private static final ObjectMapper OBJECT_MAPPER = ObjectUtils.objectMapper();
    private static final String DATE_FORMAT = "dd/MM/yyyy";
    private static Long MAP_FETCH_TIME = 0L;
    private static final Map<String, String> COURT_ID_TO_NAME_MAP = new HashMap<>();

    @Override
    public TaskType getTaskType() {
        return TaskType.LITIGATION_DRT;
    }

    @Override
    public DrtDetailDto parse(DrtTaskParamsDto parsingParams) throws Throwable {
        return parseDrt(parsingParams);
    }

    private static DrtDetailDto parseDrt(DrtTaskParamsDto parsingParams) throws Throwable {
        String organisationName = parsingParams.getCompanyName();

        List<DrtParsedResult> drtParsedResults = parseByPartyName(organisationName, parsingParams.getRequestId());

        return DrtDetailDto.Builder.drtDetailDto()
                .withParsingId(String.valueOf(UUID.randomUUID()))
                .withTaskType(TaskType.LITIGATION_DRT)
                .withParsingTime(System.currentTimeMillis())
                .withBaseTaskParamsDto(parsingParams)
                .withDrtCases(drtParsedResults)
                .build();
    }

    public static List<DrtParsedResult> parseByPartyName(String originalPartyName, String requestId)
            throws InterruptedException,
            ExecutionException, RequestParsingException {
        String sanitizedPartyName = LitigationUtils.sanitizeSearchName(originalPartyName);
        List<DrtParsedResult> finalDrtSearchResponseList = new ArrayList<>();

        
        Long startTime = System.currentTimeMillis();
        if (ObjectUtils.isBlankObject(COURT_ID_TO_NAME_MAP) || startTime - MAP_FETCH_TIME > DateUtils.DAY * 30) {
            logger.info("Building Court id To Name Map");
            buildCourtIdToNameMap();
            MAP_FETCH_TIME = startTime;
        }
        if (ObjectUtils.isBlankObject(COURT_ID_TO_NAME_MAP)) {
            throw new RequestParsingException("Cannot build courtIdToNameMap", TaskError.SERVER_DOWN);
        }

        ExecutorService executorService = ExecutorServicesPool.fixedThreadPool(requestId, 2);

        try {
            List<Callable<List<DrtParsedResult>>> callableList = new ArrayList<>();
            for (Map.Entry<String, String> entry : COURT_ID_TO_NAME_MAP.entrySet()) {
                callableList.add(() -> {
                    String courtId = entry.getKey();
                    List<DrtParsedResult> drtCases = new ArrayList<>();
                    try {
                        drtCases = getDrtCases(originalPartyName, sanitizedPartyName, courtId, COURT_ID_TO_NAME_MAP.get(courtId));
                    } catch (Exception e) {
                        logger.error("Unable to get Cases for {}, {}, {}", courtId,
                            COURT_ID_TO_NAME_MAP.get(courtId), e);
                    }
                    return drtCases;
                });
            }
            List<Future<List<DrtParsedResult>>> futures = executorService.invokeAll(callableList);
            for (Future<List<DrtParsedResult>> future : futures) {
                List<DrtParsedResult> drtSearchResponses = future.get();
                if (ObjectUtils.isNotBlankObject(drtSearchResponses)) {
                    finalDrtSearchResponseList.addAll(drtSearchResponses);
                }
            }
        } catch (Exception e) {
            logger.error("Error while fetching DRT info", e);
        } finally {
            executorService.shutdown();
        }
        return finalDrtSearchResponseList;
    }

    private static List<DrtParsedResult> getDrtCases(String originalPartyName, String partyName, String courtId, String courtName) throws RequestParsingException {
        List<DrtParsedResult> cases = new ArrayList<>();
        List<NameValuePair> formParams = new ArrayList<>();
        formParams.add(new BasicNameValuePair("schemeNameDratDrtId", courtId));
        formParams.add(new BasicNameValuePair("partyName", partyName));
        String responseFromNameSearchJson = null;
        try {
            responseFromNameSearchJson = HttpAsyncClientUtils.postUnsafeRequestWithForm(TaskType.LITIGATION_DRT, BASE_URL, null, formParams, 60 * 1000);
        } catch (Exception e) {
            logger.error("Parsing Exception : Cannot get Response from DRT URL ", e);
            throw new RequestParsingException("Cannot get Json Response from server", TaskError.SERVER_DOWN);
        }
        if (responseFromNameSearchJson == null || responseFromNameSearchJson.isEmpty() || responseFromNameSearchJson.equals("{\"status\":\"Record Not Fund\"}")) {
            return cases;
        }
        List<CaseDtoFromPartyName> casesFromName = new ArrayList<>();
        try {
            casesFromName = OBJECT_MAPPER.readValue(responseFromNameSearchJson, new TypeReference<List<CaseDtoFromPartyName>>() {
            });
        } catch (Exception e) {
            logger.error("Exception while mapping detailed response in DRT parser callback", e);
            return cases;
        }
        for (CaseDtoFromPartyName caseDtoFromPartyName : casesFromName) {
            String diaryNumberAndYear = caseDtoFromPartyName.getDiaryNo();
            String[] parts = caseDtoFromPartyName.getDiaryNo().split("/");
            String onlyDiaryNumber = parts[0];
            String onlyYear = parts[1];
            List<NameValuePair> formParamsCaeNumber = new ArrayList<>();
            formParamsCaeNumber.add(new BasicNameValuePair("schemeNameDrtId", courtId));
            formParamsCaeNumber.add(new BasicNameValuePair("diaryNo", onlyDiaryNumber));
            formParamsCaeNumber.add(new BasicNameValuePair("diaryYear", onlyYear));
            String detailedResponse = null;
            try {
                detailedResponse = HttpAsyncClientUtils.postUnsafeRequestWithForm(TaskType.LITIGATION_DRT, BASE_DETAIL_URL, null, formParamsCaeNumber, 60 * 1000);
            } catch (Exception e) {
                logger.error("Cannot find detailed report for case " + onlyDiaryNumber + " " + onlyYear + " " + partyName + " " + courtName, e);
            }
            if (detailedResponse == null) {
                continue;
            }
            Map<String, Object> dataMap = new HashMap<>();
            try {
                dataMap = OBJECT_MAPPER.readValue(detailedResponse, new TypeReference<Map<String, Object>>() {
                });
            } catch (Exception e) {
                logger.error("Exception while mapping detailed response in DRT parser callback ", e);
                continue;
            }

            List<Map<String, Object>> caseProceedingMap = (List<Map<String, Object>>) dataMap.get("caseProceedingDetails");

            List<DrtCaseProceedingHistory> caseProceedingHistoryList = new ArrayList<>();

            if (ObjectUtils.isNotBlankObject(caseProceedingMap)) {
                caseProceedingHistoryList = makeCaseProceedingHistoryListFromMap(caseProceedingMap);
            }
            Long lastListedDate = null;
            if (ObjectUtils.isNotBlankObject(caseProceedingHistoryList)) {
                lastListedDate = caseProceedingHistoryList.get(0).getCauseListDate();
            }
            String caseStatusString = (String) dataMap.get("casestatus");
            CaseStatus caseStatus = null;
            if ("DISPOSAL".equals(caseStatusString)) {
                caseStatus = CaseStatus.DISPOSED;
            } else {
                caseStatus = CaseStatus.fromString(caseStatusString);
                caseStatus = caseStatus != CaseStatus.DISPOSED ? CaseStatus.PENDING : caseStatus;
            }
            String petitioner = (String) dataMap.get("petitionerName");
            String respondent = (String) dataMap.get("respondentName");
            DrtParsedResult drtParsedResult = DrtParsedResult.Builder.drtParsedResult()
                    .withPartyName(originalPartyName)
                    .withCourtId(courtId)
                    .withCourtName(courtName)
                    .withDiaryNumber(diaryNumberAndYear)
                    .withCaseType((String) dataMap.get("casetype"))
                    .withCaseNumber((String) dataMap.get("caseno"))
                    .withCaseStatus(caseStatus)
                    .withFilingDate(HtmlParserUtils.getTimeSilently((String) dataMap.get("dateoffiling"), DATE_FORMAT))
                    .withNextListingDate(HtmlParserUtils.getTimeSilently((String) dataMap.get("nextlistingdate"), DATE_FORMAT))
                    .withDisposalDate(HtmlParserUtils.getTimeSilently((String) dataMap.get("dateofdisposal"), DATE_FORMAT))
                    .withLastListed(lastListedDate)
                    .withPetitioner(petitioner)
                    .withRespondent(respondent)
                    .withPartyInvolvement(PartyInvolvement.UNKNOWN)
                    .withPetitionerAdvocate((String) dataMap.get("advocatePetName"))
                    .withRespondentAdvocate((String) dataMap.get("advocateResName"))
                    .withPetitionerAddress((String) dataMap.get("petitionerApplicantAddress"))
                    .withRespondentAddress((String) dataMap.get("respondentDefendentAddress"))
                    .withDetailUrl(null)
                    .withMatchedWith(null)
                    .withSystemAssignedStatus(SystemAssignedStatus.PENDING)
                    .withCaseProceedingHistory(caseProceedingHistoryList)
                    .withTaggedMatters(null)
                    .build();

            Set<String> petetionerSet = new HashSet<>();
            petetionerSet.add(drtParsedResult.getPetitioner());
            Set<String> respondentSet = new HashSet<>();
            respondentSet.add(drtParsedResult.getRespondent());
            InvolvementAndMatchDto
                involvementAndMatchDto = LitigationUtils.getPartyInvolvementAndMatchingStatus(originalPartyName, petetionerSet, respondentSet);
            drtParsedResult.setPartyInvolvement(involvementAndMatchDto.getPartyInvolvement());
            drtParsedResult.setMatchedWith(involvementAndMatchDto.getMatchedWith());
            drtParsedResult.setSystemAssignedStatus(involvementAndMatchDto.getSystemAssignedStatus());
            cases.add(drtParsedResult);

        }
        logger.info(
                "Total cases found from DRT for partyName -> {} , Court Id -> {} , Court Name -> {}, case : {}",
                partyName, courtId, courtName, cases.size());
        return cases;
    }

    private static List<DrtCaseProceedingHistory> makeCaseProceedingHistoryListFromMap(List<Map<String, Object>> caseProceedingMap) {
        List<DrtCaseProceedingHistory> caseProceedingHistoryList = new ArrayList<>();
        for (Map<String, Object> cases : caseProceedingMap) {
            String orderUrl = null;
            if (cases.get("orderUrl") != null) {
                orderUrl = (String) cases.get("orderUrl");
            }
            DrtCaseProceedingHistory drtCaseProceedingHistory = DrtCaseProceedingHistory.Builder.drtCaseProceedingHistory()
                    .withCourtName((String) cases.get("courtName"))
                    .withCauseListDate(HtmlParserUtils.getTimeSilently((String) cases.get("causelistdate"), DATE_FORMAT))
                    .withPurpose((String) cases.get("purpose"))
                    .withOrderUrl(orderUrl)
                    .build();
            caseProceedingHistoryList.add(drtCaseProceedingHistory);
        }
        return caseProceedingHistoryList;
    }

    private static void buildCourtIdToNameMap() throws RequestParsingException {
        String jsonDataSchemaString = null;
        try {
            jsonDataSchemaString = HttpAsyncClientUtils.postUnsafeRequest(TaskType.LITIGATION_DRT, SCHEMA_URL, null, 60 * 1000);
        } catch (Exception e) {
            logger.error("Exception While Building CourtIDtoNameMap", e);
            throw new RequestParsingException("Cannot Build COURT_ID_TO_NAME_MAP in drt parser callback", TaskError.SERVER_DOWN);
        }
        JsonNode jsonDataSchema = convertStringToJsonNode(jsonDataSchemaString);
        if (jsonDataSchema == null) {
            return;
        }
        for (JsonNode drtSchema : jsonDataSchema) {
            if (Integer.parseInt(drtSchema.get("schemeNameDrtId").asText()) >= 100) {
                continue;
            }
            COURT_ID_TO_NAME_MAP.put(drtSchema.get("schemeNameDrtId").asText(), drtSchema.get("SchemaName").asText());
        }
    }

    public static JsonNode convertStringToJsonNode(String jsonString) {
        ObjectMapper objectMapper = new ObjectMapper();
        try {
            return objectMapper.readTree(jsonString);
        } catch (Exception e) {
            logger.error("Caught Exception in while converting String to JsonNode in DRT parser callback", e);
            return null;
        }
    }

    @Data
    private static class CaseDtoFromPartyName {
        @JsonProperty("casetype")
        private String caseType;
        @JsonProperty("caseno")
        private String caseNo;
        @JsonProperty("diaryno")
        private String diaryNo;
        @JsonProperty("dateoffiling")
        private String dateOfFiling;
        @JsonProperty("applicantadvocate")
        private String applicantAdvocate;
        @JsonProperty("respondentadvocate")
        private String respondentAdvocate;
        private String applicant;
        private String respondent;
        private String filingNo;
    }

    public static void main(String[] args)
            throws IOException, ExecutionException, InterruptedException, RequestParsingException, NoSuchAlgorithmException, KeyStoreException, KeyManagementException {
        String partyName = "Reliance";
        long startTime = System.currentTimeMillis();
        List<DrtParsedResult> drtParsedResultList = parseByPartyName(partyName, UUID.randomUUID().toString());
        Set<CaseStatus> caseStatus = drtParsedResultList.stream().map(DrtParsedResult::getCaseStatus).collect(Collectors.toSet());
        System.out.println(System.currentTimeMillis() - startTime);
    }
}


package com.ofb.crawler.commons.util;

public class ExecutorServiceUtil {

    public static final String TASK_GENERATED_EXECUTOR_PREFIX = "TASK_GENERATED";

    public static String getExecutorServiceName(String serviceName, TaskType taskType, TaskPriority taskPriority) {
        return serviceName + "." + taskType.name() + "." + taskPriority.name();
    }

    public static String getExecutorServiceName(String serviceName, TaskType taskType) {
        return serviceName + "." + taskType.name();
    }

    public static void reloadAllExecutorServices() {
        reloadTaskGeneratedExecutors();
    }

    public static void reloadTaskGeneratedExecutors() {
        for (TaskType taskType : TaskType.values()) {
            for (TaskPriority priority : TaskPriority.values()) {
                ExecutorServicesPool.reloadExecutorService(getExecutorServiceName(TASK_GENERATED_EXECUTOR_PREFIX,
                    taskType, priority), taskType.getExecutionThreadCount());
            }
        }
    }

}


package com.ofb.crawler.commons.types.knowYourGst.dto;

@Data
public class KnowYourGstResponseDto extends BaseS3ResponseDto {

    private List<GstInfoDto> gstInfoDtos;

    private KnowYourGstTaskParamsDto knowYourGstTaskParamsDto;

    public KnowYourGstResponseDto() {
    }

    public KnowYourGstResponseDto(String parsingId, TaskType taskType, long parsingTime,
        BaseTaskParamsDto baseTaskParamsDto,
        List<GstInfoDto> gstInfoDtos,
        KnowYourGstTaskParamsDto knowYourGstTaskParamsDto) {
        super(parsingId, taskType, parsingTime, baseTaskParamsDto);
        this.gstInfoDtos = gstInfoDtos;
        this.knowYourGstTaskParamsDto = knowYourGstTaskParamsDto;
    }

    @Override public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
        KnowYourGstResponseDto that = (KnowYourGstResponseDto) o;
        return Objects.equals(gstInfoDtos, that.gstInfoDtos) && Objects.equals(knowYourGstTaskParamsDto,
            that.knowYourGstTaskParamsDto);
    }

    @Override public int hashCode() {
        return Objects.hash(super.hashCode(), gstInfoDtos, knowYourGstTaskParamsDto);
    }

    public static interface ParsingIdStep {
        TaskTypeStep withParsingId(String parsingId);
    }

    public static interface TaskTypeStep {
        ParsingTimeStep withTaskType(TaskType taskType);
    }

    public static interface ParsingTimeStep {
        BaseTaskParamsDtoStep withParsingTime(long parsingTime);
    }

    public static interface BaseTaskParamsDtoStep {
        GstInfoDtosStep withBaseTaskParamsDto(BaseTaskParamsDto baseTaskParamsDto);
    }

    public static interface GstInfoDtosStep {
        KnowYourGstTaskParamsDtoStep withGstInfoDtos(List<GstInfoDto> gstInfoDtos);
    }

    public static interface KnowYourGstTaskParamsDtoStep {
        BuildStep withKnowYourGstTaskParamsDto(KnowYourGstTaskParamsDto knowYourGstTaskParamsDto);
    }

    public static interface BuildStep {
        KnowYourGstResponseDto build();
    }

    public static class Builder
        implements ParsingIdStep, TaskTypeStep, ParsingTimeStep, BaseTaskParamsDtoStep, GstInfoDtosStep,
        KnowYourGstTaskParamsDtoStep, BuildStep {
        private String parsingId;
        private TaskType taskType;
        private long parsingTime;
        private BaseTaskParamsDto baseTaskParamsDto;
        private List<GstInfoDto> gstInfoDtos;
        private KnowYourGstTaskParamsDto knowYourGstTaskParamsDto;

        private Builder() {
        }

        public static ParsingIdStep knowYourGstResponseDto() {
            return new Builder();
        }

        @Override
        public TaskTypeStep withParsingId(String parsingId) {
            this.parsingId = parsingId;
            return this;
        }

        @Override
        public ParsingTimeStep withTaskType(TaskType taskType) {
            this.taskType = taskType;
            return this;
        }

        @Override
        public BaseTaskParamsDtoStep withParsingTime(long parsingTime) {
            this.parsingTime = parsingTime;
            return this;
        }

        @Override
        public GstInfoDtosStep withBaseTaskParamsDto(BaseTaskParamsDto baseTaskParamsDto) {
            this.baseTaskParamsDto = baseTaskParamsDto;
            return this;
        }

        @Override
        public KnowYourGstTaskParamsDtoStep withGstInfoDtos(List<GstInfoDto> gstInfoDtos) {
            this.gstInfoDtos = gstInfoDtos;
            return this;
        }

        @Override
        public BuildStep withKnowYourGstTaskParamsDto(KnowYourGstTaskParamsDto knowYourGstTaskParamsDto) {
            this.knowYourGstTaskParamsDto = knowYourGstTaskParamsDto;
            return this;
        }

        @Override
        public KnowYourGstResponseDto build() {
            return new KnowYourGstResponseDto(
                this.parsingId,
                this.taskType,
                this.parsingTime,
                this.baseTaskParamsDto,
                this.gstInfoDtos,
                this.knowYourGstTaskParamsDto
            );
        }
    }
}


package com.ofb.crawler.commons.dto;

@Data
public class ChargesInfoDto implements Serializable {

    private String chargeId;

    private Long creationDate;

    private Long modificationDate;

    private Long closureDate;

    private Long amount;

    private String assetsUnderCharge;

    private String chargeHolder;

    private String chargeStatus;

    public ChargesInfoDto() {
    }

    public ChargesInfoDto(String chargeId, Long creationDate, Long modificationDate, Long closureDate,
        Long amount, String assetsUnderCharge, String chargeHolder, String chargeStatus) {
        this.chargeId = chargeId;
        this.creationDate = creationDate;
        this.modificationDate = modificationDate;
        this.closureDate = closureDate;
        this.amount = amount;
        this.assetsUnderCharge = assetsUnderCharge;
        this.chargeHolder = chargeHolder;
        this.chargeStatus = chargeStatus;
    }

    @Override public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ChargesInfoDto that = (ChargesInfoDto) o;
        return Objects.equals(chargeId, that.chargeId)
            && Objects.equals(creationDate, that.creationDate)
            && Objects.equals(modificationDate, that.modificationDate)
            && Objects.equals(closureDate, that.closureDate)
            && Objects.equals(amount, that.amount)
            && Objects.equals(assetsUnderCharge, that.assetsUnderCharge)
            && Objects.equals(chargeHolder, that.chargeHolder)
            && Objects.equals(chargeStatus, that.chargeStatus);
    }

    @Override public int hashCode() {
        return Objects.hash(chargeId, creationDate, modificationDate, closureDate, amount, assetsUnderCharge,
            chargeHolder,
            chargeStatus);
    }

    public static interface ChargeIdStep {
        CreationDateStep withChargeId(String chargeId);
    }

    public static interface CreationDateStep {
        ModificationDateStep withCreationDate(Long creationDate);
    }

    public static interface ModificationDateStep {
        ClosureDateStep withModificationDate(Long modificationDate);
    }

    public static interface ClosureDateStep {
        AmountStep withClosureDate(Long closureDate);
    }

    public static interface AmountStep {
        AssetsUnderChargeStep withAmount(Long amount);
    }

    public static interface AssetsUnderChargeStep {
        ChargeHolderStep withAssetsUnderCharge(String assetsUnderCharge);
    }

    public static interface ChargeHolderStep {
        ChargeStatusStep withChargeHolder(String chargeHolder);
    }

    public static interface ChargeStatusStep {
        BuildStep withChargeStatus(String chargeStatus);
    }

    public static interface BuildStep {
        ChargesInfoDto build();
    }

    public static class Builder
        implements ChargeIdStep, CreationDateStep, ModificationDateStep, ClosureDateStep, AmountStep,
        AssetsUnderChargeStep, ChargeHolderStep, ChargeStatusStep, BuildStep {
        private String chargeId;
        private Long creationDate;
        private Long modificationDate;
        private Long closureDate;
        private Long amount;
        private String assetsUnderCharge;
        private String chargeHolder;
        private String chargeStatus;

        private Builder() {
        }

        public static ChargeIdStep chargesInfoDto() {
            return new Builder();
        }

        @Override
        public CreationDateStep withChargeId(String chargeId) {
            this.chargeId = chargeId;
            return this;
        }

        @Override
        public ModificationDateStep withCreationDate(Long creationDate) {
            this.creationDate = creationDate;
            return this;
        }

        @Override
        public ClosureDateStep withModificationDate(Long modificationDate) {
            this.modificationDate = modificationDate;
            return this;
        }

        @Override
        public AmountStep withClosureDate(Long closureDate) {
            this.closureDate = closureDate;
            return this;
        }

        @Override
        public AssetsUnderChargeStep withAmount(Long amount) {
            this.amount = amount;
            return this;
        }

        @Override
        public ChargeHolderStep withAssetsUnderCharge(String assetsUnderCharge) {
            this.assetsUnderCharge = assetsUnderCharge;
            return this;
        }

        @Override
        public ChargeStatusStep withChargeHolder(String chargeHolder) {
            this.chargeHolder = chargeHolder;
            return this;
        }

        @Override
        public BuildStep withChargeStatus(String chargeStatus) {
            this.chargeStatus = chargeStatus;
            return this;
        }

        @Override
        public ChargesInfoDto build() {
            return new ChargesInfoDto(
                this.chargeId,
                this.creationDate,
                this.modificationDate,
                this.closureDate,
                this.amount,
                this.assetsUnderCharge,
                this.chargeHolder,
                this.chargeStatus
            );
        }
    }
}


package com.ofb.crawler.commons.types.mca.dto;

@Data
@EqualsAndHashCode
@ToString
public class CompanyDetailDto {

    private String detailUrl;

    private BasicDetail basicDetail;

    private FinancialDetail financialDetail;

    private List<DirectorDetail> directorDetails;

    private ContactDetail contactDetail;

    private ComplianceDetail complianceDetail;

    private List<ChargesDetail> chargesDetail ;

    private EstablishmentDetail establishmentDetail ;

    private List<SimilarCompanyDetail> similarCompanyDetail;

    public CompanyDetailDto() {
    }

    public CompanyDetailDto(String detailUrl, BasicDetail basicDetail,
        FinancialDetail financialDetail,
        List<DirectorDetail> directorDetails, ContactDetail contactDetail,
        ComplianceDetail complianceDetail,
        List<ChargesDetail> chargesDetail, EstablishmentDetail establishmentDetail,
        List<SimilarCompanyDetail> similarCompanyDetail) {
        this.detailUrl = detailUrl;
        this.basicDetail = basicDetail;
        this.financialDetail = financialDetail;
        this.directorDetails = directorDetails;
        this.contactDetail = contactDetail;
        this.complianceDetail = complianceDetail;
        this.chargesDetail = chargesDetail;
        this.establishmentDetail = establishmentDetail;
        this.similarCompanyDetail = similarCompanyDetail;
    }

    public static interface DetailUrlStep {
        BasicDetailStep withDetailUrl(String detailUrl);
    }

    public static interface BasicDetailStep {
        FinancialDetailStep withBasicDetail(BasicDetail basicDetail);
    }

    public static interface FinancialDetailStep {
        DirectorDetailsStep withFinancialDetail(FinancialDetail financialDetail);
    }

    public static interface DirectorDetailsStep {
        ContactDetailStep withDirectorDetails(List<DirectorDetail> directorDetails);
    }

    public static interface ContactDetailStep {
        ComplianceDetailStep withContactDetail(ContactDetail contactDetail);
    }

    public static interface ComplianceDetailStep {
        ChargesDetailStep withComplianceDetail(ComplianceDetail complianceDetail);
    }

    public static interface ChargesDetailStep {
        EstablishmentDetailStep withChargesDetail(List<ChargesDetail> chargesDetail);
    }

    public static interface EstablishmentDetailStep {
        SimilarCompanyDetailStep withEstablishmentDetail(EstablishmentDetail establishmentDetail);
    }

    public static interface SimilarCompanyDetailStep {
        BuildStep withSimilarCompanyDetail(List<SimilarCompanyDetail> similarCompanyDetail);
    }

    public static interface BuildStep {
        CompanyDetailDto build();
    }

    public static class Builder
        implements DetailUrlStep, BasicDetailStep, FinancialDetailStep, DirectorDetailsStep, ContactDetailStep,
        ComplianceDetailStep, ChargesDetailStep, EstablishmentDetailStep, SimilarCompanyDetailStep, BuildStep {
        private String detailUrl;
        private BasicDetail basicDetail;
        private FinancialDetail financialDetail;
        private List<DirectorDetail> directorDetails;
        private ContactDetail contactDetail;
        private ComplianceDetail complianceDetail;
        private List<ChargesDetail> chargesDetail;
        private EstablishmentDetail establishmentDetail;
        private List<SimilarCompanyDetail> similarCompanyDetail;

        private Builder() {
        }

        public static DetailUrlStep companyDetailDto() {
            return new Builder();
        }

        @Override
        public BasicDetailStep withDetailUrl(String detailUrl) {
            this.detailUrl = detailUrl;
            return this;
        }

        @Override
        public FinancialDetailStep withBasicDetail(BasicDetail basicDetail) {
            this.basicDetail = basicDetail;
            return this;
        }

        @Override
        public DirectorDetailsStep withFinancialDetail(FinancialDetail financialDetail) {
            this.financialDetail = financialDetail;
            return this;
        }

        @Override
        public ContactDetailStep withDirectorDetails(List<DirectorDetail> directorDetails) {
            this.directorDetails = directorDetails;
            return this;
        }

        @Override
        public ComplianceDetailStep withContactDetail(ContactDetail contactDetail) {
            this.contactDetail = contactDetail;
            return this;
        }

        @Override
        public ChargesDetailStep withComplianceDetail(ComplianceDetail complianceDetail) {
            this.complianceDetail = complianceDetail;
            return this;
        }

        @Override
        public EstablishmentDetailStep withChargesDetail(List<ChargesDetail> chargesDetail) {
            this.chargesDetail = chargesDetail;
            return this;
        }

        @Override
        public SimilarCompanyDetailStep withEstablishmentDetail(EstablishmentDetail establishmentDetail) {
            this.establishmentDetail = establishmentDetail;
            return this;
        }

        @Override
        public BuildStep withSimilarCompanyDetail(List<SimilarCompanyDetail> similarCompanyDetail) {
            this.similarCompanyDetail = similarCompanyDetail;
            return this;
        }

        @Override
        public CompanyDetailDto build() {
            return new CompanyDetailDto(
                this.detailUrl,
                this.basicDetail,
                this.financialDetail,
                this.directorDetails,
                this.contactDetail,
                this.complianceDetail,
                this.chargesDetail,
                this.establishmentDetail,
                this.similarCompanyDetail
            );
        }
    }

    @Override public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        CompanyDetailDto that = (CompanyDetailDto) o;
        return Objects.equals(detailUrl, that.detailUrl)
            && Objects.equals(basicDetail, that.basicDetail)
            && Objects.equals(financialDetail, that.financialDetail)
            && Objects.equals(directorDetails, that.directorDetails)
            && Objects.equals(contactDetail, that.contactDetail)
            && Objects.equals(complianceDetail, that.complianceDetail)
            && Objects.equals(chargesDetail, that.chargesDetail)
            && Objects.equals(establishmentDetail, that.establishmentDetail)
            && Objects.equals(similarCompanyDetail, that.similarCompanyDetail);
    }

    @Override public int hashCode() {
        return Objects.hash(detailUrl, basicDetail, financialDetail, directorDetails, contactDetail, complianceDetail,
            chargesDetail, establishmentDetail, similarCompanyDetail);
    }
}


package com.ofb.crawler.commons.types.gstInfo.dto.parsing;

@Data
@NoArgsConstructor
public class GstInfoParsingDto extends BaseParsingDto {

    private String gstIn;

    public GstInfoParsingDto(String parsingId, String requestId, TaskType taskType, long parsingTime, String responseUrl, String gstIn) {
        super(parsingId, requestId, taskType, parsingTime, responseUrl);
        this.gstIn = gstIn;
    }

    public static interface ParsingIdStep {
        RequestIdStep withParsingId(String parsingId);
    }

    public static interface RequestIdStep {
        TaskTypeStep withRequestId(String requestId);
    }

    public static interface TaskTypeStep {
        ParsingTimeStep withTaskType(TaskType taskType);
    }

    public static interface ParsingTimeStep {
        ResponseUrlStep withParsingTime(long parsingTime);
    }

    public static interface ResponseUrlStep {
        GstInStep withResponseUrl(String responseUrl);
    }

    public static interface GstInStep {
        BuildStep withGstIn(String gstIn);
    }

    public static interface BuildStep {
        GstInfoParsingDto build();
    }


    public static class Builder implements ParsingIdStep, RequestIdStep, TaskTypeStep, ParsingTimeStep, ResponseUrlStep, GstInStep, BuildStep {
        private String parsingId;
        private String requestId;
        private TaskType taskType;
        private long parsingTime;
        private String responseUrl;
        private String gstIn;

        private Builder() {
        }

        public static ParsingIdStep gstInfoParsingDto() {
            return new Builder();
        }

        @Override
        public RequestIdStep withParsingId(String parsingId) {
            this.parsingId = parsingId;
            return this;
        }

        @Override
        public TaskTypeStep withRequestId(String requestId) {
            this.requestId = requestId;
            return this;
        }

        @Override
        public ParsingTimeStep withTaskType(TaskType taskType) {
            this.taskType = taskType;
            return this;
        }

        @Override
        public ResponseUrlStep withParsingTime(long parsingTime) {
            this.parsingTime = parsingTime;
            return this;
        }

        @Override
        public GstInStep withResponseUrl(String responseUrl) {
            this.responseUrl = responseUrl;
            return this;
        }

        @Override
        public BuildStep withGstIn(String gstIn) {
            this.gstIn = gstIn;
            return this;
        }

        @Override
        public GstInfoParsingDto build() {
            return new GstInfoParsingDto(
                    this.parsingId,
                    this.requestId,
                    this.taskType,
                    this.parsingTime,
                    this.responseUrl,
                    this.gstIn
            );
        }
    }
}


